Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COLON
    COMMENT
    DECLARATION
    DIVIDE
    ELSE
    EQ
    FOR
    GT
    GTE
    IF
    INSTRUCTION
    LT
    LTE
    MULTIPLY
    NEQ
    NUMBER
    VAR_GLOBAL

Grammar

Rule 0     S' -> statement
Rule 1     statement -> type declaration_list SEMICOLON
Rule 2     statement -> CONST type ID EQUALS expression SEMICOLON
Rule 3     declaration_list -> declaration
Rule 4     declaration_list -> declaration COMMA declaration_list
Rule 5     declaration -> ID
Rule 6     declaration -> ID EQUALS expression
Rule 7     statement -> ID EQUALS expression SEMICOLON
Rule 8     type -> INT_TYPE
Rule 9     type -> FLOAT_TYPE
Rule 10    type -> BOOL_TYPE
Rule 11    type -> CHAR_TYPE
Rule 12    factor -> INTEGER
Rule 13    factor -> FLOAT
Rule 14    factor -> CHAR
Rule 15    factor -> BOOL
Rule 16    factor -> MINUS factor
Rule 17    factor -> PLUS factor
Rule 18    factor -> LPAREN INTEGER RPAREN
Rule 19    factor -> LPAREN FLOAT RPAREN
Rule 20    factor -> LPAREN MINUS FLOAT RPAREN
Rule 21    statements -> statement
Rule 22    statements -> statement statements
Rule 23    statement -> simple_assignment
Rule 24    statement -> array_declarationTab
Rule 25    statement -> array_assignment
Rule 26    statement -> type declarationTab_listTab SEMICOLON
Rule 27    statement -> const_declarationTab
Rule 28    simple_assignment -> ID EQUALS expressionTab SEMICOLON
Rule 29    const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON
Rule 30    array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON
Rule 31    declarationTab_listTab -> declarationTab
Rule 32    declarationTab_listTab -> declarationTab COMMA declarationTab_listTab
Rule 33    declarationTab -> ID
Rule 34    declarationTab -> ID EQUALS expressionTab
Rule 35    declarationTab -> ID LBRACKET INTEGER RBRACKET
Rule 36    expressionTab -> ID
Rule 37    expressionTab -> FLOAT
Rule 38    expressionTab -> INTEGER
Rule 39    expressionTab -> CHAR
Rule 40    factor -> ID LBRACKET expressionTab RBRACKET
Rule 41    array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON
Rule 42    expression -> expression OR term
Rule 43    expression -> term
Rule 44    term -> term AND factor
Rule 45    term -> factor
Rule 46    factor -> ID
Rule 47    factor -> TRUE
Rule 48    factor -> FALSE
Rule 49    factor -> NOT ID

Terminals, with rules where they appear

AND                  : 44
BOOL                 : 15
BOOL_TYPE            : 10
CHAR                 : 14 39
CHAR_TYPE            : 11
COLON                : 
COMMA                : 4 32
COMMENT              : 
CONST                : 2 29
DECLARATION          : 
DIVIDE               : 
ELSE                 : 
EQ                   : 
EQUALS               : 2 6 7 28 29 34 41
FALSE                : 48
FLOAT                : 13 19 20 37
FLOAT_TYPE           : 9
FOR                  : 
GT                   : 
GTE                  : 
ID                   : 2 5 6 7 28 29 30 33 34 35 36 40 41 46 49
IF                   : 
INSTRUCTION          : 
INTEGER              : 12 18 30 35 38
INT_TYPE             : 8
LBRACKET             : 30 35 40 41
LPAREN               : 18 19 20
LT                   : 
LTE                  : 
MINUS                : 16 20
MULTIPLY             : 
NEQ                  : 
NOT                  : 49
NUMBER               : 
OR                   : 42
PLUS                 : 17
RBRACKET             : 30 35 40 41
RPAREN               : 18 19 20
SEMICOLON            : 1 2 7 26 28 29 30 41
TRUE                 : 47
VAR_GLOBAL           : 
error                : 

Nonterminals, with rules where they appear

array_assignment     : 25
array_declarationTab : 24
const_declarationTab : 27
declaration          : 3 4
declarationTab       : 31 32
declarationTab_listTab : 26 32
declaration_list     : 1 4
expression           : 2 6 7 42
expressionTab        : 28 29 34 40 41 41
factor               : 16 17 44 45
simple_assignment    : 23
statement            : 21 22 0
statements           : 22
term                 : 42 43 44
type                 : 1 2 26 29 30

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . type declaration_list SEMICOLON
    (2) statement -> . CONST type ID EQUALS expression SEMICOLON
    (7) statement -> . ID EQUALS expression SEMICOLON
    (23) statement -> . simple_assignment
    (24) statement -> . array_declarationTab
    (25) statement -> . array_assignment
    (26) statement -> . type declarationTab_listTab SEMICOLON
    (27) statement -> . const_declarationTab
    (8) type -> . INT_TYPE
    (9) type -> . FLOAT_TYPE
    (10) type -> . BOOL_TYPE
    (11) type -> . CHAR_TYPE
    (28) simple_assignment -> . ID EQUALS expressionTab SEMICOLON
    (30) array_declarationTab -> . type ID LBRACKET INTEGER RBRACKET SEMICOLON
    (41) array_assignment -> . ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON
    (29) const_declarationTab -> . CONST type ID EQUALS expressionTab SEMICOLON

    CONST           shift and go to state 3
    ID              shift and go to state 4
    INT_TYPE        shift and go to state 9
    FLOAT_TYPE      shift and go to state 10
    BOOL_TYPE       shift and go to state 11
    CHAR_TYPE       shift and go to state 12

    statement                      shift and go to state 1
    type                           shift and go to state 2
    simple_assignment              shift and go to state 5
    array_declarationTab           shift and go to state 6
    array_assignment               shift and go to state 7
    const_declarationTab           shift and go to state 8

state 1

    (0) S' -> statement .



state 2

    (1) statement -> type . declaration_list SEMICOLON
    (26) statement -> type . declarationTab_listTab SEMICOLON
    (30) array_declarationTab -> type . ID LBRACKET INTEGER RBRACKET SEMICOLON
    (3) declaration_list -> . declaration
    (4) declaration_list -> . declaration COMMA declaration_list
    (31) declarationTab_listTab -> . declarationTab
    (32) declarationTab_listTab -> . declarationTab COMMA declarationTab_listTab
    (5) declaration -> . ID
    (6) declaration -> . ID EQUALS expression
    (33) declarationTab -> . ID
    (34) declarationTab -> . ID EQUALS expressionTab
    (35) declarationTab -> . ID LBRACKET INTEGER RBRACKET

    ID              shift and go to state 15

    declaration_list               shift and go to state 13
    declarationTab_listTab         shift and go to state 14
    declaration                    shift and go to state 16
    declarationTab                 shift and go to state 17

state 3

    (2) statement -> CONST . type ID EQUALS expression SEMICOLON
    (29) const_declarationTab -> CONST . type ID EQUALS expressionTab SEMICOLON
    (8) type -> . INT_TYPE
    (9) type -> . FLOAT_TYPE
    (10) type -> . BOOL_TYPE
    (11) type -> . CHAR_TYPE

    INT_TYPE        shift and go to state 9
    FLOAT_TYPE      shift and go to state 10
    BOOL_TYPE       shift and go to state 11
    CHAR_TYPE       shift and go to state 12

    type                           shift and go to state 18

state 4

    (7) statement -> ID . EQUALS expression SEMICOLON
    (28) simple_assignment -> ID . EQUALS expressionTab SEMICOLON
    (41) array_assignment -> ID . LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON

    EQUALS          shift and go to state 19
    LBRACKET        shift and go to state 20


state 5

    (23) statement -> simple_assignment .

    $end            reduce using rule 23 (statement -> simple_assignment .)


state 6

    (24) statement -> array_declarationTab .

    $end            reduce using rule 24 (statement -> array_declarationTab .)


state 7

    (25) statement -> array_assignment .

    $end            reduce using rule 25 (statement -> array_assignment .)


state 8

    (27) statement -> const_declarationTab .

    $end            reduce using rule 27 (statement -> const_declarationTab .)


state 9

    (8) type -> INT_TYPE .

    ID              reduce using rule 8 (type -> INT_TYPE .)


state 10

    (9) type -> FLOAT_TYPE .

    ID              reduce using rule 9 (type -> FLOAT_TYPE .)


state 11

    (10) type -> BOOL_TYPE .

    ID              reduce using rule 10 (type -> BOOL_TYPE .)


state 12

    (11) type -> CHAR_TYPE .

    ID              reduce using rule 11 (type -> CHAR_TYPE .)


state 13

    (1) statement -> type declaration_list . SEMICOLON

    SEMICOLON       shift and go to state 21


state 14

    (26) statement -> type declarationTab_listTab . SEMICOLON

    SEMICOLON       shift and go to state 22


state 15

    (30) array_declarationTab -> type ID . LBRACKET INTEGER RBRACKET SEMICOLON
    (5) declaration -> ID .
    (6) declaration -> ID . EQUALS expression
    (33) declarationTab -> ID .
    (34) declarationTab -> ID . EQUALS expressionTab
    (35) declarationTab -> ID . LBRACKET INTEGER RBRACKET

  ! reduce/reduce conflict for COMMA resolved using rule 5 (declaration -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 5 (declaration -> ID .)
    LBRACKET        shift and go to state 23
    COMMA           reduce using rule 5 (declaration -> ID .)
    SEMICOLON       reduce using rule 5 (declaration -> ID .)
    EQUALS          shift and go to state 24

  ! COMMA           [ reduce using rule 33 (declarationTab -> ID .) ]
  ! SEMICOLON       [ reduce using rule 33 (declarationTab -> ID .) ]


state 16

    (3) declaration_list -> declaration .
    (4) declaration_list -> declaration . COMMA declaration_list

    SEMICOLON       reduce using rule 3 (declaration_list -> declaration .)
    COMMA           shift and go to state 25


state 17

    (31) declarationTab_listTab -> declarationTab .
    (32) declarationTab_listTab -> declarationTab . COMMA declarationTab_listTab

    SEMICOLON       reduce using rule 31 (declarationTab_listTab -> declarationTab .)
    COMMA           shift and go to state 26


state 18

    (2) statement -> CONST type . ID EQUALS expression SEMICOLON
    (29) const_declarationTab -> CONST type . ID EQUALS expressionTab SEMICOLON

    ID              shift and go to state 27


state 19

    (7) statement -> ID EQUALS . expression SEMICOLON
    (28) simple_assignment -> ID EQUALS . expressionTab SEMICOLON
    (42) expression -> . expression OR term
    (43) expression -> . term
    (36) expressionTab -> . ID
    (37) expressionTab -> . FLOAT
    (38) expressionTab -> . INTEGER
    (39) expressionTab -> . CHAR
    (44) term -> . term AND factor
    (45) term -> . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (40) factor -> . ID LBRACKET expressionTab RBRACKET
    (46) factor -> . ID
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . NOT ID

    ID              shift and go to state 28
    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 33
    CHAR            shift and go to state 34
    BOOL            shift and go to state 36
    MINUS           shift and go to state 37
    PLUS            shift and go to state 38
    LPAREN          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    NOT             shift and go to state 42

    expression                     shift and go to state 29
    expressionTab                  shift and go to state 30
    term                           shift and go to state 31
    factor                         shift and go to state 35

state 20

    (41) array_assignment -> ID LBRACKET . expressionTab RBRACKET EQUALS expressionTab SEMICOLON
    (36) expressionTab -> . ID
    (37) expressionTab -> . FLOAT
    (38) expressionTab -> . INTEGER
    (39) expressionTab -> . CHAR

    ID              shift and go to state 43
    FLOAT           shift and go to state 45
    INTEGER         shift and go to state 46
    CHAR            shift and go to state 47

    expressionTab                  shift and go to state 44

state 21

    (1) statement -> type declaration_list SEMICOLON .

    $end            reduce using rule 1 (statement -> type declaration_list SEMICOLON .)


state 22

    (26) statement -> type declarationTab_listTab SEMICOLON .

    $end            reduce using rule 26 (statement -> type declarationTab_listTab SEMICOLON .)


state 23

    (30) array_declarationTab -> type ID LBRACKET . INTEGER RBRACKET SEMICOLON
    (35) declarationTab -> ID LBRACKET . INTEGER RBRACKET

    INTEGER         shift and go to state 48


state 24

    (6) declaration -> ID EQUALS . expression
    (34) declarationTab -> ID EQUALS . expressionTab
    (42) expression -> . expression OR term
    (43) expression -> . term
    (36) expressionTab -> . ID
    (37) expressionTab -> . FLOAT
    (38) expressionTab -> . INTEGER
    (39) expressionTab -> . CHAR
    (44) term -> . term AND factor
    (45) term -> . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (40) factor -> . ID LBRACKET expressionTab RBRACKET
    (46) factor -> . ID
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . NOT ID

    ID              shift and go to state 28
    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 33
    CHAR            shift and go to state 34
    BOOL            shift and go to state 36
    MINUS           shift and go to state 37
    PLUS            shift and go to state 38
    LPAREN          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    NOT             shift and go to state 42

    expression                     shift and go to state 49
    expressionTab                  shift and go to state 50
    term                           shift and go to state 31
    factor                         shift and go to state 35

state 25

    (4) declaration_list -> declaration COMMA . declaration_list
    (3) declaration_list -> . declaration
    (4) declaration_list -> . declaration COMMA declaration_list
    (5) declaration -> . ID
    (6) declaration -> . ID EQUALS expression

    ID              shift and go to state 52

    declaration                    shift and go to state 16
    declaration_list               shift and go to state 51

state 26

    (32) declarationTab_listTab -> declarationTab COMMA . declarationTab_listTab
    (31) declarationTab_listTab -> . declarationTab
    (32) declarationTab_listTab -> . declarationTab COMMA declarationTab_listTab
    (33) declarationTab -> . ID
    (34) declarationTab -> . ID EQUALS expressionTab
    (35) declarationTab -> . ID LBRACKET INTEGER RBRACKET

    ID              shift and go to state 54

    declarationTab                 shift and go to state 17
    declarationTab_listTab         shift and go to state 53

state 27

    (2) statement -> CONST type ID . EQUALS expression SEMICOLON
    (29) const_declarationTab -> CONST type ID . EQUALS expressionTab SEMICOLON

    EQUALS          shift and go to state 55


state 28

    (36) expressionTab -> ID .
    (40) factor -> ID . LBRACKET expressionTab RBRACKET
    (46) factor -> ID .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 36 (expressionTab -> ID .)
  ! reduce/reduce conflict for COMMA resolved using rule 36 (expressionTab -> ID .)
    SEMICOLON       reduce using rule 36 (expressionTab -> ID .)
    COMMA           reduce using rule 36 (expressionTab -> ID .)
    LBRACKET        shift and go to state 56
    AND             reduce using rule 46 (factor -> ID .)
    OR              reduce using rule 46 (factor -> ID .)

  ! SEMICOLON       [ reduce using rule 46 (factor -> ID .) ]
  ! COMMA           [ reduce using rule 46 (factor -> ID .) ]


state 29

    (7) statement -> ID EQUALS expression . SEMICOLON
    (42) expression -> expression . OR term

    SEMICOLON       shift and go to state 57
    OR              shift and go to state 58


state 30

    (28) simple_assignment -> ID EQUALS expressionTab . SEMICOLON

    SEMICOLON       shift and go to state 59


state 31

    (43) expression -> term .
    (44) term -> term . AND factor

    SEMICOLON       reduce using rule 43 (expression -> term .)
    OR              reduce using rule 43 (expression -> term .)
    COMMA           reduce using rule 43 (expression -> term .)
    AND             shift and go to state 60


state 32

    (37) expressionTab -> FLOAT .
    (13) factor -> FLOAT .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 13 (factor -> FLOAT .)
  ! reduce/reduce conflict for COMMA resolved using rule 13 (factor -> FLOAT .)
    AND             reduce using rule 13 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 13 (factor -> FLOAT .)
    OR              reduce using rule 13 (factor -> FLOAT .)
    COMMA           reduce using rule 13 (factor -> FLOAT .)

  ! SEMICOLON       [ reduce using rule 37 (expressionTab -> FLOAT .) ]
  ! COMMA           [ reduce using rule 37 (expressionTab -> FLOAT .) ]


state 33

    (38) expressionTab -> INTEGER .
    (12) factor -> INTEGER .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 12 (factor -> INTEGER .)
  ! reduce/reduce conflict for COMMA resolved using rule 12 (factor -> INTEGER .)
    AND             reduce using rule 12 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 12 (factor -> INTEGER .)
    OR              reduce using rule 12 (factor -> INTEGER .)
    COMMA           reduce using rule 12 (factor -> INTEGER .)

  ! SEMICOLON       [ reduce using rule 38 (expressionTab -> INTEGER .) ]
  ! COMMA           [ reduce using rule 38 (expressionTab -> INTEGER .) ]


state 34

    (39) expressionTab -> CHAR .
    (14) factor -> CHAR .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 14 (factor -> CHAR .)
  ! reduce/reduce conflict for COMMA resolved using rule 14 (factor -> CHAR .)
    AND             reduce using rule 14 (factor -> CHAR .)
    SEMICOLON       reduce using rule 14 (factor -> CHAR .)
    OR              reduce using rule 14 (factor -> CHAR .)
    COMMA           reduce using rule 14 (factor -> CHAR .)

  ! SEMICOLON       [ reduce using rule 39 (expressionTab -> CHAR .) ]
  ! COMMA           [ reduce using rule 39 (expressionTab -> CHAR .) ]


state 35

    (45) term -> factor .

    AND             reduce using rule 45 (term -> factor .)
    SEMICOLON       reduce using rule 45 (term -> factor .)
    OR              reduce using rule 45 (term -> factor .)
    COMMA           reduce using rule 45 (term -> factor .)


state 36

    (15) factor -> BOOL .

    AND             reduce using rule 15 (factor -> BOOL .)
    SEMICOLON       reduce using rule 15 (factor -> BOOL .)
    OR              reduce using rule 15 (factor -> BOOL .)
    COMMA           reduce using rule 15 (factor -> BOOL .)


state 37

    (16) factor -> MINUS . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (40) factor -> . ID LBRACKET expressionTab RBRACKET
    (46) factor -> . ID
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . NOT ID

    INTEGER         shift and go to state 62
    FLOAT           shift and go to state 63
    CHAR            shift and go to state 64
    BOOL            shift and go to state 36
    MINUS           shift and go to state 37
    PLUS            shift and go to state 38
    LPAREN          shift and go to state 39
    ID              shift and go to state 65
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    NOT             shift and go to state 42

    factor                         shift and go to state 61

state 38

    (17) factor -> PLUS . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (40) factor -> . ID LBRACKET expressionTab RBRACKET
    (46) factor -> . ID
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . NOT ID

    INTEGER         shift and go to state 62
    FLOAT           shift and go to state 63
    CHAR            shift and go to state 64
    BOOL            shift and go to state 36
    MINUS           shift and go to state 37
    PLUS            shift and go to state 38
    LPAREN          shift and go to state 39
    ID              shift and go to state 65
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    NOT             shift and go to state 42

    factor                         shift and go to state 66

state 39

    (18) factor -> LPAREN . INTEGER RPAREN
    (19) factor -> LPAREN . FLOAT RPAREN
    (20) factor -> LPAREN . MINUS FLOAT RPAREN

    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    MINUS           shift and go to state 69


state 40

    (47) factor -> TRUE .

    AND             reduce using rule 47 (factor -> TRUE .)
    SEMICOLON       reduce using rule 47 (factor -> TRUE .)
    OR              reduce using rule 47 (factor -> TRUE .)
    COMMA           reduce using rule 47 (factor -> TRUE .)


state 41

    (48) factor -> FALSE .

    AND             reduce using rule 48 (factor -> FALSE .)
    SEMICOLON       reduce using rule 48 (factor -> FALSE .)
    OR              reduce using rule 48 (factor -> FALSE .)
    COMMA           reduce using rule 48 (factor -> FALSE .)


state 42

    (49) factor -> NOT . ID

    ID              shift and go to state 70


state 43

    (36) expressionTab -> ID .

    RBRACKET        reduce using rule 36 (expressionTab -> ID .)
    COMMA           reduce using rule 36 (expressionTab -> ID .)
    SEMICOLON       reduce using rule 36 (expressionTab -> ID .)


state 44

    (41) array_assignment -> ID LBRACKET expressionTab . RBRACKET EQUALS expressionTab SEMICOLON

    RBRACKET        shift and go to state 71


state 45

    (37) expressionTab -> FLOAT .

    RBRACKET        reduce using rule 37 (expressionTab -> FLOAT .)
    COMMA           reduce using rule 37 (expressionTab -> FLOAT .)
    SEMICOLON       reduce using rule 37 (expressionTab -> FLOAT .)


state 46

    (38) expressionTab -> INTEGER .

    RBRACKET        reduce using rule 38 (expressionTab -> INTEGER .)
    COMMA           reduce using rule 38 (expressionTab -> INTEGER .)
    SEMICOLON       reduce using rule 38 (expressionTab -> INTEGER .)


state 47

    (39) expressionTab -> CHAR .

    RBRACKET        reduce using rule 39 (expressionTab -> CHAR .)
    COMMA           reduce using rule 39 (expressionTab -> CHAR .)
    SEMICOLON       reduce using rule 39 (expressionTab -> CHAR .)


state 48

    (30) array_declarationTab -> type ID LBRACKET INTEGER . RBRACKET SEMICOLON
    (35) declarationTab -> ID LBRACKET INTEGER . RBRACKET

    RBRACKET        shift and go to state 72


state 49

    (6) declaration -> ID EQUALS expression .
    (42) expression -> expression . OR term

    COMMA           reduce using rule 6 (declaration -> ID EQUALS expression .)
    SEMICOLON       reduce using rule 6 (declaration -> ID EQUALS expression .)
    OR              shift and go to state 58


state 50

    (34) declarationTab -> ID EQUALS expressionTab .

    COMMA           reduce using rule 34 (declarationTab -> ID EQUALS expressionTab .)
    SEMICOLON       reduce using rule 34 (declarationTab -> ID EQUALS expressionTab .)


state 51

    (4) declaration_list -> declaration COMMA declaration_list .

    SEMICOLON       reduce using rule 4 (declaration_list -> declaration COMMA declaration_list .)


state 52

    (5) declaration -> ID .
    (6) declaration -> ID . EQUALS expression

    COMMA           reduce using rule 5 (declaration -> ID .)
    SEMICOLON       reduce using rule 5 (declaration -> ID .)
    EQUALS          shift and go to state 73


state 53

    (32) declarationTab_listTab -> declarationTab COMMA declarationTab_listTab .

    SEMICOLON       reduce using rule 32 (declarationTab_listTab -> declarationTab COMMA declarationTab_listTab .)


state 54

    (33) declarationTab -> ID .
    (34) declarationTab -> ID . EQUALS expressionTab
    (35) declarationTab -> ID . LBRACKET INTEGER RBRACKET

    COMMA           reduce using rule 33 (declarationTab -> ID .)
    SEMICOLON       reduce using rule 33 (declarationTab -> ID .)
    EQUALS          shift and go to state 74
    LBRACKET        shift and go to state 75


state 55

    (2) statement -> CONST type ID EQUALS . expression SEMICOLON
    (29) const_declarationTab -> CONST type ID EQUALS . expressionTab SEMICOLON
    (42) expression -> . expression OR term
    (43) expression -> . term
    (36) expressionTab -> . ID
    (37) expressionTab -> . FLOAT
    (38) expressionTab -> . INTEGER
    (39) expressionTab -> . CHAR
    (44) term -> . term AND factor
    (45) term -> . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (40) factor -> . ID LBRACKET expressionTab RBRACKET
    (46) factor -> . ID
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . NOT ID

    ID              shift and go to state 28
    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 33
    CHAR            shift and go to state 34
    BOOL            shift and go to state 36
    MINUS           shift and go to state 37
    PLUS            shift and go to state 38
    LPAREN          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    NOT             shift and go to state 42

    expression                     shift and go to state 76
    expressionTab                  shift and go to state 77
    term                           shift and go to state 31
    factor                         shift and go to state 35

state 56

    (40) factor -> ID LBRACKET . expressionTab RBRACKET
    (36) expressionTab -> . ID
    (37) expressionTab -> . FLOAT
    (38) expressionTab -> . INTEGER
    (39) expressionTab -> . CHAR

    ID              shift and go to state 43
    FLOAT           shift and go to state 45
    INTEGER         shift and go to state 46
    CHAR            shift and go to state 47

    expressionTab                  shift and go to state 78

state 57

    (7) statement -> ID EQUALS expression SEMICOLON .

    $end            reduce using rule 7 (statement -> ID EQUALS expression SEMICOLON .)


state 58

    (42) expression -> expression OR . term
    (44) term -> . term AND factor
    (45) term -> . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (40) factor -> . ID LBRACKET expressionTab RBRACKET
    (46) factor -> . ID
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . NOT ID

    INTEGER         shift and go to state 62
    FLOAT           shift and go to state 63
    CHAR            shift and go to state 64
    BOOL            shift and go to state 36
    MINUS           shift and go to state 37
    PLUS            shift and go to state 38
    LPAREN          shift and go to state 39
    ID              shift and go to state 65
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    NOT             shift and go to state 42

    term                           shift and go to state 79
    factor                         shift and go to state 35

state 59

    (28) simple_assignment -> ID EQUALS expressionTab SEMICOLON .

    $end            reduce using rule 28 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)


state 60

    (44) term -> term AND . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (40) factor -> . ID LBRACKET expressionTab RBRACKET
    (46) factor -> . ID
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . NOT ID

    INTEGER         shift and go to state 62
    FLOAT           shift and go to state 63
    CHAR            shift and go to state 64
    BOOL            shift and go to state 36
    MINUS           shift and go to state 37
    PLUS            shift and go to state 38
    LPAREN          shift and go to state 39
    ID              shift and go to state 65
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    NOT             shift and go to state 42

    factor                         shift and go to state 80

state 61

    (16) factor -> MINUS factor .

    AND             reduce using rule 16 (factor -> MINUS factor .)
    SEMICOLON       reduce using rule 16 (factor -> MINUS factor .)
    OR              reduce using rule 16 (factor -> MINUS factor .)
    COMMA           reduce using rule 16 (factor -> MINUS factor .)


state 62

    (12) factor -> INTEGER .

    AND             reduce using rule 12 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 12 (factor -> INTEGER .)
    OR              reduce using rule 12 (factor -> INTEGER .)
    COMMA           reduce using rule 12 (factor -> INTEGER .)


state 63

    (13) factor -> FLOAT .

    AND             reduce using rule 13 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 13 (factor -> FLOAT .)
    OR              reduce using rule 13 (factor -> FLOAT .)
    COMMA           reduce using rule 13 (factor -> FLOAT .)


state 64

    (14) factor -> CHAR .

    AND             reduce using rule 14 (factor -> CHAR .)
    SEMICOLON       reduce using rule 14 (factor -> CHAR .)
    OR              reduce using rule 14 (factor -> CHAR .)
    COMMA           reduce using rule 14 (factor -> CHAR .)


state 65

    (40) factor -> ID . LBRACKET expressionTab RBRACKET
    (46) factor -> ID .

    LBRACKET        shift and go to state 56
    AND             reduce using rule 46 (factor -> ID .)
    SEMICOLON       reduce using rule 46 (factor -> ID .)
    OR              reduce using rule 46 (factor -> ID .)
    COMMA           reduce using rule 46 (factor -> ID .)


state 66

    (17) factor -> PLUS factor .

    AND             reduce using rule 17 (factor -> PLUS factor .)
    SEMICOLON       reduce using rule 17 (factor -> PLUS factor .)
    OR              reduce using rule 17 (factor -> PLUS factor .)
    COMMA           reduce using rule 17 (factor -> PLUS factor .)


state 67

    (18) factor -> LPAREN INTEGER . RPAREN

    RPAREN          shift and go to state 81


state 68

    (19) factor -> LPAREN FLOAT . RPAREN

    RPAREN          shift and go to state 82


state 69

    (20) factor -> LPAREN MINUS . FLOAT RPAREN

    FLOAT           shift and go to state 83


state 70

    (49) factor -> NOT ID .

    AND             reduce using rule 49 (factor -> NOT ID .)
    SEMICOLON       reduce using rule 49 (factor -> NOT ID .)
    OR              reduce using rule 49 (factor -> NOT ID .)
    COMMA           reduce using rule 49 (factor -> NOT ID .)


state 71

    (41) array_assignment -> ID LBRACKET expressionTab RBRACKET . EQUALS expressionTab SEMICOLON

    EQUALS          shift and go to state 84


state 72

    (30) array_declarationTab -> type ID LBRACKET INTEGER RBRACKET . SEMICOLON
    (35) declarationTab -> ID LBRACKET INTEGER RBRACKET .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 85
    COMMA           reduce using rule 35 (declarationTab -> ID LBRACKET INTEGER RBRACKET .)

  ! SEMICOLON       [ reduce using rule 35 (declarationTab -> ID LBRACKET INTEGER RBRACKET .) ]


state 73

    (6) declaration -> ID EQUALS . expression
    (42) expression -> . expression OR term
    (43) expression -> . term
    (44) term -> . term AND factor
    (45) term -> . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (40) factor -> . ID LBRACKET expressionTab RBRACKET
    (46) factor -> . ID
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . NOT ID

    INTEGER         shift and go to state 62
    FLOAT           shift and go to state 63
    CHAR            shift and go to state 64
    BOOL            shift and go to state 36
    MINUS           shift and go to state 37
    PLUS            shift and go to state 38
    LPAREN          shift and go to state 39
    ID              shift and go to state 65
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    NOT             shift and go to state 42

    expression                     shift and go to state 49
    term                           shift and go to state 31
    factor                         shift and go to state 35

state 74

    (34) declarationTab -> ID EQUALS . expressionTab
    (36) expressionTab -> . ID
    (37) expressionTab -> . FLOAT
    (38) expressionTab -> . INTEGER
    (39) expressionTab -> . CHAR

    ID              shift and go to state 43
    FLOAT           shift and go to state 45
    INTEGER         shift and go to state 46
    CHAR            shift and go to state 47

    expressionTab                  shift and go to state 50

state 75

    (35) declarationTab -> ID LBRACKET . INTEGER RBRACKET

    INTEGER         shift and go to state 86


state 76

    (2) statement -> CONST type ID EQUALS expression . SEMICOLON
    (42) expression -> expression . OR term

    SEMICOLON       shift and go to state 87
    OR              shift and go to state 58


state 77

    (29) const_declarationTab -> CONST type ID EQUALS expressionTab . SEMICOLON

    SEMICOLON       shift and go to state 88


state 78

    (40) factor -> ID LBRACKET expressionTab . RBRACKET

    RBRACKET        shift and go to state 89


state 79

    (42) expression -> expression OR term .
    (44) term -> term . AND factor

    SEMICOLON       reduce using rule 42 (expression -> expression OR term .)
    OR              reduce using rule 42 (expression -> expression OR term .)
    COMMA           reduce using rule 42 (expression -> expression OR term .)
    AND             shift and go to state 60


state 80

    (44) term -> term AND factor .

    AND             reduce using rule 44 (term -> term AND factor .)
    SEMICOLON       reduce using rule 44 (term -> term AND factor .)
    OR              reduce using rule 44 (term -> term AND factor .)
    COMMA           reduce using rule 44 (term -> term AND factor .)


state 81

    (18) factor -> LPAREN INTEGER RPAREN .

    AND             reduce using rule 18 (factor -> LPAREN INTEGER RPAREN .)
    SEMICOLON       reduce using rule 18 (factor -> LPAREN INTEGER RPAREN .)
    OR              reduce using rule 18 (factor -> LPAREN INTEGER RPAREN .)
    COMMA           reduce using rule 18 (factor -> LPAREN INTEGER RPAREN .)


state 82

    (19) factor -> LPAREN FLOAT RPAREN .

    AND             reduce using rule 19 (factor -> LPAREN FLOAT RPAREN .)
    SEMICOLON       reduce using rule 19 (factor -> LPAREN FLOAT RPAREN .)
    OR              reduce using rule 19 (factor -> LPAREN FLOAT RPAREN .)
    COMMA           reduce using rule 19 (factor -> LPAREN FLOAT RPAREN .)


state 83

    (20) factor -> LPAREN MINUS FLOAT . RPAREN

    RPAREN          shift and go to state 90


state 84

    (41) array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS . expressionTab SEMICOLON
    (36) expressionTab -> . ID
    (37) expressionTab -> . FLOAT
    (38) expressionTab -> . INTEGER
    (39) expressionTab -> . CHAR

    ID              shift and go to state 43
    FLOAT           shift and go to state 45
    INTEGER         shift and go to state 46
    CHAR            shift and go to state 47

    expressionTab                  shift and go to state 91

state 85

    (30) array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .

    $end            reduce using rule 30 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)


state 86

    (35) declarationTab -> ID LBRACKET INTEGER . RBRACKET

    RBRACKET        shift and go to state 92


state 87

    (2) statement -> CONST type ID EQUALS expression SEMICOLON .

    $end            reduce using rule 2 (statement -> CONST type ID EQUALS expression SEMICOLON .)


state 88

    (29) const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .

    $end            reduce using rule 29 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)


state 89

    (40) factor -> ID LBRACKET expressionTab RBRACKET .

    AND             reduce using rule 40 (factor -> ID LBRACKET expressionTab RBRACKET .)
    SEMICOLON       reduce using rule 40 (factor -> ID LBRACKET expressionTab RBRACKET .)
    OR              reduce using rule 40 (factor -> ID LBRACKET expressionTab RBRACKET .)
    COMMA           reduce using rule 40 (factor -> ID LBRACKET expressionTab RBRACKET .)


state 90

    (20) factor -> LPAREN MINUS FLOAT RPAREN .

    AND             reduce using rule 20 (factor -> LPAREN MINUS FLOAT RPAREN .)
    SEMICOLON       reduce using rule 20 (factor -> LPAREN MINUS FLOAT RPAREN .)
    OR              reduce using rule 20 (factor -> LPAREN MINUS FLOAT RPAREN .)
    COMMA           reduce using rule 20 (factor -> LPAREN MINUS FLOAT RPAREN .)


state 91

    (41) array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab . SEMICOLON

    SEMICOLON       shift and go to state 93


state 92

    (35) declarationTab -> ID LBRACKET INTEGER RBRACKET .

    COMMA           reduce using rule 35 (declarationTab -> ID LBRACKET INTEGER RBRACKET .)
    SEMICOLON       reduce using rule 35 (declarationTab -> ID LBRACKET INTEGER RBRACKET .)


state 93

    (41) array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .

    $end            reduce using rule 41 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for SEMICOLON in state 72 resolved as shift
WARNING: reduce/reduce conflict in state 15 resolved using rule (declaration -> ID)
WARNING: rejected rule (declarationTab -> ID) in state 15
WARNING: reduce/reduce conflict in state 28 resolved using rule (expressionTab -> ID)
WARNING: rejected rule (factor -> ID) in state 28
WARNING: reduce/reduce conflict in state 32 resolved using rule (factor -> FLOAT)
WARNING: rejected rule (expressionTab -> FLOAT) in state 32
WARNING: reduce/reduce conflict in state 33 resolved using rule (factor -> INTEGER)
WARNING: rejected rule (expressionTab -> INTEGER) in state 33
WARNING: reduce/reduce conflict in state 34 resolved using rule (factor -> CHAR)
WARNING: rejected rule (expressionTab -> CHAR) in state 34
