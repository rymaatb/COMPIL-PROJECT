Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    NUMBER

Grammar

Rule 0     S' -> PROGRAMME
Rule 1     PROGRAMME -> varGlobal declaration_ instruction
Rule 2     varGlobal -> VAR_GLOBAL LBRACE declarations RBRACE
Rule 3     declaration_ -> DECLARATION LBRACE declarations RBRACE
Rule 4     instruction -> INSTRUCTION LBRACE statements RBRACE
Rule 5     declarations -> declaration declarations
Rule 6     declarations -> declaration
Rule 7     declarations -> empty
Rule 8     empty -> <empty>
Rule 9     declaration -> type declaration_list SEMICOLON
Rule 10    declaration -> CONST type ID EQUALS expression SEMICOLON
Rule 11    declaration_list -> declaration
Rule 12    declaration_list -> declaration COMMA declaration_list
Rule 13    declaration -> ID
Rule 14    declaration -> ID EQUALS expression
Rule 15    statement -> ID EQUALS expression SEMICOLON
Rule 16    type -> INT_TYPE
Rule 17    type -> FLOAT_TYPE
Rule 18    type -> BOOL_TYPE
Rule 19    type -> CHAR_TYPE
Rule 20    factor -> INTEGER
Rule 21    factor -> FLOAT
Rule 22    factor -> CHAR
Rule 23    factor -> BOOL
Rule 24    factor -> MINUS factor
Rule 25    factor -> PLUS factor
Rule 26    factor -> LPAREN INTEGER RPAREN
Rule 27    factor -> LPAREN FLOAT RPAREN
Rule 28    factor -> LPAREN MINUS FLOAT RPAREN
Rule 29    statements -> statement
Rule 30    statements -> statement statements
Rule 31    statements -> empty
Rule 32    statement -> simple_assignment
Rule 33    statement -> array_assignment
Rule 34    declaration -> array_declarationTab
Rule 35    declaration -> type declarationTab_listTab SEMICOLON
Rule 36    declaration -> const_declarationTab
Rule 37    simple_assignment -> ID EQUALS expressionTab SEMICOLON
Rule 38    const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON
Rule 39    array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON
Rule 40    declarationTab_listTab -> declarationTab
Rule 41    declarationTab_listTab -> declarationTab COMMA declarationTab_listTab
Rule 42    declarationTab -> ID
Rule 43    declarationTab -> ID EQUALS expressionTab
Rule 44    declarationTab -> ID LBRACKET INTEGER RBRACKET
Rule 45    expressionTab -> ID
Rule 46    expressionTab -> FLOAT
Rule 47    expressionTab -> INTEGER
Rule 48    expressionTab -> CHAR
Rule 49    factor -> ID LBRACKET expressionTab RBRACKET
Rule 50    array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON
Rule 51    expression -> expression OR term
Rule 52    expression -> term
Rule 53    term -> term AND factor
Rule 54    term -> factor
Rule 55    factor -> ID
Rule 56    factor -> TRUE
Rule 57    factor -> FALSE
Rule 58    factor -> NOT ID
Rule 59    statement -> type ID EQUALS expression_arithmetique SEMICOLON
Rule 60    statement -> ID EQUALS expression_arithmetique SEMICOLON
Rule 61    expression_arithmetique -> expression_arithmetique PLUS term_arithmetique
Rule 62    expression_arithmetique -> expression_arithmetique MINUS term_arithmetique
Rule 63    expression_arithmetique -> term_arithmetique
Rule 64    term_arithmetique -> term_arithmetique MULTIPLY term_arithmetique
Rule 65    term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique
Rule 66    term_arithmetique -> factor_arithmetique
Rule 67    factor_arithmetique -> ID
Rule 68    factor_arithmetique -> INTEGER
Rule 69    factor_arithmetique -> FLOAT
Rule 70    factor_arithmetique -> LPAREN expression_arithmetique RPAREN
Rule 71    statement -> READ LPAREN ID RPAREN SEMICOLON
Rule 72    statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON
Rule 73    statement -> WRITE LPAREN write_content RPAREN SEMICOLON
Rule 74    write_content -> write_item
Rule 75    write_content -> write_content COMMA write_item
Rule 76    write_item -> ID
Rule 77    write_item -> ID LBRACKET INTEGER RBRACKET
Rule 78    statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block
Rule 79    initialisation -> ID EQUALS INTEGER
Rule 80    step -> INTEGER
Rule 81    step -> ID
Rule 82    BorneSup -> ID
Rule 83    block -> LBRACE statements RBRACE
Rule 84    statement -> IFTHEN
Rule 85    statement -> IFTHENELSE
Rule 86    IFTHENELSE -> IFTHEN ELSE block
Rule 87    IFTHEN -> conditionIF RPAREN block
Rule 88    conditionIF -> IF LPAREN condition
Rule 89    condition -> ID EQ ID
Rule 90    condition -> ID NEQ ID
Rule 91    condition -> ID LT ID
Rule 92    condition -> ID LTE ID
Rule 93    condition -> ID GT ID
Rule 94    condition -> ID GTE ID
Rule 95    condition -> ID EQ factor
Rule 96    condition -> ID NEQ factor
Rule 97    condition -> ID LT factor
Rule 98    condition -> ID LTE factor
Rule 99    condition -> ID GT factor
Rule 100   condition -> ID GTE factor
Rule 101   condition -> expression

Terminals, with rules where they appear

AND                  : 53
BOOL                 : 23
BOOL_TYPE            : 18
CHAR                 : 22 48
CHAR_TYPE            : 19
COLON                : 78 78
COMMA                : 12 41 75
COMMENT              : 
CONST                : 10 38
DECLARATION          : 3
DIVIDE               : 65
ELSE                 : 86
EQ                   : 89 95
EQUALS               : 10 14 15 37 38 43 50 59 60 79
FALSE                : 57
FLOAT                : 21 27 28 46 69
FLOAT_TYPE           : 17
FOR                  : 78
GT                   : 93 99
GTE                  : 94 100
ID                   : 10 13 14 15 37 38 39 42 43 44 45 49 50 55 58 59 60 67 71 72 76 77 79 81 82 89 89 90 90 91 91 92 92 93 93 94 94 95 96 97 98 99 100
IF                   : 88
INSTRUCTION          : 4
INTEGER              : 20 26 39 44 47 68 72 77 79 80
INT_TYPE             : 16
LBRACE               : 2 3 4 83
LBRACKET             : 39 44 49 50 72 77
LPAREN               : 26 27 28 70 71 72 73 78 88
LT                   : 91 97
LTE                  : 92 98
MINUS                : 24 28 62
MULTIPLY             : 64
NEQ                  : 90 96
NOT                  : 58
NUMBER               : 
OR                   : 51
PLUS                 : 25 61
RBRACE               : 2 3 4 83
RBRACKET             : 39 44 49 50 72 77
READ                 : 71 72
RPAREN               : 26 27 28 70 71 72 73 78 87
SEMICOLON            : 9 10 15 35 37 38 39 50 59 60 71 72 73
TRUE                 : 56
VAR_GLOBAL           : 2
WRITE                : 73
error                : 

Nonterminals, with rules where they appear

BorneSup             : 78
IFTHEN               : 84 86
IFTHENELSE           : 85
PROGRAMME            : 0
array_assignment     : 33
array_declarationTab : 34
block                : 78 86 87
condition            : 88
conditionIF          : 87
const_declarationTab : 36
declaration          : 5 6 11 12
declarationTab       : 40 41
declarationTab_listTab : 35 41
declaration_         : 1
declaration_list     : 9 12
declarations         : 2 3 5
empty                : 7 31
expression           : 10 14 15 51 101
expressionTab        : 37 38 43 49 50 50
expression_arithmetique : 59 60 61 62 70
factor               : 24 25 53 54 95 96 97 98 99 100
factor_arithmetique  : 65 66
initialisation       : 78
instruction          : 1
simple_assignment    : 32
statement            : 29 30
statements           : 4 30 83
step                 : 78
term                 : 51 52 53
term_arithmetique    : 61 62 63 64 64 65
type                 : 9 10 35 38 39 59
varGlobal            : 1
write_content        : 73 75
write_item           : 74 75

Parsing method: LALR

state 0

    (0) S' -> . PROGRAMME
    (1) PROGRAMME -> . varGlobal declaration_ instruction
    (2) varGlobal -> . VAR_GLOBAL LBRACE declarations RBRACE

    VAR_GLOBAL      shift and go to state 3

    PROGRAMME                      shift and go to state 1
    varGlobal                      shift and go to state 2

state 1

    (0) S' -> PROGRAMME .



state 2

    (1) PROGRAMME -> varGlobal . declaration_ instruction
    (3) declaration_ -> . DECLARATION LBRACE declarations RBRACE

    DECLARATION     shift and go to state 5

    declaration_                   shift and go to state 4

state 3

    (2) varGlobal -> VAR_GLOBAL . LBRACE declarations RBRACE

    LBRACE          shift and go to state 6


state 4

    (1) PROGRAMME -> varGlobal declaration_ . instruction
    (4) instruction -> . INSTRUCTION LBRACE statements RBRACE

    INSTRUCTION     shift and go to state 8

    instruction                    shift and go to state 7

state 5

    (3) declaration_ -> DECLARATION . LBRACE declarations RBRACE

    LBRACE          shift and go to state 9


state 6

    (2) varGlobal -> VAR_GLOBAL LBRACE . declarations RBRACE
    (5) declarations -> . declaration declarations
    (6) declarations -> . declaration
    (7) declarations -> . empty
    (9) declaration -> . type declaration_list SEMICOLON
    (10) declaration -> . CONST type ID EQUALS expression SEMICOLON
    (13) declaration -> . ID
    (14) declaration -> . ID EQUALS expression
    (34) declaration -> . array_declarationTab
    (35) declaration -> . type declarationTab_listTab SEMICOLON
    (36) declaration -> . const_declarationTab
    (8) empty -> .
    (16) type -> . INT_TYPE
    (17) type -> . FLOAT_TYPE
    (18) type -> . BOOL_TYPE
    (19) type -> . CHAR_TYPE
    (39) array_declarationTab -> . type ID LBRACKET INTEGER RBRACKET SEMICOLON
    (38) const_declarationTab -> . CONST type ID EQUALS expressionTab SEMICOLON

    CONST           shift and go to state 14
    ID              shift and go to state 15
    RBRACE          reduce using rule 8 (empty -> .)
    INT_TYPE        shift and go to state 18
    FLOAT_TYPE      shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    CHAR_TYPE       shift and go to state 21

    declarations                   shift and go to state 10
    declaration                    shift and go to state 11
    empty                          shift and go to state 12
    type                           shift and go to state 13
    array_declarationTab           shift and go to state 16
    const_declarationTab           shift and go to state 17

state 7

    (1) PROGRAMME -> varGlobal declaration_ instruction .

    $end            reduce using rule 1 (PROGRAMME -> varGlobal declaration_ instruction .)


state 8

    (4) instruction -> INSTRUCTION . LBRACE statements RBRACE

    LBRACE          shift and go to state 22


state 9

    (3) declaration_ -> DECLARATION LBRACE . declarations RBRACE
    (5) declarations -> . declaration declarations
    (6) declarations -> . declaration
    (7) declarations -> . empty
    (9) declaration -> . type declaration_list SEMICOLON
    (10) declaration -> . CONST type ID EQUALS expression SEMICOLON
    (13) declaration -> . ID
    (14) declaration -> . ID EQUALS expression
    (34) declaration -> . array_declarationTab
    (35) declaration -> . type declarationTab_listTab SEMICOLON
    (36) declaration -> . const_declarationTab
    (8) empty -> .
    (16) type -> . INT_TYPE
    (17) type -> . FLOAT_TYPE
    (18) type -> . BOOL_TYPE
    (19) type -> . CHAR_TYPE
    (39) array_declarationTab -> . type ID LBRACKET INTEGER RBRACKET SEMICOLON
    (38) const_declarationTab -> . CONST type ID EQUALS expressionTab SEMICOLON

    CONST           shift and go to state 14
    ID              shift and go to state 15
    RBRACE          reduce using rule 8 (empty -> .)
    INT_TYPE        shift and go to state 18
    FLOAT_TYPE      shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    CHAR_TYPE       shift and go to state 21

    declarations                   shift and go to state 23
    declaration                    shift and go to state 11
    empty                          shift and go to state 12
    type                           shift and go to state 13
    array_declarationTab           shift and go to state 16
    const_declarationTab           shift and go to state 17

state 10

    (2) varGlobal -> VAR_GLOBAL LBRACE declarations . RBRACE

    RBRACE          shift and go to state 24


state 11

    (5) declarations -> declaration . declarations
    (6) declarations -> declaration .
    (5) declarations -> . declaration declarations
    (6) declarations -> . declaration
    (7) declarations -> . empty
    (9) declaration -> . type declaration_list SEMICOLON
    (10) declaration -> . CONST type ID EQUALS expression SEMICOLON
    (13) declaration -> . ID
    (14) declaration -> . ID EQUALS expression
    (34) declaration -> . array_declarationTab
    (35) declaration -> . type declarationTab_listTab SEMICOLON
    (36) declaration -> . const_declarationTab
    (8) empty -> .
    (16) type -> . INT_TYPE
    (17) type -> . FLOAT_TYPE
    (18) type -> . BOOL_TYPE
    (19) type -> . CHAR_TYPE
    (39) array_declarationTab -> . type ID LBRACKET INTEGER RBRACKET SEMICOLON
    (38) const_declarationTab -> . CONST type ID EQUALS expressionTab SEMICOLON

  ! reduce/reduce conflict for RBRACE resolved using rule 6 (declarations -> declaration .)
    RBRACE          reduce using rule 6 (declarations -> declaration .)
    CONST           shift and go to state 14
    ID              shift and go to state 15
    INT_TYPE        shift and go to state 18
    FLOAT_TYPE      shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    CHAR_TYPE       shift and go to state 21

  ! RBRACE          [ reduce using rule 8 (empty -> .) ]

    declaration                    shift and go to state 11
    declarations                   shift and go to state 25
    empty                          shift and go to state 12
    type                           shift and go to state 13
    array_declarationTab           shift and go to state 16
    const_declarationTab           shift and go to state 17

state 12

    (7) declarations -> empty .

    RBRACE          reduce using rule 7 (declarations -> empty .)


state 13

    (9) declaration -> type . declaration_list SEMICOLON
    (35) declaration -> type . declarationTab_listTab SEMICOLON
    (39) array_declarationTab -> type . ID LBRACKET INTEGER RBRACKET SEMICOLON
    (11) declaration_list -> . declaration
    (12) declaration_list -> . declaration COMMA declaration_list
    (40) declarationTab_listTab -> . declarationTab
    (41) declarationTab_listTab -> . declarationTab COMMA declarationTab_listTab
    (9) declaration -> . type declaration_list SEMICOLON
    (10) declaration -> . CONST type ID EQUALS expression SEMICOLON
    (13) declaration -> . ID
    (14) declaration -> . ID EQUALS expression
    (34) declaration -> . array_declarationTab
    (35) declaration -> . type declarationTab_listTab SEMICOLON
    (36) declaration -> . const_declarationTab
    (42) declarationTab -> . ID
    (43) declarationTab -> . ID EQUALS expressionTab
    (44) declarationTab -> . ID LBRACKET INTEGER RBRACKET
    (16) type -> . INT_TYPE
    (17) type -> . FLOAT_TYPE
    (18) type -> . BOOL_TYPE
    (19) type -> . CHAR_TYPE
    (39) array_declarationTab -> . type ID LBRACKET INTEGER RBRACKET SEMICOLON
    (38) const_declarationTab -> . CONST type ID EQUALS expressionTab SEMICOLON

    ID              shift and go to state 28
    CONST           shift and go to state 14
    INT_TYPE        shift and go to state 18
    FLOAT_TYPE      shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    CHAR_TYPE       shift and go to state 21

    type                           shift and go to state 13
    declaration_list               shift and go to state 26
    declarationTab_listTab         shift and go to state 27
    declaration                    shift and go to state 29
    declarationTab                 shift and go to state 30
    array_declarationTab           shift and go to state 16
    const_declarationTab           shift and go to state 17

state 14

    (10) declaration -> CONST . type ID EQUALS expression SEMICOLON
    (38) const_declarationTab -> CONST . type ID EQUALS expressionTab SEMICOLON
    (16) type -> . INT_TYPE
    (17) type -> . FLOAT_TYPE
    (18) type -> . BOOL_TYPE
    (19) type -> . CHAR_TYPE

    INT_TYPE        shift and go to state 18
    FLOAT_TYPE      shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    CHAR_TYPE       shift and go to state 21

    type                           shift and go to state 31

state 15

    (13) declaration -> ID .
    (14) declaration -> ID . EQUALS expression

    CONST           reduce using rule 13 (declaration -> ID .)
    ID              reduce using rule 13 (declaration -> ID .)
    INT_TYPE        reduce using rule 13 (declaration -> ID .)
    FLOAT_TYPE      reduce using rule 13 (declaration -> ID .)
    BOOL_TYPE       reduce using rule 13 (declaration -> ID .)
    CHAR_TYPE       reduce using rule 13 (declaration -> ID .)
    RBRACE          reduce using rule 13 (declaration -> ID .)
    COMMA           reduce using rule 13 (declaration -> ID .)
    SEMICOLON       reduce using rule 13 (declaration -> ID .)
    EQUALS          shift and go to state 32


state 16

    (34) declaration -> array_declarationTab .

    CONST           reduce using rule 34 (declaration -> array_declarationTab .)
    ID              reduce using rule 34 (declaration -> array_declarationTab .)
    INT_TYPE        reduce using rule 34 (declaration -> array_declarationTab .)
    FLOAT_TYPE      reduce using rule 34 (declaration -> array_declarationTab .)
    BOOL_TYPE       reduce using rule 34 (declaration -> array_declarationTab .)
    CHAR_TYPE       reduce using rule 34 (declaration -> array_declarationTab .)
    RBRACE          reduce using rule 34 (declaration -> array_declarationTab .)
    COMMA           reduce using rule 34 (declaration -> array_declarationTab .)
    SEMICOLON       reduce using rule 34 (declaration -> array_declarationTab .)


state 17

    (36) declaration -> const_declarationTab .

    CONST           reduce using rule 36 (declaration -> const_declarationTab .)
    ID              reduce using rule 36 (declaration -> const_declarationTab .)
    INT_TYPE        reduce using rule 36 (declaration -> const_declarationTab .)
    FLOAT_TYPE      reduce using rule 36 (declaration -> const_declarationTab .)
    BOOL_TYPE       reduce using rule 36 (declaration -> const_declarationTab .)
    CHAR_TYPE       reduce using rule 36 (declaration -> const_declarationTab .)
    RBRACE          reduce using rule 36 (declaration -> const_declarationTab .)
    COMMA           reduce using rule 36 (declaration -> const_declarationTab .)
    SEMICOLON       reduce using rule 36 (declaration -> const_declarationTab .)


state 18

    (16) type -> INT_TYPE .

    ID              reduce using rule 16 (type -> INT_TYPE .)
    CONST           reduce using rule 16 (type -> INT_TYPE .)
    INT_TYPE        reduce using rule 16 (type -> INT_TYPE .)
    FLOAT_TYPE      reduce using rule 16 (type -> INT_TYPE .)
    BOOL_TYPE       reduce using rule 16 (type -> INT_TYPE .)
    CHAR_TYPE       reduce using rule 16 (type -> INT_TYPE .)


state 19

    (17) type -> FLOAT_TYPE .

    ID              reduce using rule 17 (type -> FLOAT_TYPE .)
    CONST           reduce using rule 17 (type -> FLOAT_TYPE .)
    INT_TYPE        reduce using rule 17 (type -> FLOAT_TYPE .)
    FLOAT_TYPE      reduce using rule 17 (type -> FLOAT_TYPE .)
    BOOL_TYPE       reduce using rule 17 (type -> FLOAT_TYPE .)
    CHAR_TYPE       reduce using rule 17 (type -> FLOAT_TYPE .)


state 20

    (18) type -> BOOL_TYPE .

    ID              reduce using rule 18 (type -> BOOL_TYPE .)
    CONST           reduce using rule 18 (type -> BOOL_TYPE .)
    INT_TYPE        reduce using rule 18 (type -> BOOL_TYPE .)
    FLOAT_TYPE      reduce using rule 18 (type -> BOOL_TYPE .)
    BOOL_TYPE       reduce using rule 18 (type -> BOOL_TYPE .)
    CHAR_TYPE       reduce using rule 18 (type -> BOOL_TYPE .)


state 21

    (19) type -> CHAR_TYPE .

    ID              reduce using rule 19 (type -> CHAR_TYPE .)
    CONST           reduce using rule 19 (type -> CHAR_TYPE .)
    INT_TYPE        reduce using rule 19 (type -> CHAR_TYPE .)
    FLOAT_TYPE      reduce using rule 19 (type -> CHAR_TYPE .)
    BOOL_TYPE       reduce using rule 19 (type -> CHAR_TYPE .)
    CHAR_TYPE       reduce using rule 19 (type -> CHAR_TYPE .)


state 22

    (4) instruction -> INSTRUCTION LBRACE . statements RBRACE
    (29) statements -> . statement
    (30) statements -> . statement statements
    (31) statements -> . empty
    (15) statement -> . ID EQUALS expression SEMICOLON
    (32) statement -> . simple_assignment
    (33) statement -> . array_assignment
    (59) statement -> . type ID EQUALS expression_arithmetique SEMICOLON
    (60) statement -> . ID EQUALS expression_arithmetique SEMICOLON
    (71) statement -> . READ LPAREN ID RPAREN SEMICOLON
    (72) statement -> . READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON
    (73) statement -> . WRITE LPAREN write_content RPAREN SEMICOLON
    (78) statement -> . FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block
    (84) statement -> . IFTHEN
    (85) statement -> . IFTHENELSE
    (8) empty -> .
    (37) simple_assignment -> . ID EQUALS expressionTab SEMICOLON
    (50) array_assignment -> . ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON
    (16) type -> . INT_TYPE
    (17) type -> . FLOAT_TYPE
    (18) type -> . BOOL_TYPE
    (19) type -> . CHAR_TYPE
    (87) IFTHEN -> . conditionIF RPAREN block
    (86) IFTHENELSE -> . IFTHEN ELSE block
    (88) conditionIF -> . IF LPAREN condition

    ID              shift and go to state 36
    READ            shift and go to state 40
    WRITE           shift and go to state 41
    FOR             shift and go to state 42
    RBRACE          reduce using rule 8 (empty -> .)
    INT_TYPE        shift and go to state 18
    FLOAT_TYPE      shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    CHAR_TYPE       shift and go to state 21
    IF              shift and go to state 46

    statements                     shift and go to state 33
    statement                      shift and go to state 34
    empty                          shift and go to state 35
    simple_assignment              shift and go to state 37
    array_assignment               shift and go to state 38
    type                           shift and go to state 39
    IFTHEN                         shift and go to state 43
    IFTHENELSE                     shift and go to state 44
    conditionIF                    shift and go to state 45

state 23

    (3) declaration_ -> DECLARATION LBRACE declarations . RBRACE

    RBRACE          shift and go to state 47


state 24

    (2) varGlobal -> VAR_GLOBAL LBRACE declarations RBRACE .

    DECLARATION     reduce using rule 2 (varGlobal -> VAR_GLOBAL LBRACE declarations RBRACE .)


state 25

    (5) declarations -> declaration declarations .

    RBRACE          reduce using rule 5 (declarations -> declaration declarations .)


state 26

    (9) declaration -> type declaration_list . SEMICOLON

    SEMICOLON       shift and go to state 48


state 27

    (35) declaration -> type declarationTab_listTab . SEMICOLON

    SEMICOLON       shift and go to state 49


state 28

    (39) array_declarationTab -> type ID . LBRACKET INTEGER RBRACKET SEMICOLON
    (13) declaration -> ID .
    (14) declaration -> ID . EQUALS expression
    (42) declarationTab -> ID .
    (43) declarationTab -> ID . EQUALS expressionTab
    (44) declarationTab -> ID . LBRACKET INTEGER RBRACKET

  ! reduce/reduce conflict for COMMA resolved using rule 13 (declaration -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 13 (declaration -> ID .)
    LBRACKET        shift and go to state 50
    COMMA           reduce using rule 13 (declaration -> ID .)
    SEMICOLON       reduce using rule 13 (declaration -> ID .)
    EQUALS          shift and go to state 51

  ! COMMA           [ reduce using rule 42 (declarationTab -> ID .) ]
  ! SEMICOLON       [ reduce using rule 42 (declarationTab -> ID .) ]


state 29

    (11) declaration_list -> declaration .
    (12) declaration_list -> declaration . COMMA declaration_list

    SEMICOLON       reduce using rule 11 (declaration_list -> declaration .)
    COMMA           shift and go to state 52


state 30

    (40) declarationTab_listTab -> declarationTab .
    (41) declarationTab_listTab -> declarationTab . COMMA declarationTab_listTab

    SEMICOLON       reduce using rule 40 (declarationTab_listTab -> declarationTab .)
    COMMA           shift and go to state 53


state 31

    (10) declaration -> CONST type . ID EQUALS expression SEMICOLON
    (38) const_declarationTab -> CONST type . ID EQUALS expressionTab SEMICOLON

    ID              shift and go to state 54


state 32

    (14) declaration -> ID EQUALS . expression
    (51) expression -> . expression OR term
    (52) expression -> . term
    (53) term -> . term AND factor
    (54) term -> . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . CHAR
    (23) factor -> . BOOL
    (24) factor -> . MINUS factor
    (25) factor -> . PLUS factor
    (26) factor -> . LPAREN INTEGER RPAREN
    (27) factor -> . LPAREN FLOAT RPAREN
    (28) factor -> . LPAREN MINUS FLOAT RPAREN
    (49) factor -> . ID LBRACKET expressionTab RBRACKET
    (55) factor -> . ID
    (56) factor -> . TRUE
    (57) factor -> . FALSE
    (58) factor -> . NOT ID

    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    CHAR            shift and go to state 61
    BOOL            shift and go to state 62
    MINUS           shift and go to state 63
    PLUS            shift and go to state 64
    LPAREN          shift and go to state 65
    ID              shift and go to state 55
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    NOT             shift and go to state 68

    expression                     shift and go to state 56
    term                           shift and go to state 57
    factor                         shift and go to state 58

state 33

    (4) instruction -> INSTRUCTION LBRACE statements . RBRACE

    RBRACE          shift and go to state 69


state 34

    (29) statements -> statement .
    (30) statements -> statement . statements
    (29) statements -> . statement
    (30) statements -> . statement statements
    (31) statements -> . empty
    (15) statement -> . ID EQUALS expression SEMICOLON
    (32) statement -> . simple_assignment
    (33) statement -> . array_assignment
    (59) statement -> . type ID EQUALS expression_arithmetique SEMICOLON
    (60) statement -> . ID EQUALS expression_arithmetique SEMICOLON
    (71) statement -> . READ LPAREN ID RPAREN SEMICOLON
    (72) statement -> . READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON
    (73) statement -> . WRITE LPAREN write_content RPAREN SEMICOLON
    (78) statement -> . FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block
    (84) statement -> . IFTHEN
    (85) statement -> . IFTHENELSE
    (8) empty -> .
    (37) simple_assignment -> . ID EQUALS expressionTab SEMICOLON
    (50) array_assignment -> . ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON
    (16) type -> . INT_TYPE
    (17) type -> . FLOAT_TYPE
    (18) type -> . BOOL_TYPE
    (19) type -> . CHAR_TYPE
    (87) IFTHEN -> . conditionIF RPAREN block
    (86) IFTHENELSE -> . IFTHEN ELSE block
    (88) conditionIF -> . IF LPAREN condition

  ! reduce/reduce conflict for RBRACE resolved using rule 8 (empty -> .)
    ID              shift and go to state 36
    READ            shift and go to state 40
    WRITE           shift and go to state 41
    FOR             shift and go to state 42
    RBRACE          reduce using rule 8 (empty -> .)
    INT_TYPE        shift and go to state 18
    FLOAT_TYPE      shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    CHAR_TYPE       shift and go to state 21
    IF              shift and go to state 46

  ! RBRACE          [ reduce using rule 29 (statements -> statement .) ]

    statement                      shift and go to state 34
    statements                     shift and go to state 70
    empty                          shift and go to state 35
    simple_assignment              shift and go to state 37
    array_assignment               shift and go to state 38
    type                           shift and go to state 39
    IFTHEN                         shift and go to state 43
    IFTHENELSE                     shift and go to state 44
    conditionIF                    shift and go to state 45

state 35

    (31) statements -> empty .

    RBRACE          reduce using rule 31 (statements -> empty .)


state 36

    (15) statement -> ID . EQUALS expression SEMICOLON
    (60) statement -> ID . EQUALS expression_arithmetique SEMICOLON
    (37) simple_assignment -> ID . EQUALS expressionTab SEMICOLON
    (50) array_assignment -> ID . LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON

    EQUALS          shift and go to state 71
    LBRACKET        shift and go to state 72


state 37

    (32) statement -> simple_assignment .

    ID              reduce using rule 32 (statement -> simple_assignment .)
    READ            reduce using rule 32 (statement -> simple_assignment .)
    WRITE           reduce using rule 32 (statement -> simple_assignment .)
    FOR             reduce using rule 32 (statement -> simple_assignment .)
    INT_TYPE        reduce using rule 32 (statement -> simple_assignment .)
    FLOAT_TYPE      reduce using rule 32 (statement -> simple_assignment .)
    BOOL_TYPE       reduce using rule 32 (statement -> simple_assignment .)
    CHAR_TYPE       reduce using rule 32 (statement -> simple_assignment .)
    IF              reduce using rule 32 (statement -> simple_assignment .)
    RBRACE          reduce using rule 32 (statement -> simple_assignment .)


state 38

    (33) statement -> array_assignment .

    ID              reduce using rule 33 (statement -> array_assignment .)
    READ            reduce using rule 33 (statement -> array_assignment .)
    WRITE           reduce using rule 33 (statement -> array_assignment .)
    FOR             reduce using rule 33 (statement -> array_assignment .)
    INT_TYPE        reduce using rule 33 (statement -> array_assignment .)
    FLOAT_TYPE      reduce using rule 33 (statement -> array_assignment .)
    BOOL_TYPE       reduce using rule 33 (statement -> array_assignment .)
    CHAR_TYPE       reduce using rule 33 (statement -> array_assignment .)
    IF              reduce using rule 33 (statement -> array_assignment .)
    RBRACE          reduce using rule 33 (statement -> array_assignment .)


state 39

    (59) statement -> type . ID EQUALS expression_arithmetique SEMICOLON

    ID              shift and go to state 73


state 40

    (71) statement -> READ . LPAREN ID RPAREN SEMICOLON
    (72) statement -> READ . LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON

    LPAREN          shift and go to state 74


state 41

    (73) statement -> WRITE . LPAREN write_content RPAREN SEMICOLON

    LPAREN          shift and go to state 75


state 42

    (78) statement -> FOR . LPAREN initialisation COLON step COLON BorneSup RPAREN block

    LPAREN          shift and go to state 76


state 43

    (84) statement -> IFTHEN .
    (86) IFTHENELSE -> IFTHEN . ELSE block

    ID              reduce using rule 84 (statement -> IFTHEN .)
    READ            reduce using rule 84 (statement -> IFTHEN .)
    WRITE           reduce using rule 84 (statement -> IFTHEN .)
    FOR             reduce using rule 84 (statement -> IFTHEN .)
    INT_TYPE        reduce using rule 84 (statement -> IFTHEN .)
    FLOAT_TYPE      reduce using rule 84 (statement -> IFTHEN .)
    BOOL_TYPE       reduce using rule 84 (statement -> IFTHEN .)
    CHAR_TYPE       reduce using rule 84 (statement -> IFTHEN .)
    IF              reduce using rule 84 (statement -> IFTHEN .)
    RBRACE          reduce using rule 84 (statement -> IFTHEN .)
    ELSE            shift and go to state 77


state 44

    (85) statement -> IFTHENELSE .

    ID              reduce using rule 85 (statement -> IFTHENELSE .)
    READ            reduce using rule 85 (statement -> IFTHENELSE .)
    WRITE           reduce using rule 85 (statement -> IFTHENELSE .)
    FOR             reduce using rule 85 (statement -> IFTHENELSE .)
    INT_TYPE        reduce using rule 85 (statement -> IFTHENELSE .)
    FLOAT_TYPE      reduce using rule 85 (statement -> IFTHENELSE .)
    BOOL_TYPE       reduce using rule 85 (statement -> IFTHENELSE .)
    CHAR_TYPE       reduce using rule 85 (statement -> IFTHENELSE .)
    IF              reduce using rule 85 (statement -> IFTHENELSE .)
    RBRACE          reduce using rule 85 (statement -> IFTHENELSE .)


state 45

    (87) IFTHEN -> conditionIF . RPAREN block

    RPAREN          shift and go to state 78


state 46

    (88) conditionIF -> IF . LPAREN condition

    LPAREN          shift and go to state 79


state 47

    (3) declaration_ -> DECLARATION LBRACE declarations RBRACE .

    INSTRUCTION     reduce using rule 3 (declaration_ -> DECLARATION LBRACE declarations RBRACE .)


state 48

    (9) declaration -> type declaration_list SEMICOLON .

    CONST           reduce using rule 9 (declaration -> type declaration_list SEMICOLON .)
    ID              reduce using rule 9 (declaration -> type declaration_list SEMICOLON .)
    INT_TYPE        reduce using rule 9 (declaration -> type declaration_list SEMICOLON .)
    FLOAT_TYPE      reduce using rule 9 (declaration -> type declaration_list SEMICOLON .)
    BOOL_TYPE       reduce using rule 9 (declaration -> type declaration_list SEMICOLON .)
    CHAR_TYPE       reduce using rule 9 (declaration -> type declaration_list SEMICOLON .)
    RBRACE          reduce using rule 9 (declaration -> type declaration_list SEMICOLON .)
    COMMA           reduce using rule 9 (declaration -> type declaration_list SEMICOLON .)
    SEMICOLON       reduce using rule 9 (declaration -> type declaration_list SEMICOLON .)


state 49

    (35) declaration -> type declarationTab_listTab SEMICOLON .

    CONST           reduce using rule 35 (declaration -> type declarationTab_listTab SEMICOLON .)
    ID              reduce using rule 35 (declaration -> type declarationTab_listTab SEMICOLON .)
    INT_TYPE        reduce using rule 35 (declaration -> type declarationTab_listTab SEMICOLON .)
    FLOAT_TYPE      reduce using rule 35 (declaration -> type declarationTab_listTab SEMICOLON .)
    BOOL_TYPE       reduce using rule 35 (declaration -> type declarationTab_listTab SEMICOLON .)
    CHAR_TYPE       reduce using rule 35 (declaration -> type declarationTab_listTab SEMICOLON .)
    RBRACE          reduce using rule 35 (declaration -> type declarationTab_listTab SEMICOLON .)
    COMMA           reduce using rule 35 (declaration -> type declarationTab_listTab SEMICOLON .)
    SEMICOLON       reduce using rule 35 (declaration -> type declarationTab_listTab SEMICOLON .)


state 50

    (39) array_declarationTab -> type ID LBRACKET . INTEGER RBRACKET SEMICOLON
    (44) declarationTab -> ID LBRACKET . INTEGER RBRACKET

    INTEGER         shift and go to state 80


state 51

    (14) declaration -> ID EQUALS . expression
    (43) declarationTab -> ID EQUALS . expressionTab
    (51) expression -> . expression OR term
    (52) expression -> . term
    (45) expressionTab -> . ID
    (46) expressionTab -> . FLOAT
    (47) expressionTab -> . INTEGER
    (48) expressionTab -> . CHAR
    (53) term -> . term AND factor
    (54) term -> . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . CHAR
    (23) factor -> . BOOL
    (24) factor -> . MINUS factor
    (25) factor -> . PLUS factor
    (26) factor -> . LPAREN INTEGER RPAREN
    (27) factor -> . LPAREN FLOAT RPAREN
    (28) factor -> . LPAREN MINUS FLOAT RPAREN
    (49) factor -> . ID LBRACKET expressionTab RBRACKET
    (55) factor -> . ID
    (56) factor -> . TRUE
    (57) factor -> . FALSE
    (58) factor -> . NOT ID

    ID              shift and go to state 81
    FLOAT           shift and go to state 83
    INTEGER         shift and go to state 84
    CHAR            shift and go to state 85
    BOOL            shift and go to state 62
    MINUS           shift and go to state 63
    PLUS            shift and go to state 64
    LPAREN          shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    NOT             shift and go to state 68

    expression                     shift and go to state 56
    expressionTab                  shift and go to state 82
    term                           shift and go to state 57
    factor                         shift and go to state 58

state 52

    (12) declaration_list -> declaration COMMA . declaration_list
    (11) declaration_list -> . declaration
    (12) declaration_list -> . declaration COMMA declaration_list
    (9) declaration -> . type declaration_list SEMICOLON
    (10) declaration -> . CONST type ID EQUALS expression SEMICOLON
    (13) declaration -> . ID
    (14) declaration -> . ID EQUALS expression
    (34) declaration -> . array_declarationTab
    (35) declaration -> . type declarationTab_listTab SEMICOLON
    (36) declaration -> . const_declarationTab
    (16) type -> . INT_TYPE
    (17) type -> . FLOAT_TYPE
    (18) type -> . BOOL_TYPE
    (19) type -> . CHAR_TYPE
    (39) array_declarationTab -> . type ID LBRACKET INTEGER RBRACKET SEMICOLON
    (38) const_declarationTab -> . CONST type ID EQUALS expressionTab SEMICOLON

    CONST           shift and go to state 14
    ID              shift and go to state 15
    INT_TYPE        shift and go to state 18
    FLOAT_TYPE      shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    CHAR_TYPE       shift and go to state 21

    declaration                    shift and go to state 29
    declaration_list               shift and go to state 86
    type                           shift and go to state 13
    array_declarationTab           shift and go to state 16
    const_declarationTab           shift and go to state 17

state 53

    (41) declarationTab_listTab -> declarationTab COMMA . declarationTab_listTab
    (40) declarationTab_listTab -> . declarationTab
    (41) declarationTab_listTab -> . declarationTab COMMA declarationTab_listTab
    (42) declarationTab -> . ID
    (43) declarationTab -> . ID EQUALS expressionTab
    (44) declarationTab -> . ID LBRACKET INTEGER RBRACKET

    ID              shift and go to state 88

    declarationTab                 shift and go to state 30
    declarationTab_listTab         shift and go to state 87

state 54

    (10) declaration -> CONST type ID . EQUALS expression SEMICOLON
    (38) const_declarationTab -> CONST type ID . EQUALS expressionTab SEMICOLON

    EQUALS          shift and go to state 89


state 55

    (49) factor -> ID . LBRACKET expressionTab RBRACKET
    (55) factor -> ID .

    LBRACKET        shift and go to state 90
    AND             reduce using rule 55 (factor -> ID .)
    OR              reduce using rule 55 (factor -> ID .)
    CONST           reduce using rule 55 (factor -> ID .)
    ID              reduce using rule 55 (factor -> ID .)
    INT_TYPE        reduce using rule 55 (factor -> ID .)
    FLOAT_TYPE      reduce using rule 55 (factor -> ID .)
    BOOL_TYPE       reduce using rule 55 (factor -> ID .)
    CHAR_TYPE       reduce using rule 55 (factor -> ID .)
    RBRACE          reduce using rule 55 (factor -> ID .)
    COMMA           reduce using rule 55 (factor -> ID .)
    SEMICOLON       reduce using rule 55 (factor -> ID .)
    RPAREN          reduce using rule 55 (factor -> ID .)


state 56

    (14) declaration -> ID EQUALS expression .
    (51) expression -> expression . OR term

    CONST           reduce using rule 14 (declaration -> ID EQUALS expression .)
    ID              reduce using rule 14 (declaration -> ID EQUALS expression .)
    INT_TYPE        reduce using rule 14 (declaration -> ID EQUALS expression .)
    FLOAT_TYPE      reduce using rule 14 (declaration -> ID EQUALS expression .)
    BOOL_TYPE       reduce using rule 14 (declaration -> ID EQUALS expression .)
    CHAR_TYPE       reduce using rule 14 (declaration -> ID EQUALS expression .)
    RBRACE          reduce using rule 14 (declaration -> ID EQUALS expression .)
    COMMA           reduce using rule 14 (declaration -> ID EQUALS expression .)
    SEMICOLON       reduce using rule 14 (declaration -> ID EQUALS expression .)
    OR              shift and go to state 91


state 57

    (52) expression -> term .
    (53) term -> term . AND factor

    OR              reduce using rule 52 (expression -> term .)
    CONST           reduce using rule 52 (expression -> term .)
    ID              reduce using rule 52 (expression -> term .)
    INT_TYPE        reduce using rule 52 (expression -> term .)
    FLOAT_TYPE      reduce using rule 52 (expression -> term .)
    BOOL_TYPE       reduce using rule 52 (expression -> term .)
    CHAR_TYPE       reduce using rule 52 (expression -> term .)
    RBRACE          reduce using rule 52 (expression -> term .)
    COMMA           reduce using rule 52 (expression -> term .)
    SEMICOLON       reduce using rule 52 (expression -> term .)
    RPAREN          reduce using rule 52 (expression -> term .)
    AND             shift and go to state 92


state 58

    (54) term -> factor .

    AND             reduce using rule 54 (term -> factor .)
    OR              reduce using rule 54 (term -> factor .)
    CONST           reduce using rule 54 (term -> factor .)
    ID              reduce using rule 54 (term -> factor .)
    INT_TYPE        reduce using rule 54 (term -> factor .)
    FLOAT_TYPE      reduce using rule 54 (term -> factor .)
    BOOL_TYPE       reduce using rule 54 (term -> factor .)
    CHAR_TYPE       reduce using rule 54 (term -> factor .)
    RBRACE          reduce using rule 54 (term -> factor .)
    COMMA           reduce using rule 54 (term -> factor .)
    SEMICOLON       reduce using rule 54 (term -> factor .)
    RPAREN          reduce using rule 54 (term -> factor .)


state 59

    (20) factor -> INTEGER .

    AND             reduce using rule 20 (factor -> INTEGER .)
    OR              reduce using rule 20 (factor -> INTEGER .)
    CONST           reduce using rule 20 (factor -> INTEGER .)
    ID              reduce using rule 20 (factor -> INTEGER .)
    INT_TYPE        reduce using rule 20 (factor -> INTEGER .)
    FLOAT_TYPE      reduce using rule 20 (factor -> INTEGER .)
    BOOL_TYPE       reduce using rule 20 (factor -> INTEGER .)
    CHAR_TYPE       reduce using rule 20 (factor -> INTEGER .)
    RBRACE          reduce using rule 20 (factor -> INTEGER .)
    COMMA           reduce using rule 20 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 20 (factor -> INTEGER .)
    RPAREN          reduce using rule 20 (factor -> INTEGER .)


state 60

    (21) factor -> FLOAT .

    AND             reduce using rule 21 (factor -> FLOAT .)
    OR              reduce using rule 21 (factor -> FLOAT .)
    CONST           reduce using rule 21 (factor -> FLOAT .)
    ID              reduce using rule 21 (factor -> FLOAT .)
    INT_TYPE        reduce using rule 21 (factor -> FLOAT .)
    FLOAT_TYPE      reduce using rule 21 (factor -> FLOAT .)
    BOOL_TYPE       reduce using rule 21 (factor -> FLOAT .)
    CHAR_TYPE       reduce using rule 21 (factor -> FLOAT .)
    RBRACE          reduce using rule 21 (factor -> FLOAT .)
    COMMA           reduce using rule 21 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 21 (factor -> FLOAT .)
    RPAREN          reduce using rule 21 (factor -> FLOAT .)


state 61

    (22) factor -> CHAR .

    AND             reduce using rule 22 (factor -> CHAR .)
    OR              reduce using rule 22 (factor -> CHAR .)
    CONST           reduce using rule 22 (factor -> CHAR .)
    ID              reduce using rule 22 (factor -> CHAR .)
    INT_TYPE        reduce using rule 22 (factor -> CHAR .)
    FLOAT_TYPE      reduce using rule 22 (factor -> CHAR .)
    BOOL_TYPE       reduce using rule 22 (factor -> CHAR .)
    CHAR_TYPE       reduce using rule 22 (factor -> CHAR .)
    RBRACE          reduce using rule 22 (factor -> CHAR .)
    COMMA           reduce using rule 22 (factor -> CHAR .)
    SEMICOLON       reduce using rule 22 (factor -> CHAR .)
    RPAREN          reduce using rule 22 (factor -> CHAR .)


state 62

    (23) factor -> BOOL .

    AND             reduce using rule 23 (factor -> BOOL .)
    OR              reduce using rule 23 (factor -> BOOL .)
    CONST           reduce using rule 23 (factor -> BOOL .)
    ID              reduce using rule 23 (factor -> BOOL .)
    INT_TYPE        reduce using rule 23 (factor -> BOOL .)
    FLOAT_TYPE      reduce using rule 23 (factor -> BOOL .)
    BOOL_TYPE       reduce using rule 23 (factor -> BOOL .)
    CHAR_TYPE       reduce using rule 23 (factor -> BOOL .)
    RBRACE          reduce using rule 23 (factor -> BOOL .)
    COMMA           reduce using rule 23 (factor -> BOOL .)
    SEMICOLON       reduce using rule 23 (factor -> BOOL .)
    RPAREN          reduce using rule 23 (factor -> BOOL .)


state 63

    (24) factor -> MINUS . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . CHAR
    (23) factor -> . BOOL
    (24) factor -> . MINUS factor
    (25) factor -> . PLUS factor
    (26) factor -> . LPAREN INTEGER RPAREN
    (27) factor -> . LPAREN FLOAT RPAREN
    (28) factor -> . LPAREN MINUS FLOAT RPAREN
    (49) factor -> . ID LBRACKET expressionTab RBRACKET
    (55) factor -> . ID
    (56) factor -> . TRUE
    (57) factor -> . FALSE
    (58) factor -> . NOT ID

    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    CHAR            shift and go to state 61
    BOOL            shift and go to state 62
    MINUS           shift and go to state 63
    PLUS            shift and go to state 64
    LPAREN          shift and go to state 65
    ID              shift and go to state 55
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    NOT             shift and go to state 68

    factor                         shift and go to state 93

state 64

    (25) factor -> PLUS . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . CHAR
    (23) factor -> . BOOL
    (24) factor -> . MINUS factor
    (25) factor -> . PLUS factor
    (26) factor -> . LPAREN INTEGER RPAREN
    (27) factor -> . LPAREN FLOAT RPAREN
    (28) factor -> . LPAREN MINUS FLOAT RPAREN
    (49) factor -> . ID LBRACKET expressionTab RBRACKET
    (55) factor -> . ID
    (56) factor -> . TRUE
    (57) factor -> . FALSE
    (58) factor -> . NOT ID

    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    CHAR            shift and go to state 61
    BOOL            shift and go to state 62
    MINUS           shift and go to state 63
    PLUS            shift and go to state 64
    LPAREN          shift and go to state 65
    ID              shift and go to state 55
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    NOT             shift and go to state 68

    factor                         shift and go to state 94

state 65

    (26) factor -> LPAREN . INTEGER RPAREN
    (27) factor -> LPAREN . FLOAT RPAREN
    (28) factor -> LPAREN . MINUS FLOAT RPAREN

    INTEGER         shift and go to state 95
    FLOAT           shift and go to state 96
    MINUS           shift and go to state 97


state 66

    (56) factor -> TRUE .

    AND             reduce using rule 56 (factor -> TRUE .)
    OR              reduce using rule 56 (factor -> TRUE .)
    CONST           reduce using rule 56 (factor -> TRUE .)
    ID              reduce using rule 56 (factor -> TRUE .)
    INT_TYPE        reduce using rule 56 (factor -> TRUE .)
    FLOAT_TYPE      reduce using rule 56 (factor -> TRUE .)
    BOOL_TYPE       reduce using rule 56 (factor -> TRUE .)
    CHAR_TYPE       reduce using rule 56 (factor -> TRUE .)
    RBRACE          reduce using rule 56 (factor -> TRUE .)
    COMMA           reduce using rule 56 (factor -> TRUE .)
    SEMICOLON       reduce using rule 56 (factor -> TRUE .)
    RPAREN          reduce using rule 56 (factor -> TRUE .)


state 67

    (57) factor -> FALSE .

    AND             reduce using rule 57 (factor -> FALSE .)
    OR              reduce using rule 57 (factor -> FALSE .)
    CONST           reduce using rule 57 (factor -> FALSE .)
    ID              reduce using rule 57 (factor -> FALSE .)
    INT_TYPE        reduce using rule 57 (factor -> FALSE .)
    FLOAT_TYPE      reduce using rule 57 (factor -> FALSE .)
    BOOL_TYPE       reduce using rule 57 (factor -> FALSE .)
    CHAR_TYPE       reduce using rule 57 (factor -> FALSE .)
    RBRACE          reduce using rule 57 (factor -> FALSE .)
    COMMA           reduce using rule 57 (factor -> FALSE .)
    SEMICOLON       reduce using rule 57 (factor -> FALSE .)
    RPAREN          reduce using rule 57 (factor -> FALSE .)


state 68

    (58) factor -> NOT . ID

    ID              shift and go to state 98


state 69

    (4) instruction -> INSTRUCTION LBRACE statements RBRACE .

    $end            reduce using rule 4 (instruction -> INSTRUCTION LBRACE statements RBRACE .)


state 70

    (30) statements -> statement statements .

    RBRACE          reduce using rule 30 (statements -> statement statements .)


state 71

    (15) statement -> ID EQUALS . expression SEMICOLON
    (60) statement -> ID EQUALS . expression_arithmetique SEMICOLON
    (37) simple_assignment -> ID EQUALS . expressionTab SEMICOLON
    (51) expression -> . expression OR term
    (52) expression -> . term
    (61) expression_arithmetique -> . expression_arithmetique PLUS term_arithmetique
    (62) expression_arithmetique -> . expression_arithmetique MINUS term_arithmetique
    (63) expression_arithmetique -> . term_arithmetique
    (45) expressionTab -> . ID
    (46) expressionTab -> . FLOAT
    (47) expressionTab -> . INTEGER
    (48) expressionTab -> . CHAR
    (53) term -> . term AND factor
    (54) term -> . factor
    (64) term_arithmetique -> . term_arithmetique MULTIPLY term_arithmetique
    (65) term_arithmetique -> . term_arithmetique DIVIDE factor_arithmetique
    (66) term_arithmetique -> . factor_arithmetique
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . CHAR
    (23) factor -> . BOOL
    (24) factor -> . MINUS factor
    (25) factor -> . PLUS factor
    (26) factor -> . LPAREN INTEGER RPAREN
    (27) factor -> . LPAREN FLOAT RPAREN
    (28) factor -> . LPAREN MINUS FLOAT RPAREN
    (49) factor -> . ID LBRACKET expressionTab RBRACKET
    (55) factor -> . ID
    (56) factor -> . TRUE
    (57) factor -> . FALSE
    (58) factor -> . NOT ID
    (67) factor_arithmetique -> . ID
    (68) factor_arithmetique -> . INTEGER
    (69) factor_arithmetique -> . FLOAT
    (70) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN

    ID              shift and go to state 99
    FLOAT           shift and go to state 104
    INTEGER         shift and go to state 105
    CHAR            shift and go to state 85
    BOOL            shift and go to state 62
    MINUS           shift and go to state 63
    PLUS            shift and go to state 64
    LPAREN          shift and go to state 107
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    NOT             shift and go to state 68

    expression                     shift and go to state 100
    expression_arithmetique        shift and go to state 101
    expressionTab                  shift and go to state 102
    term                           shift and go to state 57
    term_arithmetique              shift and go to state 103
    factor                         shift and go to state 58
    factor_arithmetique            shift and go to state 106

state 72

    (50) array_assignment -> ID LBRACKET . expressionTab RBRACKET EQUALS expressionTab SEMICOLON
    (45) expressionTab -> . ID
    (46) expressionTab -> . FLOAT
    (47) expressionTab -> . INTEGER
    (48) expressionTab -> . CHAR

    ID              shift and go to state 108
    FLOAT           shift and go to state 110
    INTEGER         shift and go to state 111
    CHAR            shift and go to state 112

    expressionTab                  shift and go to state 109

state 73

    (59) statement -> type ID . EQUALS expression_arithmetique SEMICOLON

    EQUALS          shift and go to state 113


state 74

    (71) statement -> READ LPAREN . ID RPAREN SEMICOLON
    (72) statement -> READ LPAREN . ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON

    ID              shift and go to state 114


state 75

    (73) statement -> WRITE LPAREN . write_content RPAREN SEMICOLON
    (74) write_content -> . write_item
    (75) write_content -> . write_content COMMA write_item
    (76) write_item -> . ID
    (77) write_item -> . ID LBRACKET INTEGER RBRACKET

    ID              shift and go to state 117

    write_content                  shift and go to state 115
    write_item                     shift and go to state 116

state 76

    (78) statement -> FOR LPAREN . initialisation COLON step COLON BorneSup RPAREN block
    (79) initialisation -> . ID EQUALS INTEGER

    ID              shift and go to state 119

    initialisation                 shift and go to state 118

state 77

    (86) IFTHENELSE -> IFTHEN ELSE . block
    (83) block -> . LBRACE statements RBRACE

    LBRACE          shift and go to state 121

    block                          shift and go to state 120

state 78

    (87) IFTHEN -> conditionIF RPAREN . block
    (83) block -> . LBRACE statements RBRACE

    LBRACE          shift and go to state 121

    block                          shift and go to state 122

state 79

    (88) conditionIF -> IF LPAREN . condition
    (89) condition -> . ID EQ ID
    (90) condition -> . ID NEQ ID
    (91) condition -> . ID LT ID
    (92) condition -> . ID LTE ID
    (93) condition -> . ID GT ID
    (94) condition -> . ID GTE ID
    (95) condition -> . ID EQ factor
    (96) condition -> . ID NEQ factor
    (97) condition -> . ID LT factor
    (98) condition -> . ID LTE factor
    (99) condition -> . ID GT factor
    (100) condition -> . ID GTE factor
    (101) condition -> . expression
    (51) expression -> . expression OR term
    (52) expression -> . term
    (53) term -> . term AND factor
    (54) term -> . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . CHAR
    (23) factor -> . BOOL
    (24) factor -> . MINUS factor
    (25) factor -> . PLUS factor
    (26) factor -> . LPAREN INTEGER RPAREN
    (27) factor -> . LPAREN FLOAT RPAREN
    (28) factor -> . LPAREN MINUS FLOAT RPAREN
    (49) factor -> . ID LBRACKET expressionTab RBRACKET
    (55) factor -> . ID
    (56) factor -> . TRUE
    (57) factor -> . FALSE
    (58) factor -> . NOT ID

    ID              shift and go to state 124
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    CHAR            shift and go to state 61
    BOOL            shift and go to state 62
    MINUS           shift and go to state 63
    PLUS            shift and go to state 64
    LPAREN          shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    NOT             shift and go to state 68

    condition                      shift and go to state 123
    factor                         shift and go to state 58
    expression                     shift and go to state 125
    term                           shift and go to state 57

state 80

    (39) array_declarationTab -> type ID LBRACKET INTEGER . RBRACKET SEMICOLON
    (44) declarationTab -> ID LBRACKET INTEGER . RBRACKET

    RBRACKET        shift and go to state 126


state 81

    (45) expressionTab -> ID .
    (49) factor -> ID . LBRACKET expressionTab RBRACKET
    (55) factor -> ID .

  ! reduce/reduce conflict for COMMA resolved using rule 45 (expressionTab -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 45 (expressionTab -> ID .)
    COMMA           reduce using rule 45 (expressionTab -> ID .)
    SEMICOLON       reduce using rule 45 (expressionTab -> ID .)
    LBRACKET        shift and go to state 90
    AND             reduce using rule 55 (factor -> ID .)
    OR              reduce using rule 55 (factor -> ID .)

  ! COMMA           [ reduce using rule 55 (factor -> ID .) ]
  ! SEMICOLON       [ reduce using rule 55 (factor -> ID .) ]


state 82

    (43) declarationTab -> ID EQUALS expressionTab .

    COMMA           reduce using rule 43 (declarationTab -> ID EQUALS expressionTab .)
    SEMICOLON       reduce using rule 43 (declarationTab -> ID EQUALS expressionTab .)


state 83

    (46) expressionTab -> FLOAT .
    (21) factor -> FLOAT .

  ! reduce/reduce conflict for COMMA resolved using rule 21 (factor -> FLOAT .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 21 (factor -> FLOAT .)
    AND             reduce using rule 21 (factor -> FLOAT .)
    OR              reduce using rule 21 (factor -> FLOAT .)
    COMMA           reduce using rule 21 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 21 (factor -> FLOAT .)

  ! COMMA           [ reduce using rule 46 (expressionTab -> FLOAT .) ]
  ! SEMICOLON       [ reduce using rule 46 (expressionTab -> FLOAT .) ]


state 84

    (47) expressionTab -> INTEGER .
    (20) factor -> INTEGER .

  ! reduce/reduce conflict for COMMA resolved using rule 20 (factor -> INTEGER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 20 (factor -> INTEGER .)
    AND             reduce using rule 20 (factor -> INTEGER .)
    OR              reduce using rule 20 (factor -> INTEGER .)
    COMMA           reduce using rule 20 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 20 (factor -> INTEGER .)

  ! COMMA           [ reduce using rule 47 (expressionTab -> INTEGER .) ]
  ! SEMICOLON       [ reduce using rule 47 (expressionTab -> INTEGER .) ]


state 85

    (48) expressionTab -> CHAR .
    (22) factor -> CHAR .

  ! reduce/reduce conflict for COMMA resolved using rule 22 (factor -> CHAR .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 22 (factor -> CHAR .)
    AND             reduce using rule 22 (factor -> CHAR .)
    OR              reduce using rule 22 (factor -> CHAR .)
    COMMA           reduce using rule 22 (factor -> CHAR .)
    SEMICOLON       reduce using rule 22 (factor -> CHAR .)

  ! COMMA           [ reduce using rule 48 (expressionTab -> CHAR .) ]
  ! SEMICOLON       [ reduce using rule 48 (expressionTab -> CHAR .) ]


state 86

    (12) declaration_list -> declaration COMMA declaration_list .

    SEMICOLON       reduce using rule 12 (declaration_list -> declaration COMMA declaration_list .)


state 87

    (41) declarationTab_listTab -> declarationTab COMMA declarationTab_listTab .

    SEMICOLON       reduce using rule 41 (declarationTab_listTab -> declarationTab COMMA declarationTab_listTab .)


state 88

    (42) declarationTab -> ID .
    (43) declarationTab -> ID . EQUALS expressionTab
    (44) declarationTab -> ID . LBRACKET INTEGER RBRACKET

    COMMA           reduce using rule 42 (declarationTab -> ID .)
    SEMICOLON       reduce using rule 42 (declarationTab -> ID .)
    EQUALS          shift and go to state 127
    LBRACKET        shift and go to state 128


state 89

    (10) declaration -> CONST type ID EQUALS . expression SEMICOLON
    (38) const_declarationTab -> CONST type ID EQUALS . expressionTab SEMICOLON
    (51) expression -> . expression OR term
    (52) expression -> . term
    (45) expressionTab -> . ID
    (46) expressionTab -> . FLOAT
    (47) expressionTab -> . INTEGER
    (48) expressionTab -> . CHAR
    (53) term -> . term AND factor
    (54) term -> . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . CHAR
    (23) factor -> . BOOL
    (24) factor -> . MINUS factor
    (25) factor -> . PLUS factor
    (26) factor -> . LPAREN INTEGER RPAREN
    (27) factor -> . LPAREN FLOAT RPAREN
    (28) factor -> . LPAREN MINUS FLOAT RPAREN
    (49) factor -> . ID LBRACKET expressionTab RBRACKET
    (55) factor -> . ID
    (56) factor -> . TRUE
    (57) factor -> . FALSE
    (58) factor -> . NOT ID

    ID              shift and go to state 81
    FLOAT           shift and go to state 83
    INTEGER         shift and go to state 84
    CHAR            shift and go to state 85
    BOOL            shift and go to state 62
    MINUS           shift and go to state 63
    PLUS            shift and go to state 64
    LPAREN          shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    NOT             shift and go to state 68

    expression                     shift and go to state 129
    expressionTab                  shift and go to state 130
    term                           shift and go to state 57
    factor                         shift and go to state 58

state 90

    (49) factor -> ID LBRACKET . expressionTab RBRACKET
    (45) expressionTab -> . ID
    (46) expressionTab -> . FLOAT
    (47) expressionTab -> . INTEGER
    (48) expressionTab -> . CHAR

    ID              shift and go to state 108
    FLOAT           shift and go to state 110
    INTEGER         shift and go to state 111
    CHAR            shift and go to state 112

    expressionTab                  shift and go to state 131

state 91

    (51) expression -> expression OR . term
    (53) term -> . term AND factor
    (54) term -> . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . CHAR
    (23) factor -> . BOOL
    (24) factor -> . MINUS factor
    (25) factor -> . PLUS factor
    (26) factor -> . LPAREN INTEGER RPAREN
    (27) factor -> . LPAREN FLOAT RPAREN
    (28) factor -> . LPAREN MINUS FLOAT RPAREN
    (49) factor -> . ID LBRACKET expressionTab RBRACKET
    (55) factor -> . ID
    (56) factor -> . TRUE
    (57) factor -> . FALSE
    (58) factor -> . NOT ID

    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    CHAR            shift and go to state 61
    BOOL            shift and go to state 62
    MINUS           shift and go to state 63
    PLUS            shift and go to state 64
    LPAREN          shift and go to state 65
    ID              shift and go to state 55
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    NOT             shift and go to state 68

    term                           shift and go to state 132
    factor                         shift and go to state 58

state 92

    (53) term -> term AND . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . CHAR
    (23) factor -> . BOOL
    (24) factor -> . MINUS factor
    (25) factor -> . PLUS factor
    (26) factor -> . LPAREN INTEGER RPAREN
    (27) factor -> . LPAREN FLOAT RPAREN
    (28) factor -> . LPAREN MINUS FLOAT RPAREN
    (49) factor -> . ID LBRACKET expressionTab RBRACKET
    (55) factor -> . ID
    (56) factor -> . TRUE
    (57) factor -> . FALSE
    (58) factor -> . NOT ID

    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    CHAR            shift and go to state 61
    BOOL            shift and go to state 62
    MINUS           shift and go to state 63
    PLUS            shift and go to state 64
    LPAREN          shift and go to state 65
    ID              shift and go to state 55
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    NOT             shift and go to state 68

    factor                         shift and go to state 133

state 93

    (24) factor -> MINUS factor .

    AND             reduce using rule 24 (factor -> MINUS factor .)
    OR              reduce using rule 24 (factor -> MINUS factor .)
    CONST           reduce using rule 24 (factor -> MINUS factor .)
    ID              reduce using rule 24 (factor -> MINUS factor .)
    INT_TYPE        reduce using rule 24 (factor -> MINUS factor .)
    FLOAT_TYPE      reduce using rule 24 (factor -> MINUS factor .)
    BOOL_TYPE       reduce using rule 24 (factor -> MINUS factor .)
    CHAR_TYPE       reduce using rule 24 (factor -> MINUS factor .)
    RBRACE          reduce using rule 24 (factor -> MINUS factor .)
    COMMA           reduce using rule 24 (factor -> MINUS factor .)
    SEMICOLON       reduce using rule 24 (factor -> MINUS factor .)
    RPAREN          reduce using rule 24 (factor -> MINUS factor .)


state 94

    (25) factor -> PLUS factor .

    AND             reduce using rule 25 (factor -> PLUS factor .)
    OR              reduce using rule 25 (factor -> PLUS factor .)
    CONST           reduce using rule 25 (factor -> PLUS factor .)
    ID              reduce using rule 25 (factor -> PLUS factor .)
    INT_TYPE        reduce using rule 25 (factor -> PLUS factor .)
    FLOAT_TYPE      reduce using rule 25 (factor -> PLUS factor .)
    BOOL_TYPE       reduce using rule 25 (factor -> PLUS factor .)
    CHAR_TYPE       reduce using rule 25 (factor -> PLUS factor .)
    RBRACE          reduce using rule 25 (factor -> PLUS factor .)
    COMMA           reduce using rule 25 (factor -> PLUS factor .)
    SEMICOLON       reduce using rule 25 (factor -> PLUS factor .)
    RPAREN          reduce using rule 25 (factor -> PLUS factor .)


state 95

    (26) factor -> LPAREN INTEGER . RPAREN

    RPAREN          shift and go to state 134


state 96

    (27) factor -> LPAREN FLOAT . RPAREN

    RPAREN          shift and go to state 135


state 97

    (28) factor -> LPAREN MINUS . FLOAT RPAREN

    FLOAT           shift and go to state 136


state 98

    (58) factor -> NOT ID .

    AND             reduce using rule 58 (factor -> NOT ID .)
    OR              reduce using rule 58 (factor -> NOT ID .)
    CONST           reduce using rule 58 (factor -> NOT ID .)
    ID              reduce using rule 58 (factor -> NOT ID .)
    INT_TYPE        reduce using rule 58 (factor -> NOT ID .)
    FLOAT_TYPE      reduce using rule 58 (factor -> NOT ID .)
    BOOL_TYPE       reduce using rule 58 (factor -> NOT ID .)
    CHAR_TYPE       reduce using rule 58 (factor -> NOT ID .)
    RBRACE          reduce using rule 58 (factor -> NOT ID .)
    COMMA           reduce using rule 58 (factor -> NOT ID .)
    SEMICOLON       reduce using rule 58 (factor -> NOT ID .)
    RPAREN          reduce using rule 58 (factor -> NOT ID .)


state 99

    (45) expressionTab -> ID .
    (49) factor -> ID . LBRACKET expressionTab RBRACKET
    (55) factor -> ID .
    (67) factor_arithmetique -> ID .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 45 (expressionTab -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 45 (expressionTab -> ID .)
    SEMICOLON       reduce using rule 45 (expressionTab -> ID .)
    LBRACKET        shift and go to state 90
    AND             reduce using rule 55 (factor -> ID .)
    OR              reduce using rule 55 (factor -> ID .)
    MULTIPLY        reduce using rule 67 (factor_arithmetique -> ID .)
    DIVIDE          reduce using rule 67 (factor_arithmetique -> ID .)
    PLUS            reduce using rule 67 (factor_arithmetique -> ID .)
    MINUS           reduce using rule 67 (factor_arithmetique -> ID .)

  ! SEMICOLON       [ reduce using rule 55 (factor -> ID .) ]
  ! SEMICOLON       [ reduce using rule 67 (factor_arithmetique -> ID .) ]


state 100

    (15) statement -> ID EQUALS expression . SEMICOLON
    (51) expression -> expression . OR term

    SEMICOLON       shift and go to state 137
    OR              shift and go to state 91


state 101

    (60) statement -> ID EQUALS expression_arithmetique . SEMICOLON
    (61) expression_arithmetique -> expression_arithmetique . PLUS term_arithmetique
    (62) expression_arithmetique -> expression_arithmetique . MINUS term_arithmetique

    SEMICOLON       shift and go to state 138
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140


state 102

    (37) simple_assignment -> ID EQUALS expressionTab . SEMICOLON

    SEMICOLON       shift and go to state 141


state 103

    (63) expression_arithmetique -> term_arithmetique .
    (64) term_arithmetique -> term_arithmetique . MULTIPLY term_arithmetique
    (65) term_arithmetique -> term_arithmetique . DIVIDE factor_arithmetique

    SEMICOLON       reduce using rule 63 (expression_arithmetique -> term_arithmetique .)
    PLUS            reduce using rule 63 (expression_arithmetique -> term_arithmetique .)
    MINUS           reduce using rule 63 (expression_arithmetique -> term_arithmetique .)
    RPAREN          reduce using rule 63 (expression_arithmetique -> term_arithmetique .)
    MULTIPLY        shift and go to state 142
    DIVIDE          shift and go to state 143


state 104

    (46) expressionTab -> FLOAT .
    (21) factor -> FLOAT .
    (69) factor_arithmetique -> FLOAT .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 21 (factor -> FLOAT .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 21 (factor -> FLOAT .)
    AND             reduce using rule 21 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 21 (factor -> FLOAT .)
    OR              reduce using rule 21 (factor -> FLOAT .)
    MULTIPLY        reduce using rule 69 (factor_arithmetique -> FLOAT .)
    DIVIDE          reduce using rule 69 (factor_arithmetique -> FLOAT .)
    PLUS            reduce using rule 69 (factor_arithmetique -> FLOAT .)
    MINUS           reduce using rule 69 (factor_arithmetique -> FLOAT .)

  ! SEMICOLON       [ reduce using rule 46 (expressionTab -> FLOAT .) ]
  ! SEMICOLON       [ reduce using rule 69 (factor_arithmetique -> FLOAT .) ]


state 105

    (47) expressionTab -> INTEGER .
    (20) factor -> INTEGER .
    (68) factor_arithmetique -> INTEGER .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 20 (factor -> INTEGER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 20 (factor -> INTEGER .)
    AND             reduce using rule 20 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 20 (factor -> INTEGER .)
    OR              reduce using rule 20 (factor -> INTEGER .)
    MULTIPLY        reduce using rule 68 (factor_arithmetique -> INTEGER .)
    DIVIDE          reduce using rule 68 (factor_arithmetique -> INTEGER .)
    PLUS            reduce using rule 68 (factor_arithmetique -> INTEGER .)
    MINUS           reduce using rule 68 (factor_arithmetique -> INTEGER .)

  ! SEMICOLON       [ reduce using rule 47 (expressionTab -> INTEGER .) ]
  ! SEMICOLON       [ reduce using rule 68 (factor_arithmetique -> INTEGER .) ]


state 106

    (66) term_arithmetique -> factor_arithmetique .

    MULTIPLY        reduce using rule 66 (term_arithmetique -> factor_arithmetique .)
    DIVIDE          reduce using rule 66 (term_arithmetique -> factor_arithmetique .)
    SEMICOLON       reduce using rule 66 (term_arithmetique -> factor_arithmetique .)
    PLUS            reduce using rule 66 (term_arithmetique -> factor_arithmetique .)
    MINUS           reduce using rule 66 (term_arithmetique -> factor_arithmetique .)
    RPAREN          reduce using rule 66 (term_arithmetique -> factor_arithmetique .)


state 107

    (26) factor -> LPAREN . INTEGER RPAREN
    (27) factor -> LPAREN . FLOAT RPAREN
    (28) factor -> LPAREN . MINUS FLOAT RPAREN
    (70) factor_arithmetique -> LPAREN . expression_arithmetique RPAREN
    (61) expression_arithmetique -> . expression_arithmetique PLUS term_arithmetique
    (62) expression_arithmetique -> . expression_arithmetique MINUS term_arithmetique
    (63) expression_arithmetique -> . term_arithmetique
    (64) term_arithmetique -> . term_arithmetique MULTIPLY term_arithmetique
    (65) term_arithmetique -> . term_arithmetique DIVIDE factor_arithmetique
    (66) term_arithmetique -> . factor_arithmetique
    (67) factor_arithmetique -> . ID
    (68) factor_arithmetique -> . INTEGER
    (69) factor_arithmetique -> . FLOAT
    (70) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN

    INTEGER         shift and go to state 145
    FLOAT           shift and go to state 146
    MINUS           shift and go to state 97
    ID              shift and go to state 148
    LPAREN          shift and go to state 144

    expression_arithmetique        shift and go to state 147
    term_arithmetique              shift and go to state 103
    factor_arithmetique            shift and go to state 106

state 108

    (45) expressionTab -> ID .

    RBRACKET        reduce using rule 45 (expressionTab -> ID .)
    COMMA           reduce using rule 45 (expressionTab -> ID .)
    SEMICOLON       reduce using rule 45 (expressionTab -> ID .)


state 109

    (50) array_assignment -> ID LBRACKET expressionTab . RBRACKET EQUALS expressionTab SEMICOLON

    RBRACKET        shift and go to state 149


state 110

    (46) expressionTab -> FLOAT .

    RBRACKET        reduce using rule 46 (expressionTab -> FLOAT .)
    COMMA           reduce using rule 46 (expressionTab -> FLOAT .)
    SEMICOLON       reduce using rule 46 (expressionTab -> FLOAT .)


state 111

    (47) expressionTab -> INTEGER .

    RBRACKET        reduce using rule 47 (expressionTab -> INTEGER .)
    COMMA           reduce using rule 47 (expressionTab -> INTEGER .)
    SEMICOLON       reduce using rule 47 (expressionTab -> INTEGER .)


state 112

    (48) expressionTab -> CHAR .

    RBRACKET        reduce using rule 48 (expressionTab -> CHAR .)
    COMMA           reduce using rule 48 (expressionTab -> CHAR .)
    SEMICOLON       reduce using rule 48 (expressionTab -> CHAR .)


state 113

    (59) statement -> type ID EQUALS . expression_arithmetique SEMICOLON
    (61) expression_arithmetique -> . expression_arithmetique PLUS term_arithmetique
    (62) expression_arithmetique -> . expression_arithmetique MINUS term_arithmetique
    (63) expression_arithmetique -> . term_arithmetique
    (64) term_arithmetique -> . term_arithmetique MULTIPLY term_arithmetique
    (65) term_arithmetique -> . term_arithmetique DIVIDE factor_arithmetique
    (66) term_arithmetique -> . factor_arithmetique
    (67) factor_arithmetique -> . ID
    (68) factor_arithmetique -> . INTEGER
    (69) factor_arithmetique -> . FLOAT
    (70) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN

    ID              shift and go to state 148
    INTEGER         shift and go to state 151
    FLOAT           shift and go to state 152
    LPAREN          shift and go to state 144

    expression_arithmetique        shift and go to state 150
    term_arithmetique              shift and go to state 103
    factor_arithmetique            shift and go to state 106

state 114

    (71) statement -> READ LPAREN ID . RPAREN SEMICOLON
    (72) statement -> READ LPAREN ID . LBRACKET INTEGER RBRACKET RPAREN SEMICOLON

    RPAREN          shift and go to state 153
    LBRACKET        shift and go to state 154


state 115

    (73) statement -> WRITE LPAREN write_content . RPAREN SEMICOLON
    (75) write_content -> write_content . COMMA write_item

    RPAREN          shift and go to state 155
    COMMA           shift and go to state 156


state 116

    (74) write_content -> write_item .

    RPAREN          reduce using rule 74 (write_content -> write_item .)
    COMMA           reduce using rule 74 (write_content -> write_item .)


state 117

    (76) write_item -> ID .
    (77) write_item -> ID . LBRACKET INTEGER RBRACKET

    RPAREN          reduce using rule 76 (write_item -> ID .)
    COMMA           reduce using rule 76 (write_item -> ID .)
    LBRACKET        shift and go to state 157


state 118

    (78) statement -> FOR LPAREN initialisation . COLON step COLON BorneSup RPAREN block

    COLON           shift and go to state 158


state 119

    (79) initialisation -> ID . EQUALS INTEGER

    EQUALS          shift and go to state 159


state 120

    (86) IFTHENELSE -> IFTHEN ELSE block .

    ID              reduce using rule 86 (IFTHENELSE -> IFTHEN ELSE block .)
    READ            reduce using rule 86 (IFTHENELSE -> IFTHEN ELSE block .)
    WRITE           reduce using rule 86 (IFTHENELSE -> IFTHEN ELSE block .)
    FOR             reduce using rule 86 (IFTHENELSE -> IFTHEN ELSE block .)
    INT_TYPE        reduce using rule 86 (IFTHENELSE -> IFTHEN ELSE block .)
    FLOAT_TYPE      reduce using rule 86 (IFTHENELSE -> IFTHEN ELSE block .)
    BOOL_TYPE       reduce using rule 86 (IFTHENELSE -> IFTHEN ELSE block .)
    CHAR_TYPE       reduce using rule 86 (IFTHENELSE -> IFTHEN ELSE block .)
    IF              reduce using rule 86 (IFTHENELSE -> IFTHEN ELSE block .)
    RBRACE          reduce using rule 86 (IFTHENELSE -> IFTHEN ELSE block .)


state 121

    (83) block -> LBRACE . statements RBRACE
    (29) statements -> . statement
    (30) statements -> . statement statements
    (31) statements -> . empty
    (15) statement -> . ID EQUALS expression SEMICOLON
    (32) statement -> . simple_assignment
    (33) statement -> . array_assignment
    (59) statement -> . type ID EQUALS expression_arithmetique SEMICOLON
    (60) statement -> . ID EQUALS expression_arithmetique SEMICOLON
    (71) statement -> . READ LPAREN ID RPAREN SEMICOLON
    (72) statement -> . READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON
    (73) statement -> . WRITE LPAREN write_content RPAREN SEMICOLON
    (78) statement -> . FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block
    (84) statement -> . IFTHEN
    (85) statement -> . IFTHENELSE
    (8) empty -> .
    (37) simple_assignment -> . ID EQUALS expressionTab SEMICOLON
    (50) array_assignment -> . ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON
    (16) type -> . INT_TYPE
    (17) type -> . FLOAT_TYPE
    (18) type -> . BOOL_TYPE
    (19) type -> . CHAR_TYPE
    (87) IFTHEN -> . conditionIF RPAREN block
    (86) IFTHENELSE -> . IFTHEN ELSE block
    (88) conditionIF -> . IF LPAREN condition

    ID              shift and go to state 36
    READ            shift and go to state 40
    WRITE           shift and go to state 41
    FOR             shift and go to state 42
    RBRACE          reduce using rule 8 (empty -> .)
    INT_TYPE        shift and go to state 18
    FLOAT_TYPE      shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    CHAR_TYPE       shift and go to state 21
    IF              shift and go to state 46

    statements                     shift and go to state 160
    statement                      shift and go to state 34
    empty                          shift and go to state 35
    simple_assignment              shift and go to state 37
    array_assignment               shift and go to state 38
    type                           shift and go to state 39
    IFTHEN                         shift and go to state 43
    IFTHENELSE                     shift and go to state 44
    conditionIF                    shift and go to state 45

state 122

    (87) IFTHEN -> conditionIF RPAREN block .

    ELSE            reduce using rule 87 (IFTHEN -> conditionIF RPAREN block .)
    ID              reduce using rule 87 (IFTHEN -> conditionIF RPAREN block .)
    READ            reduce using rule 87 (IFTHEN -> conditionIF RPAREN block .)
    WRITE           reduce using rule 87 (IFTHEN -> conditionIF RPAREN block .)
    FOR             reduce using rule 87 (IFTHEN -> conditionIF RPAREN block .)
    INT_TYPE        reduce using rule 87 (IFTHEN -> conditionIF RPAREN block .)
    FLOAT_TYPE      reduce using rule 87 (IFTHEN -> conditionIF RPAREN block .)
    BOOL_TYPE       reduce using rule 87 (IFTHEN -> conditionIF RPAREN block .)
    CHAR_TYPE       reduce using rule 87 (IFTHEN -> conditionIF RPAREN block .)
    IF              reduce using rule 87 (IFTHEN -> conditionIF RPAREN block .)
    RBRACE          reduce using rule 87 (IFTHEN -> conditionIF RPAREN block .)


state 123

    (88) conditionIF -> IF LPAREN condition .

    RPAREN          reduce using rule 88 (conditionIF -> IF LPAREN condition .)


state 124

    (89) condition -> ID . EQ ID
    (90) condition -> ID . NEQ ID
    (91) condition -> ID . LT ID
    (92) condition -> ID . LTE ID
    (93) condition -> ID . GT ID
    (94) condition -> ID . GTE ID
    (95) condition -> ID . EQ factor
    (96) condition -> ID . NEQ factor
    (97) condition -> ID . LT factor
    (98) condition -> ID . LTE factor
    (99) condition -> ID . GT factor
    (100) condition -> ID . GTE factor
    (49) factor -> ID . LBRACKET expressionTab RBRACKET
    (55) factor -> ID .

    EQ              shift and go to state 161
    NEQ             shift and go to state 162
    LT              shift and go to state 163
    LTE             shift and go to state 164
    GT              shift and go to state 165
    GTE             shift and go to state 166
    LBRACKET        shift and go to state 90
    AND             reduce using rule 55 (factor -> ID .)
    OR              reduce using rule 55 (factor -> ID .)
    RPAREN          reduce using rule 55 (factor -> ID .)


state 125

    (101) condition -> expression .
    (51) expression -> expression . OR term

    RPAREN          reduce using rule 101 (condition -> expression .)
    OR              shift and go to state 91


state 126

    (39) array_declarationTab -> type ID LBRACKET INTEGER RBRACKET . SEMICOLON
    (44) declarationTab -> ID LBRACKET INTEGER RBRACKET .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 167
    COMMA           reduce using rule 44 (declarationTab -> ID LBRACKET INTEGER RBRACKET .)

  ! SEMICOLON       [ reduce using rule 44 (declarationTab -> ID LBRACKET INTEGER RBRACKET .) ]


state 127

    (43) declarationTab -> ID EQUALS . expressionTab
    (45) expressionTab -> . ID
    (46) expressionTab -> . FLOAT
    (47) expressionTab -> . INTEGER
    (48) expressionTab -> . CHAR

    ID              shift and go to state 108
    FLOAT           shift and go to state 110
    INTEGER         shift and go to state 111
    CHAR            shift and go to state 112

    expressionTab                  shift and go to state 82

state 128

    (44) declarationTab -> ID LBRACKET . INTEGER RBRACKET

    INTEGER         shift and go to state 168


state 129

    (10) declaration -> CONST type ID EQUALS expression . SEMICOLON
    (51) expression -> expression . OR term

    SEMICOLON       shift and go to state 169
    OR              shift and go to state 91


state 130

    (38) const_declarationTab -> CONST type ID EQUALS expressionTab . SEMICOLON

    SEMICOLON       shift and go to state 170


state 131

    (49) factor -> ID LBRACKET expressionTab . RBRACKET

    RBRACKET        shift and go to state 171


state 132

    (51) expression -> expression OR term .
    (53) term -> term . AND factor

    OR              reduce using rule 51 (expression -> expression OR term .)
    CONST           reduce using rule 51 (expression -> expression OR term .)
    ID              reduce using rule 51 (expression -> expression OR term .)
    INT_TYPE        reduce using rule 51 (expression -> expression OR term .)
    FLOAT_TYPE      reduce using rule 51 (expression -> expression OR term .)
    BOOL_TYPE       reduce using rule 51 (expression -> expression OR term .)
    CHAR_TYPE       reduce using rule 51 (expression -> expression OR term .)
    RBRACE          reduce using rule 51 (expression -> expression OR term .)
    COMMA           reduce using rule 51 (expression -> expression OR term .)
    SEMICOLON       reduce using rule 51 (expression -> expression OR term .)
    RPAREN          reduce using rule 51 (expression -> expression OR term .)
    AND             shift and go to state 92


state 133

    (53) term -> term AND factor .

    AND             reduce using rule 53 (term -> term AND factor .)
    OR              reduce using rule 53 (term -> term AND factor .)
    CONST           reduce using rule 53 (term -> term AND factor .)
    ID              reduce using rule 53 (term -> term AND factor .)
    INT_TYPE        reduce using rule 53 (term -> term AND factor .)
    FLOAT_TYPE      reduce using rule 53 (term -> term AND factor .)
    BOOL_TYPE       reduce using rule 53 (term -> term AND factor .)
    CHAR_TYPE       reduce using rule 53 (term -> term AND factor .)
    RBRACE          reduce using rule 53 (term -> term AND factor .)
    COMMA           reduce using rule 53 (term -> term AND factor .)
    SEMICOLON       reduce using rule 53 (term -> term AND factor .)
    RPAREN          reduce using rule 53 (term -> term AND factor .)


state 134

    (26) factor -> LPAREN INTEGER RPAREN .

    AND             reduce using rule 26 (factor -> LPAREN INTEGER RPAREN .)
    OR              reduce using rule 26 (factor -> LPAREN INTEGER RPAREN .)
    CONST           reduce using rule 26 (factor -> LPAREN INTEGER RPAREN .)
    ID              reduce using rule 26 (factor -> LPAREN INTEGER RPAREN .)
    INT_TYPE        reduce using rule 26 (factor -> LPAREN INTEGER RPAREN .)
    FLOAT_TYPE      reduce using rule 26 (factor -> LPAREN INTEGER RPAREN .)
    BOOL_TYPE       reduce using rule 26 (factor -> LPAREN INTEGER RPAREN .)
    CHAR_TYPE       reduce using rule 26 (factor -> LPAREN INTEGER RPAREN .)
    RBRACE          reduce using rule 26 (factor -> LPAREN INTEGER RPAREN .)
    COMMA           reduce using rule 26 (factor -> LPAREN INTEGER RPAREN .)
    SEMICOLON       reduce using rule 26 (factor -> LPAREN INTEGER RPAREN .)
    RPAREN          reduce using rule 26 (factor -> LPAREN INTEGER RPAREN .)


state 135

    (27) factor -> LPAREN FLOAT RPAREN .

    AND             reduce using rule 27 (factor -> LPAREN FLOAT RPAREN .)
    OR              reduce using rule 27 (factor -> LPAREN FLOAT RPAREN .)
    CONST           reduce using rule 27 (factor -> LPAREN FLOAT RPAREN .)
    ID              reduce using rule 27 (factor -> LPAREN FLOAT RPAREN .)
    INT_TYPE        reduce using rule 27 (factor -> LPAREN FLOAT RPAREN .)
    FLOAT_TYPE      reduce using rule 27 (factor -> LPAREN FLOAT RPAREN .)
    BOOL_TYPE       reduce using rule 27 (factor -> LPAREN FLOAT RPAREN .)
    CHAR_TYPE       reduce using rule 27 (factor -> LPAREN FLOAT RPAREN .)
    RBRACE          reduce using rule 27 (factor -> LPAREN FLOAT RPAREN .)
    COMMA           reduce using rule 27 (factor -> LPAREN FLOAT RPAREN .)
    SEMICOLON       reduce using rule 27 (factor -> LPAREN FLOAT RPAREN .)
    RPAREN          reduce using rule 27 (factor -> LPAREN FLOAT RPAREN .)


state 136

    (28) factor -> LPAREN MINUS FLOAT . RPAREN

    RPAREN          shift and go to state 172


state 137

    (15) statement -> ID EQUALS expression SEMICOLON .

    ID              reduce using rule 15 (statement -> ID EQUALS expression SEMICOLON .)
    READ            reduce using rule 15 (statement -> ID EQUALS expression SEMICOLON .)
    WRITE           reduce using rule 15 (statement -> ID EQUALS expression SEMICOLON .)
    FOR             reduce using rule 15 (statement -> ID EQUALS expression SEMICOLON .)
    INT_TYPE        reduce using rule 15 (statement -> ID EQUALS expression SEMICOLON .)
    FLOAT_TYPE      reduce using rule 15 (statement -> ID EQUALS expression SEMICOLON .)
    BOOL_TYPE       reduce using rule 15 (statement -> ID EQUALS expression SEMICOLON .)
    CHAR_TYPE       reduce using rule 15 (statement -> ID EQUALS expression SEMICOLON .)
    IF              reduce using rule 15 (statement -> ID EQUALS expression SEMICOLON .)
    RBRACE          reduce using rule 15 (statement -> ID EQUALS expression SEMICOLON .)


state 138

    (60) statement -> ID EQUALS expression_arithmetique SEMICOLON .

    ID              reduce using rule 60 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    READ            reduce using rule 60 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    WRITE           reduce using rule 60 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    FOR             reduce using rule 60 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    INT_TYPE        reduce using rule 60 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    FLOAT_TYPE      reduce using rule 60 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    BOOL_TYPE       reduce using rule 60 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    CHAR_TYPE       reduce using rule 60 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    IF              reduce using rule 60 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    RBRACE          reduce using rule 60 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)


state 139

    (61) expression_arithmetique -> expression_arithmetique PLUS . term_arithmetique
    (64) term_arithmetique -> . term_arithmetique MULTIPLY term_arithmetique
    (65) term_arithmetique -> . term_arithmetique DIVIDE factor_arithmetique
    (66) term_arithmetique -> . factor_arithmetique
    (67) factor_arithmetique -> . ID
    (68) factor_arithmetique -> . INTEGER
    (69) factor_arithmetique -> . FLOAT
    (70) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN

    ID              shift and go to state 148
    INTEGER         shift and go to state 151
    FLOAT           shift and go to state 152
    LPAREN          shift and go to state 144

    term_arithmetique              shift and go to state 173
    factor_arithmetique            shift and go to state 106

state 140

    (62) expression_arithmetique -> expression_arithmetique MINUS . term_arithmetique
    (64) term_arithmetique -> . term_arithmetique MULTIPLY term_arithmetique
    (65) term_arithmetique -> . term_arithmetique DIVIDE factor_arithmetique
    (66) term_arithmetique -> . factor_arithmetique
    (67) factor_arithmetique -> . ID
    (68) factor_arithmetique -> . INTEGER
    (69) factor_arithmetique -> . FLOAT
    (70) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN

    ID              shift and go to state 148
    INTEGER         shift and go to state 151
    FLOAT           shift and go to state 152
    LPAREN          shift and go to state 144

    term_arithmetique              shift and go to state 174
    factor_arithmetique            shift and go to state 106

state 141

    (37) simple_assignment -> ID EQUALS expressionTab SEMICOLON .

    ID              reduce using rule 37 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    READ            reduce using rule 37 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    WRITE           reduce using rule 37 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    FOR             reduce using rule 37 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    INT_TYPE        reduce using rule 37 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    FLOAT_TYPE      reduce using rule 37 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    BOOL_TYPE       reduce using rule 37 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    CHAR_TYPE       reduce using rule 37 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    IF              reduce using rule 37 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    RBRACE          reduce using rule 37 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)


state 142

    (64) term_arithmetique -> term_arithmetique MULTIPLY . term_arithmetique
    (64) term_arithmetique -> . term_arithmetique MULTIPLY term_arithmetique
    (65) term_arithmetique -> . term_arithmetique DIVIDE factor_arithmetique
    (66) term_arithmetique -> . factor_arithmetique
    (67) factor_arithmetique -> . ID
    (68) factor_arithmetique -> . INTEGER
    (69) factor_arithmetique -> . FLOAT
    (70) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN

    ID              shift and go to state 148
    INTEGER         shift and go to state 151
    FLOAT           shift and go to state 152
    LPAREN          shift and go to state 144

    term_arithmetique              shift and go to state 175
    factor_arithmetique            shift and go to state 106

state 143

    (65) term_arithmetique -> term_arithmetique DIVIDE . factor_arithmetique
    (67) factor_arithmetique -> . ID
    (68) factor_arithmetique -> . INTEGER
    (69) factor_arithmetique -> . FLOAT
    (70) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN

    ID              shift and go to state 148
    INTEGER         shift and go to state 151
    FLOAT           shift and go to state 152
    LPAREN          shift and go to state 144

    factor_arithmetique            shift and go to state 176

state 144

    (70) factor_arithmetique -> LPAREN . expression_arithmetique RPAREN
    (61) expression_arithmetique -> . expression_arithmetique PLUS term_arithmetique
    (62) expression_arithmetique -> . expression_arithmetique MINUS term_arithmetique
    (63) expression_arithmetique -> . term_arithmetique
    (64) term_arithmetique -> . term_arithmetique MULTIPLY term_arithmetique
    (65) term_arithmetique -> . term_arithmetique DIVIDE factor_arithmetique
    (66) term_arithmetique -> . factor_arithmetique
    (67) factor_arithmetique -> . ID
    (68) factor_arithmetique -> . INTEGER
    (69) factor_arithmetique -> . FLOAT
    (70) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN

    ID              shift and go to state 148
    INTEGER         shift and go to state 151
    FLOAT           shift and go to state 152
    LPAREN          shift and go to state 144

    expression_arithmetique        shift and go to state 147
    term_arithmetique              shift and go to state 103
    factor_arithmetique            shift and go to state 106

state 145

    (26) factor -> LPAREN INTEGER . RPAREN
    (68) factor_arithmetique -> INTEGER .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 134
    MULTIPLY        reduce using rule 68 (factor_arithmetique -> INTEGER .)
    DIVIDE          reduce using rule 68 (factor_arithmetique -> INTEGER .)
    PLUS            reduce using rule 68 (factor_arithmetique -> INTEGER .)
    MINUS           reduce using rule 68 (factor_arithmetique -> INTEGER .)

  ! RPAREN          [ reduce using rule 68 (factor_arithmetique -> INTEGER .) ]


state 146

    (27) factor -> LPAREN FLOAT . RPAREN
    (69) factor_arithmetique -> FLOAT .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 135
    MULTIPLY        reduce using rule 69 (factor_arithmetique -> FLOAT .)
    DIVIDE          reduce using rule 69 (factor_arithmetique -> FLOAT .)
    PLUS            reduce using rule 69 (factor_arithmetique -> FLOAT .)
    MINUS           reduce using rule 69 (factor_arithmetique -> FLOAT .)

  ! RPAREN          [ reduce using rule 69 (factor_arithmetique -> FLOAT .) ]


state 147

    (70) factor_arithmetique -> LPAREN expression_arithmetique . RPAREN
    (61) expression_arithmetique -> expression_arithmetique . PLUS term_arithmetique
    (62) expression_arithmetique -> expression_arithmetique . MINUS term_arithmetique

    RPAREN          shift and go to state 177
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140


state 148

    (67) factor_arithmetique -> ID .

    MULTIPLY        reduce using rule 67 (factor_arithmetique -> ID .)
    DIVIDE          reduce using rule 67 (factor_arithmetique -> ID .)
    RPAREN          reduce using rule 67 (factor_arithmetique -> ID .)
    PLUS            reduce using rule 67 (factor_arithmetique -> ID .)
    MINUS           reduce using rule 67 (factor_arithmetique -> ID .)
    SEMICOLON       reduce using rule 67 (factor_arithmetique -> ID .)


state 149

    (50) array_assignment -> ID LBRACKET expressionTab RBRACKET . EQUALS expressionTab SEMICOLON

    EQUALS          shift and go to state 178


state 150

    (59) statement -> type ID EQUALS expression_arithmetique . SEMICOLON
    (61) expression_arithmetique -> expression_arithmetique . PLUS term_arithmetique
    (62) expression_arithmetique -> expression_arithmetique . MINUS term_arithmetique

    SEMICOLON       shift and go to state 179
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140


state 151

    (68) factor_arithmetique -> INTEGER .

    MULTIPLY        reduce using rule 68 (factor_arithmetique -> INTEGER .)
    DIVIDE          reduce using rule 68 (factor_arithmetique -> INTEGER .)
    SEMICOLON       reduce using rule 68 (factor_arithmetique -> INTEGER .)
    PLUS            reduce using rule 68 (factor_arithmetique -> INTEGER .)
    MINUS           reduce using rule 68 (factor_arithmetique -> INTEGER .)
    RPAREN          reduce using rule 68 (factor_arithmetique -> INTEGER .)


state 152

    (69) factor_arithmetique -> FLOAT .

    MULTIPLY        reduce using rule 69 (factor_arithmetique -> FLOAT .)
    DIVIDE          reduce using rule 69 (factor_arithmetique -> FLOAT .)
    SEMICOLON       reduce using rule 69 (factor_arithmetique -> FLOAT .)
    PLUS            reduce using rule 69 (factor_arithmetique -> FLOAT .)
    MINUS           reduce using rule 69 (factor_arithmetique -> FLOAT .)
    RPAREN          reduce using rule 69 (factor_arithmetique -> FLOAT .)


state 153

    (71) statement -> READ LPAREN ID RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 180


state 154

    (72) statement -> READ LPAREN ID LBRACKET . INTEGER RBRACKET RPAREN SEMICOLON

    INTEGER         shift and go to state 181


state 155

    (73) statement -> WRITE LPAREN write_content RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 182


state 156

    (75) write_content -> write_content COMMA . write_item
    (76) write_item -> . ID
    (77) write_item -> . ID LBRACKET INTEGER RBRACKET

    ID              shift and go to state 117

    write_item                     shift and go to state 183

state 157

    (77) write_item -> ID LBRACKET . INTEGER RBRACKET

    INTEGER         shift and go to state 184


state 158

    (78) statement -> FOR LPAREN initialisation COLON . step COLON BorneSup RPAREN block
    (80) step -> . INTEGER
    (81) step -> . ID

    INTEGER         shift and go to state 186
    ID              shift and go to state 187

    step                           shift and go to state 185

state 159

    (79) initialisation -> ID EQUALS . INTEGER

    INTEGER         shift and go to state 188


state 160

    (83) block -> LBRACE statements . RBRACE

    RBRACE          shift and go to state 189


state 161

    (89) condition -> ID EQ . ID
    (95) condition -> ID EQ . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . CHAR
    (23) factor -> . BOOL
    (24) factor -> . MINUS factor
    (25) factor -> . PLUS factor
    (26) factor -> . LPAREN INTEGER RPAREN
    (27) factor -> . LPAREN FLOAT RPAREN
    (28) factor -> . LPAREN MINUS FLOAT RPAREN
    (49) factor -> . ID LBRACKET expressionTab RBRACKET
    (55) factor -> . ID
    (56) factor -> . TRUE
    (57) factor -> . FALSE
    (58) factor -> . NOT ID

    ID              shift and go to state 190
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    CHAR            shift and go to state 61
    BOOL            shift and go to state 62
    MINUS           shift and go to state 63
    PLUS            shift and go to state 64
    LPAREN          shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    NOT             shift and go to state 68

    factor                         shift and go to state 191

state 162

    (90) condition -> ID NEQ . ID
    (96) condition -> ID NEQ . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . CHAR
    (23) factor -> . BOOL
    (24) factor -> . MINUS factor
    (25) factor -> . PLUS factor
    (26) factor -> . LPAREN INTEGER RPAREN
    (27) factor -> . LPAREN FLOAT RPAREN
    (28) factor -> . LPAREN MINUS FLOAT RPAREN
    (49) factor -> . ID LBRACKET expressionTab RBRACKET
    (55) factor -> . ID
    (56) factor -> . TRUE
    (57) factor -> . FALSE
    (58) factor -> . NOT ID

    ID              shift and go to state 192
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    CHAR            shift and go to state 61
    BOOL            shift and go to state 62
    MINUS           shift and go to state 63
    PLUS            shift and go to state 64
    LPAREN          shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    NOT             shift and go to state 68

    factor                         shift and go to state 193

state 163

    (91) condition -> ID LT . ID
    (97) condition -> ID LT . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . CHAR
    (23) factor -> . BOOL
    (24) factor -> . MINUS factor
    (25) factor -> . PLUS factor
    (26) factor -> . LPAREN INTEGER RPAREN
    (27) factor -> . LPAREN FLOAT RPAREN
    (28) factor -> . LPAREN MINUS FLOAT RPAREN
    (49) factor -> . ID LBRACKET expressionTab RBRACKET
    (55) factor -> . ID
    (56) factor -> . TRUE
    (57) factor -> . FALSE
    (58) factor -> . NOT ID

    ID              shift and go to state 194
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    CHAR            shift and go to state 61
    BOOL            shift and go to state 62
    MINUS           shift and go to state 63
    PLUS            shift and go to state 64
    LPAREN          shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    NOT             shift and go to state 68

    factor                         shift and go to state 195

state 164

    (92) condition -> ID LTE . ID
    (98) condition -> ID LTE . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . CHAR
    (23) factor -> . BOOL
    (24) factor -> . MINUS factor
    (25) factor -> . PLUS factor
    (26) factor -> . LPAREN INTEGER RPAREN
    (27) factor -> . LPAREN FLOAT RPAREN
    (28) factor -> . LPAREN MINUS FLOAT RPAREN
    (49) factor -> . ID LBRACKET expressionTab RBRACKET
    (55) factor -> . ID
    (56) factor -> . TRUE
    (57) factor -> . FALSE
    (58) factor -> . NOT ID

    ID              shift and go to state 196
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    CHAR            shift and go to state 61
    BOOL            shift and go to state 62
    MINUS           shift and go to state 63
    PLUS            shift and go to state 64
    LPAREN          shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    NOT             shift and go to state 68

    factor                         shift and go to state 197

state 165

    (93) condition -> ID GT . ID
    (99) condition -> ID GT . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . CHAR
    (23) factor -> . BOOL
    (24) factor -> . MINUS factor
    (25) factor -> . PLUS factor
    (26) factor -> . LPAREN INTEGER RPAREN
    (27) factor -> . LPAREN FLOAT RPAREN
    (28) factor -> . LPAREN MINUS FLOAT RPAREN
    (49) factor -> . ID LBRACKET expressionTab RBRACKET
    (55) factor -> . ID
    (56) factor -> . TRUE
    (57) factor -> . FALSE
    (58) factor -> . NOT ID

    ID              shift and go to state 198
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    CHAR            shift and go to state 61
    BOOL            shift and go to state 62
    MINUS           shift and go to state 63
    PLUS            shift and go to state 64
    LPAREN          shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    NOT             shift and go to state 68

    factor                         shift and go to state 199

state 166

    (94) condition -> ID GTE . ID
    (100) condition -> ID GTE . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . CHAR
    (23) factor -> . BOOL
    (24) factor -> . MINUS factor
    (25) factor -> . PLUS factor
    (26) factor -> . LPAREN INTEGER RPAREN
    (27) factor -> . LPAREN FLOAT RPAREN
    (28) factor -> . LPAREN MINUS FLOAT RPAREN
    (49) factor -> . ID LBRACKET expressionTab RBRACKET
    (55) factor -> . ID
    (56) factor -> . TRUE
    (57) factor -> . FALSE
    (58) factor -> . NOT ID

    ID              shift and go to state 200
    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60
    CHAR            shift and go to state 61
    BOOL            shift and go to state 62
    MINUS           shift and go to state 63
    PLUS            shift and go to state 64
    LPAREN          shift and go to state 65
    TRUE            shift and go to state 66
    FALSE           shift and go to state 67
    NOT             shift and go to state 68

    factor                         shift and go to state 201

state 167

    (39) array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .

    CONST           reduce using rule 39 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    ID              reduce using rule 39 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    INT_TYPE        reduce using rule 39 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    FLOAT_TYPE      reduce using rule 39 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    BOOL_TYPE       reduce using rule 39 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    CHAR_TYPE       reduce using rule 39 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    RBRACE          reduce using rule 39 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    COMMA           reduce using rule 39 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 39 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)


state 168

    (44) declarationTab -> ID LBRACKET INTEGER . RBRACKET

    RBRACKET        shift and go to state 202


state 169

    (10) declaration -> CONST type ID EQUALS expression SEMICOLON .

    CONST           reduce using rule 10 (declaration -> CONST type ID EQUALS expression SEMICOLON .)
    ID              reduce using rule 10 (declaration -> CONST type ID EQUALS expression SEMICOLON .)
    INT_TYPE        reduce using rule 10 (declaration -> CONST type ID EQUALS expression SEMICOLON .)
    FLOAT_TYPE      reduce using rule 10 (declaration -> CONST type ID EQUALS expression SEMICOLON .)
    BOOL_TYPE       reduce using rule 10 (declaration -> CONST type ID EQUALS expression SEMICOLON .)
    CHAR_TYPE       reduce using rule 10 (declaration -> CONST type ID EQUALS expression SEMICOLON .)
    RBRACE          reduce using rule 10 (declaration -> CONST type ID EQUALS expression SEMICOLON .)
    COMMA           reduce using rule 10 (declaration -> CONST type ID EQUALS expression SEMICOLON .)
    SEMICOLON       reduce using rule 10 (declaration -> CONST type ID EQUALS expression SEMICOLON .)


state 170

    (38) const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .

    CONST           reduce using rule 38 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    ID              reduce using rule 38 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    INT_TYPE        reduce using rule 38 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    FLOAT_TYPE      reduce using rule 38 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    BOOL_TYPE       reduce using rule 38 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    CHAR_TYPE       reduce using rule 38 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    RBRACE          reduce using rule 38 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    COMMA           reduce using rule 38 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    SEMICOLON       reduce using rule 38 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)


state 171

    (49) factor -> ID LBRACKET expressionTab RBRACKET .

    AND             reduce using rule 49 (factor -> ID LBRACKET expressionTab RBRACKET .)
    OR              reduce using rule 49 (factor -> ID LBRACKET expressionTab RBRACKET .)
    CONST           reduce using rule 49 (factor -> ID LBRACKET expressionTab RBRACKET .)
    ID              reduce using rule 49 (factor -> ID LBRACKET expressionTab RBRACKET .)
    INT_TYPE        reduce using rule 49 (factor -> ID LBRACKET expressionTab RBRACKET .)
    FLOAT_TYPE      reduce using rule 49 (factor -> ID LBRACKET expressionTab RBRACKET .)
    BOOL_TYPE       reduce using rule 49 (factor -> ID LBRACKET expressionTab RBRACKET .)
    CHAR_TYPE       reduce using rule 49 (factor -> ID LBRACKET expressionTab RBRACKET .)
    RBRACE          reduce using rule 49 (factor -> ID LBRACKET expressionTab RBRACKET .)
    COMMA           reduce using rule 49 (factor -> ID LBRACKET expressionTab RBRACKET .)
    SEMICOLON       reduce using rule 49 (factor -> ID LBRACKET expressionTab RBRACKET .)
    RPAREN          reduce using rule 49 (factor -> ID LBRACKET expressionTab RBRACKET .)


state 172

    (28) factor -> LPAREN MINUS FLOAT RPAREN .

    AND             reduce using rule 28 (factor -> LPAREN MINUS FLOAT RPAREN .)
    OR              reduce using rule 28 (factor -> LPAREN MINUS FLOAT RPAREN .)
    CONST           reduce using rule 28 (factor -> LPAREN MINUS FLOAT RPAREN .)
    ID              reduce using rule 28 (factor -> LPAREN MINUS FLOAT RPAREN .)
    INT_TYPE        reduce using rule 28 (factor -> LPAREN MINUS FLOAT RPAREN .)
    FLOAT_TYPE      reduce using rule 28 (factor -> LPAREN MINUS FLOAT RPAREN .)
    BOOL_TYPE       reduce using rule 28 (factor -> LPAREN MINUS FLOAT RPAREN .)
    CHAR_TYPE       reduce using rule 28 (factor -> LPAREN MINUS FLOAT RPAREN .)
    RBRACE          reduce using rule 28 (factor -> LPAREN MINUS FLOAT RPAREN .)
    COMMA           reduce using rule 28 (factor -> LPAREN MINUS FLOAT RPAREN .)
    SEMICOLON       reduce using rule 28 (factor -> LPAREN MINUS FLOAT RPAREN .)
    RPAREN          reduce using rule 28 (factor -> LPAREN MINUS FLOAT RPAREN .)


state 173

    (61) expression_arithmetique -> expression_arithmetique PLUS term_arithmetique .
    (64) term_arithmetique -> term_arithmetique . MULTIPLY term_arithmetique
    (65) term_arithmetique -> term_arithmetique . DIVIDE factor_arithmetique

    SEMICOLON       reduce using rule 61 (expression_arithmetique -> expression_arithmetique PLUS term_arithmetique .)
    PLUS            reduce using rule 61 (expression_arithmetique -> expression_arithmetique PLUS term_arithmetique .)
    MINUS           reduce using rule 61 (expression_arithmetique -> expression_arithmetique PLUS term_arithmetique .)
    RPAREN          reduce using rule 61 (expression_arithmetique -> expression_arithmetique PLUS term_arithmetique .)
    MULTIPLY        shift and go to state 142
    DIVIDE          shift and go to state 143


state 174

    (62) expression_arithmetique -> expression_arithmetique MINUS term_arithmetique .
    (64) term_arithmetique -> term_arithmetique . MULTIPLY term_arithmetique
    (65) term_arithmetique -> term_arithmetique . DIVIDE factor_arithmetique

    SEMICOLON       reduce using rule 62 (expression_arithmetique -> expression_arithmetique MINUS term_arithmetique .)
    PLUS            reduce using rule 62 (expression_arithmetique -> expression_arithmetique MINUS term_arithmetique .)
    MINUS           reduce using rule 62 (expression_arithmetique -> expression_arithmetique MINUS term_arithmetique .)
    RPAREN          reduce using rule 62 (expression_arithmetique -> expression_arithmetique MINUS term_arithmetique .)
    MULTIPLY        shift and go to state 142
    DIVIDE          shift and go to state 143


state 175

    (64) term_arithmetique -> term_arithmetique MULTIPLY term_arithmetique .
    (64) term_arithmetique -> term_arithmetique . MULTIPLY term_arithmetique
    (65) term_arithmetique -> term_arithmetique . DIVIDE factor_arithmetique

  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    SEMICOLON       reduce using rule 64 (term_arithmetique -> term_arithmetique MULTIPLY term_arithmetique .)
    PLUS            reduce using rule 64 (term_arithmetique -> term_arithmetique MULTIPLY term_arithmetique .)
    MINUS           reduce using rule 64 (term_arithmetique -> term_arithmetique MULTIPLY term_arithmetique .)
    RPAREN          reduce using rule 64 (term_arithmetique -> term_arithmetique MULTIPLY term_arithmetique .)
    MULTIPLY        shift and go to state 142
    DIVIDE          shift and go to state 143

  ! MULTIPLY        [ reduce using rule 64 (term_arithmetique -> term_arithmetique MULTIPLY term_arithmetique .) ]
  ! DIVIDE          [ reduce using rule 64 (term_arithmetique -> term_arithmetique MULTIPLY term_arithmetique .) ]


state 176

    (65) term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique .

    MULTIPLY        reduce using rule 65 (term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique .)
    DIVIDE          reduce using rule 65 (term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique .)
    SEMICOLON       reduce using rule 65 (term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique .)
    PLUS            reduce using rule 65 (term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique .)
    MINUS           reduce using rule 65 (term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique .)
    RPAREN          reduce using rule 65 (term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique .)


state 177

    (70) factor_arithmetique -> LPAREN expression_arithmetique RPAREN .

    MULTIPLY        reduce using rule 70 (factor_arithmetique -> LPAREN expression_arithmetique RPAREN .)
    DIVIDE          reduce using rule 70 (factor_arithmetique -> LPAREN expression_arithmetique RPAREN .)
    SEMICOLON       reduce using rule 70 (factor_arithmetique -> LPAREN expression_arithmetique RPAREN .)
    PLUS            reduce using rule 70 (factor_arithmetique -> LPAREN expression_arithmetique RPAREN .)
    MINUS           reduce using rule 70 (factor_arithmetique -> LPAREN expression_arithmetique RPAREN .)
    RPAREN          reduce using rule 70 (factor_arithmetique -> LPAREN expression_arithmetique RPAREN .)


state 178

    (50) array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS . expressionTab SEMICOLON
    (45) expressionTab -> . ID
    (46) expressionTab -> . FLOAT
    (47) expressionTab -> . INTEGER
    (48) expressionTab -> . CHAR

    ID              shift and go to state 108
    FLOAT           shift and go to state 110
    INTEGER         shift and go to state 111
    CHAR            shift and go to state 112

    expressionTab                  shift and go to state 203

state 179

    (59) statement -> type ID EQUALS expression_arithmetique SEMICOLON .

    ID              reduce using rule 59 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    READ            reduce using rule 59 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    WRITE           reduce using rule 59 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    FOR             reduce using rule 59 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    INT_TYPE        reduce using rule 59 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    FLOAT_TYPE      reduce using rule 59 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    BOOL_TYPE       reduce using rule 59 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    CHAR_TYPE       reduce using rule 59 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    IF              reduce using rule 59 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    RBRACE          reduce using rule 59 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)


state 180

    (71) statement -> READ LPAREN ID RPAREN SEMICOLON .

    ID              reduce using rule 71 (statement -> READ LPAREN ID RPAREN SEMICOLON .)
    READ            reduce using rule 71 (statement -> READ LPAREN ID RPAREN SEMICOLON .)
    WRITE           reduce using rule 71 (statement -> READ LPAREN ID RPAREN SEMICOLON .)
    FOR             reduce using rule 71 (statement -> READ LPAREN ID RPAREN SEMICOLON .)
    INT_TYPE        reduce using rule 71 (statement -> READ LPAREN ID RPAREN SEMICOLON .)
    FLOAT_TYPE      reduce using rule 71 (statement -> READ LPAREN ID RPAREN SEMICOLON .)
    BOOL_TYPE       reduce using rule 71 (statement -> READ LPAREN ID RPAREN SEMICOLON .)
    CHAR_TYPE       reduce using rule 71 (statement -> READ LPAREN ID RPAREN SEMICOLON .)
    IF              reduce using rule 71 (statement -> READ LPAREN ID RPAREN SEMICOLON .)
    RBRACE          reduce using rule 71 (statement -> READ LPAREN ID RPAREN SEMICOLON .)


state 181

    (72) statement -> READ LPAREN ID LBRACKET INTEGER . RBRACKET RPAREN SEMICOLON

    RBRACKET        shift and go to state 204


state 182

    (73) statement -> WRITE LPAREN write_content RPAREN SEMICOLON .

    ID              reduce using rule 73 (statement -> WRITE LPAREN write_content RPAREN SEMICOLON .)
    READ            reduce using rule 73 (statement -> WRITE LPAREN write_content RPAREN SEMICOLON .)
    WRITE           reduce using rule 73 (statement -> WRITE LPAREN write_content RPAREN SEMICOLON .)
    FOR             reduce using rule 73 (statement -> WRITE LPAREN write_content RPAREN SEMICOLON .)
    INT_TYPE        reduce using rule 73 (statement -> WRITE LPAREN write_content RPAREN SEMICOLON .)
    FLOAT_TYPE      reduce using rule 73 (statement -> WRITE LPAREN write_content RPAREN SEMICOLON .)
    BOOL_TYPE       reduce using rule 73 (statement -> WRITE LPAREN write_content RPAREN SEMICOLON .)
    CHAR_TYPE       reduce using rule 73 (statement -> WRITE LPAREN write_content RPAREN SEMICOLON .)
    IF              reduce using rule 73 (statement -> WRITE LPAREN write_content RPAREN SEMICOLON .)
    RBRACE          reduce using rule 73 (statement -> WRITE LPAREN write_content RPAREN SEMICOLON .)


state 183

    (75) write_content -> write_content COMMA write_item .

    RPAREN          reduce using rule 75 (write_content -> write_content COMMA write_item .)
    COMMA           reduce using rule 75 (write_content -> write_content COMMA write_item .)


state 184

    (77) write_item -> ID LBRACKET INTEGER . RBRACKET

    RBRACKET        shift and go to state 205


state 185

    (78) statement -> FOR LPAREN initialisation COLON step . COLON BorneSup RPAREN block

    COLON           shift and go to state 206


state 186

    (80) step -> INTEGER .

    COLON           reduce using rule 80 (step -> INTEGER .)


state 187

    (81) step -> ID .

    COLON           reduce using rule 81 (step -> ID .)


state 188

    (79) initialisation -> ID EQUALS INTEGER .

    COLON           reduce using rule 79 (initialisation -> ID EQUALS INTEGER .)


state 189

    (83) block -> LBRACE statements RBRACE .

    ID              reduce using rule 83 (block -> LBRACE statements RBRACE .)
    READ            reduce using rule 83 (block -> LBRACE statements RBRACE .)
    WRITE           reduce using rule 83 (block -> LBRACE statements RBRACE .)
    FOR             reduce using rule 83 (block -> LBRACE statements RBRACE .)
    INT_TYPE        reduce using rule 83 (block -> LBRACE statements RBRACE .)
    FLOAT_TYPE      reduce using rule 83 (block -> LBRACE statements RBRACE .)
    BOOL_TYPE       reduce using rule 83 (block -> LBRACE statements RBRACE .)
    CHAR_TYPE       reduce using rule 83 (block -> LBRACE statements RBRACE .)
    IF              reduce using rule 83 (block -> LBRACE statements RBRACE .)
    RBRACE          reduce using rule 83 (block -> LBRACE statements RBRACE .)
    ELSE            reduce using rule 83 (block -> LBRACE statements RBRACE .)


state 190

    (89) condition -> ID EQ ID .
    (49) factor -> ID . LBRACKET expressionTab RBRACKET
    (55) factor -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 55 (factor -> ID .)
    LBRACKET        shift and go to state 90
    RPAREN          reduce using rule 55 (factor -> ID .)

  ! RPAREN          [ reduce using rule 89 (condition -> ID EQ ID .) ]


state 191

    (95) condition -> ID EQ factor .

    RPAREN          reduce using rule 95 (condition -> ID EQ factor .)


state 192

    (90) condition -> ID NEQ ID .
    (49) factor -> ID . LBRACKET expressionTab RBRACKET
    (55) factor -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 55 (factor -> ID .)
    LBRACKET        shift and go to state 90
    RPAREN          reduce using rule 55 (factor -> ID .)

  ! RPAREN          [ reduce using rule 90 (condition -> ID NEQ ID .) ]


state 193

    (96) condition -> ID NEQ factor .

    RPAREN          reduce using rule 96 (condition -> ID NEQ factor .)


state 194

    (91) condition -> ID LT ID .
    (49) factor -> ID . LBRACKET expressionTab RBRACKET
    (55) factor -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 55 (factor -> ID .)
    LBRACKET        shift and go to state 90
    RPAREN          reduce using rule 55 (factor -> ID .)

  ! RPAREN          [ reduce using rule 91 (condition -> ID LT ID .) ]


state 195

    (97) condition -> ID LT factor .

    RPAREN          reduce using rule 97 (condition -> ID LT factor .)


state 196

    (92) condition -> ID LTE ID .
    (49) factor -> ID . LBRACKET expressionTab RBRACKET
    (55) factor -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 55 (factor -> ID .)
    LBRACKET        shift and go to state 90
    RPAREN          reduce using rule 55 (factor -> ID .)

  ! RPAREN          [ reduce using rule 92 (condition -> ID LTE ID .) ]


state 197

    (98) condition -> ID LTE factor .

    RPAREN          reduce using rule 98 (condition -> ID LTE factor .)


state 198

    (93) condition -> ID GT ID .
    (49) factor -> ID . LBRACKET expressionTab RBRACKET
    (55) factor -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 55 (factor -> ID .)
    LBRACKET        shift and go to state 90
    RPAREN          reduce using rule 55 (factor -> ID .)

  ! RPAREN          [ reduce using rule 93 (condition -> ID GT ID .) ]


state 199

    (99) condition -> ID GT factor .

    RPAREN          reduce using rule 99 (condition -> ID GT factor .)


state 200

    (94) condition -> ID GTE ID .
    (49) factor -> ID . LBRACKET expressionTab RBRACKET
    (55) factor -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 55 (factor -> ID .)
    LBRACKET        shift and go to state 90
    RPAREN          reduce using rule 55 (factor -> ID .)

  ! RPAREN          [ reduce using rule 94 (condition -> ID GTE ID .) ]


state 201

    (100) condition -> ID GTE factor .

    RPAREN          reduce using rule 100 (condition -> ID GTE factor .)


state 202

    (44) declarationTab -> ID LBRACKET INTEGER RBRACKET .

    COMMA           reduce using rule 44 (declarationTab -> ID LBRACKET INTEGER RBRACKET .)
    SEMICOLON       reduce using rule 44 (declarationTab -> ID LBRACKET INTEGER RBRACKET .)


state 203

    (50) array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab . SEMICOLON

    SEMICOLON       shift and go to state 207


state 204

    (72) statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET . RPAREN SEMICOLON

    RPAREN          shift and go to state 208


state 205

    (77) write_item -> ID LBRACKET INTEGER RBRACKET .

    RPAREN          reduce using rule 77 (write_item -> ID LBRACKET INTEGER RBRACKET .)
    COMMA           reduce using rule 77 (write_item -> ID LBRACKET INTEGER RBRACKET .)


state 206

    (78) statement -> FOR LPAREN initialisation COLON step COLON . BorneSup RPAREN block
    (82) BorneSup -> . ID

    ID              shift and go to state 210

    BorneSup                       shift and go to state 209

state 207

    (50) array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .

    ID              reduce using rule 50 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    READ            reduce using rule 50 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    WRITE           reduce using rule 50 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    FOR             reduce using rule 50 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    INT_TYPE        reduce using rule 50 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    FLOAT_TYPE      reduce using rule 50 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    BOOL_TYPE       reduce using rule 50 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    CHAR_TYPE       reduce using rule 50 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    IF              reduce using rule 50 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    RBRACE          reduce using rule 50 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)


state 208

    (72) statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 211


state 209

    (78) statement -> FOR LPAREN initialisation COLON step COLON BorneSup . RPAREN block

    RPAREN          shift and go to state 212


state 210

    (82) BorneSup -> ID .

    RPAREN          reduce using rule 82 (BorneSup -> ID .)


state 211

    (72) statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON .

    ID              reduce using rule 72 (statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON .)
    READ            reduce using rule 72 (statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON .)
    WRITE           reduce using rule 72 (statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON .)
    FOR             reduce using rule 72 (statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON .)
    INT_TYPE        reduce using rule 72 (statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON .)
    FLOAT_TYPE      reduce using rule 72 (statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON .)
    BOOL_TYPE       reduce using rule 72 (statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON .)
    CHAR_TYPE       reduce using rule 72 (statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON .)
    IF              reduce using rule 72 (statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON .)
    RBRACE          reduce using rule 72 (statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON .)


state 212

    (78) statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN . block
    (83) block -> . LBRACE statements RBRACE

    LBRACE          shift and go to state 121

    block                          shift and go to state 213

state 213

    (78) statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .

    ID              reduce using rule 78 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    READ            reduce using rule 78 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    WRITE           reduce using rule 78 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    FOR             reduce using rule 78 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    INT_TYPE        reduce using rule 78 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    FLOAT_TYPE      reduce using rule 78 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    BOOL_TYPE       reduce using rule 78 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    CHAR_TYPE       reduce using rule 78 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    IF              reduce using rule 78 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    RBRACE          reduce using rule 78 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for SEMICOLON in state 126 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 145 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 146 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 175 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 175 resolved as shift
WARNING: reduce/reduce conflict in state 11 resolved using rule (declarations -> declaration)
WARNING: rejected rule (empty -> <empty>) in state 11
WARNING: reduce/reduce conflict in state 28 resolved using rule (declaration -> ID)
WARNING: rejected rule (declarationTab -> ID) in state 28
WARNING: reduce/reduce conflict in state 34 resolved using rule (empty -> <empty>)
WARNING: rejected rule (statements -> statement) in state 34
WARNING: reduce/reduce conflict in state 81 resolved using rule (expressionTab -> ID)
WARNING: rejected rule (factor -> ID) in state 81
WARNING: reduce/reduce conflict in state 83 resolved using rule (factor -> FLOAT)
WARNING: rejected rule (expressionTab -> FLOAT) in state 83
WARNING: reduce/reduce conflict in state 84 resolved using rule (factor -> INTEGER)
WARNING: rejected rule (expressionTab -> INTEGER) in state 84
WARNING: reduce/reduce conflict in state 85 resolved using rule (factor -> CHAR)
WARNING: rejected rule (expressionTab -> CHAR) in state 85
WARNING: reduce/reduce conflict in state 99 resolved using rule (expressionTab -> ID)
WARNING: rejected rule (factor -> ID) in state 99
WARNING: reduce/reduce conflict in state 99 resolved using rule (expressionTab -> ID)
WARNING: rejected rule (factor_arithmetique -> ID) in state 99
WARNING: reduce/reduce conflict in state 104 resolved using rule (factor -> FLOAT)
WARNING: rejected rule (expressionTab -> FLOAT) in state 104
WARNING: reduce/reduce conflict in state 104 resolved using rule (factor -> FLOAT)
WARNING: rejected rule (factor_arithmetique -> FLOAT) in state 104
WARNING: reduce/reduce conflict in state 105 resolved using rule (factor -> INTEGER)
WARNING: rejected rule (expressionTab -> INTEGER) in state 105
WARNING: reduce/reduce conflict in state 105 resolved using rule (factor -> INTEGER)
WARNING: rejected rule (factor_arithmetique -> INTEGER) in state 105
WARNING: reduce/reduce conflict in state 190 resolved using rule (factor -> ID)
WARNING: rejected rule (condition -> ID EQ ID) in state 190
WARNING: reduce/reduce conflict in state 192 resolved using rule (factor -> ID)
WARNING: rejected rule (condition -> ID NEQ ID) in state 192
WARNING: reduce/reduce conflict in state 194 resolved using rule (factor -> ID)
WARNING: rejected rule (condition -> ID LT ID) in state 194
WARNING: reduce/reduce conflict in state 196 resolved using rule (factor -> ID)
WARNING: rejected rule (condition -> ID LTE ID) in state 196
WARNING: reduce/reduce conflict in state 198 resolved using rule (factor -> ID)
WARNING: rejected rule (condition -> ID GT ID) in state 198
WARNING: reduce/reduce conflict in state 200 resolved using rule (factor -> ID)
WARNING: rejected rule (condition -> ID GTE ID) in state 200
WARNING: Rule (statements -> statement) is never reduced
WARNING: Rule (condition -> ID EQ ID) is never reduced
WARNING: Rule (condition -> ID NEQ ID) is never reduced
WARNING: Rule (condition -> ID LT ID) is never reduced
WARNING: Rule (condition -> ID LTE ID) is never reduced
WARNING: Rule (condition -> ID GT ID) is never reduced
WARNING: Rule (condition -> ID GTE ID) is never reduced
