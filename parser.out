Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COLON
    COMMENT
    DECLARATION
    DIVIDE
    ELSE
    EQ
    FOR
    GT
    GTE
    IF
    INSTRUCTION
    LT
    LTE
    MULTIPLY
    NEQ
    NUMBER
    VAR_GLOBAL

Grammar

Rule 0     S' -> statement
Rule 1     statement -> type declaration_list SEMICOLON
Rule 2     statement -> CONST type ID EQUALS expression SEMICOLON
Rule 3     declaration_list -> declaration
Rule 4     declaration_list -> declaration COMMA declaration_list
Rule 5     declaration -> ID
Rule 6     declaration -> ID EQUALS expression
Rule 7     statement -> ID EQUALS expression SEMICOLON
Rule 8     type -> INT_TYPE
Rule 9     type -> FLOAT_TYPE
Rule 10    type -> BOOL_TYPE
Rule 11    type -> CHAR_TYPE
Rule 12    factor -> INTEGER
Rule 13    factor -> FLOAT
Rule 14    factor -> CHAR
Rule 15    factor -> BOOL
Rule 16    factor -> MINUS factor
Rule 17    factor -> PLUS factor
Rule 18    factor -> LPAREN INTEGER RPAREN
Rule 19    factor -> LPAREN FLOAT RPAREN
Rule 20    factor -> LPAREN MINUS FLOAT RPAREN
Rule 21    statements -> statement
Rule 22    statements -> statement statements
Rule 23    statement -> array_declarationTab
Rule 24    statement -> array_assignment
Rule 25    statement -> type declarationTab_listTab SEMICOLON
Rule 26    statement -> const_declarationTab
Rule 27    const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON
Rule 28    array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON
Rule 29    declarationTab_listTab -> declarationTab
Rule 30    declarationTab_listTab -> declarationTab COMMA declarationTab_listTab
Rule 31    declarationTab -> ID
Rule 32    declarationTab -> ID EQUALS expressionTab
Rule 33    declarationTab -> ID LBRACKET INTEGER RBRACKET
Rule 34    expressionTab -> ID
Rule 35    expressionTab -> FLOAT
Rule 36    expressionTab -> INTEGER
Rule 37    expressionTab -> CHAR
Rule 38    factor -> ID LBRACKET expression RBRACKET
Rule 39    array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON
Rule 40    expression -> expression OR term
Rule 41    expression -> term
Rule 42    term -> term AND factor
Rule 43    term -> factor
Rule 44    factor -> ID
Rule 45    factor -> TRUE
Rule 46    factor -> FALSE
Rule 47    factor -> NOT ID
Rule 48    statement -> READ LPAREN ID RPAREN SEMICOLON
Rule 49    statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON
Rule 50    statement -> WRITE LPAREN write_content RPAREN SEMICOLON
Rule 51    write_content -> write_item
Rule 52    write_content -> write_content COMMA write_item
Rule 53    write_item -> ID
Rule 54    write_item -> ID LBRACKET INTEGER RBRACKET

Terminals, with rules where they appear

AND                  : 42
BOOL                 : 15
BOOL_TYPE            : 10
CHAR                 : 14 37
CHAR_TYPE            : 11
COLON                : 
COMMA                : 4 30 52
COMMENT              : 
CONST                : 2 27
DECLARATION          : 
DIVIDE               : 
ELSE                 : 
EQ                   : 
EQUALS               : 2 6 7 27 32 39
FALSE                : 46
FLOAT                : 13 19 20 35
FLOAT_TYPE           : 9
FOR                  : 
GT                   : 
GTE                  : 
ID                   : 2 5 6 7 27 28 31 32 33 34 38 39 44 47 48 49 53 54
IF                   : 
INSTRUCTION          : 
INTEGER              : 12 18 28 33 36 49 54
INT_TYPE             : 8
LBRACKET             : 28 33 38 39 49 54
LPAREN               : 18 19 20 48 49 50
LT                   : 
LTE                  : 
MINUS                : 16 20
MULTIPLY             : 
NEQ                  : 
NOT                  : 47
NUMBER               : 
OR                   : 40
PLUS                 : 17
RBRACKET             : 28 33 38 39 49 54
READ                 : 48 49
RPAREN               : 18 19 20 48 49 50
SEMICOLON            : 1 2 7 25 27 28 39 48 49 50
TRUE                 : 45
VAR_GLOBAL           : 
WRITE                : 50
error                : 

Nonterminals, with rules where they appear

array_assignment     : 24
array_declarationTab : 23
const_declarationTab : 26
declaration          : 3 4
declarationTab       : 29 30
declarationTab_listTab : 25 30
declaration_list     : 1 4
expression           : 2 6 7 38 40
expressionTab        : 27 32 39 39
factor               : 16 17 42 43
statement            : 21 22 0
statements           : 22
term                 : 40 41 42
type                 : 1 2 25 27 28
write_content        : 50 52
write_item           : 51 52

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . type declaration_list SEMICOLON
    (2) statement -> . CONST type ID EQUALS expression SEMICOLON
    (7) statement -> . ID EQUALS expression SEMICOLON
    (23) statement -> . array_declarationTab
    (24) statement -> . array_assignment
    (25) statement -> . type declarationTab_listTab SEMICOLON
    (26) statement -> . const_declarationTab
    (48) statement -> . READ LPAREN ID RPAREN SEMICOLON
    (49) statement -> . READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON
    (50) statement -> . WRITE LPAREN write_content RPAREN SEMICOLON
    (8) type -> . INT_TYPE
    (9) type -> . FLOAT_TYPE
    (10) type -> . BOOL_TYPE
    (11) type -> . CHAR_TYPE
    (28) array_declarationTab -> . type ID LBRACKET INTEGER RBRACKET SEMICOLON
    (39) array_assignment -> . ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON
    (27) const_declarationTab -> . CONST type ID EQUALS expressionTab SEMICOLON

    CONST           shift and go to state 3
    ID              shift and go to state 4
    READ            shift and go to state 8
    WRITE           shift and go to state 9
    INT_TYPE        shift and go to state 10
    FLOAT_TYPE      shift and go to state 11
    BOOL_TYPE       shift and go to state 12
    CHAR_TYPE       shift and go to state 13

    statement                      shift and go to state 1
    type                           shift and go to state 2
    array_declarationTab           shift and go to state 5
    array_assignment               shift and go to state 6
    const_declarationTab           shift and go to state 7

state 1

    (0) S' -> statement .



state 2

    (1) statement -> type . declaration_list SEMICOLON
    (25) statement -> type . declarationTab_listTab SEMICOLON
    (28) array_declarationTab -> type . ID LBRACKET INTEGER RBRACKET SEMICOLON
    (3) declaration_list -> . declaration
    (4) declaration_list -> . declaration COMMA declaration_list
    (29) declarationTab_listTab -> . declarationTab
    (30) declarationTab_listTab -> . declarationTab COMMA declarationTab_listTab
    (5) declaration -> . ID
    (6) declaration -> . ID EQUALS expression
    (31) declarationTab -> . ID
    (32) declarationTab -> . ID EQUALS expressionTab
    (33) declarationTab -> . ID LBRACKET INTEGER RBRACKET

    ID              shift and go to state 16

    declaration_list               shift and go to state 14
    declarationTab_listTab         shift and go to state 15
    declaration                    shift and go to state 17
    declarationTab                 shift and go to state 18

state 3

    (2) statement -> CONST . type ID EQUALS expression SEMICOLON
    (27) const_declarationTab -> CONST . type ID EQUALS expressionTab SEMICOLON
    (8) type -> . INT_TYPE
    (9) type -> . FLOAT_TYPE
    (10) type -> . BOOL_TYPE
    (11) type -> . CHAR_TYPE

    INT_TYPE        shift and go to state 10
    FLOAT_TYPE      shift and go to state 11
    BOOL_TYPE       shift and go to state 12
    CHAR_TYPE       shift and go to state 13

    type                           shift and go to state 19

state 4

    (7) statement -> ID . EQUALS expression SEMICOLON
    (39) array_assignment -> ID . LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON

    EQUALS          shift and go to state 20
    LBRACKET        shift and go to state 21


state 5

    (23) statement -> array_declarationTab .

    $end            reduce using rule 23 (statement -> array_declarationTab .)


state 6

    (24) statement -> array_assignment .

    $end            reduce using rule 24 (statement -> array_assignment .)


state 7

    (26) statement -> const_declarationTab .

    $end            reduce using rule 26 (statement -> const_declarationTab .)


state 8

    (48) statement -> READ . LPAREN ID RPAREN SEMICOLON
    (49) statement -> READ . LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON

    LPAREN          shift and go to state 22


state 9

    (50) statement -> WRITE . LPAREN write_content RPAREN SEMICOLON

    LPAREN          shift and go to state 23


state 10

    (8) type -> INT_TYPE .

    ID              reduce using rule 8 (type -> INT_TYPE .)


state 11

    (9) type -> FLOAT_TYPE .

    ID              reduce using rule 9 (type -> FLOAT_TYPE .)


state 12

    (10) type -> BOOL_TYPE .

    ID              reduce using rule 10 (type -> BOOL_TYPE .)


state 13

    (11) type -> CHAR_TYPE .

    ID              reduce using rule 11 (type -> CHAR_TYPE .)


state 14

    (1) statement -> type declaration_list . SEMICOLON

    SEMICOLON       shift and go to state 24


state 15

    (25) statement -> type declarationTab_listTab . SEMICOLON

    SEMICOLON       shift and go to state 25


state 16

    (28) array_declarationTab -> type ID . LBRACKET INTEGER RBRACKET SEMICOLON
    (5) declaration -> ID .
    (6) declaration -> ID . EQUALS expression
    (31) declarationTab -> ID .
    (32) declarationTab -> ID . EQUALS expressionTab
    (33) declarationTab -> ID . LBRACKET INTEGER RBRACKET

  ! reduce/reduce conflict for COMMA resolved using rule 5 (declaration -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 5 (declaration -> ID .)
    LBRACKET        shift and go to state 26
    COMMA           reduce using rule 5 (declaration -> ID .)
    SEMICOLON       reduce using rule 5 (declaration -> ID .)
    EQUALS          shift and go to state 27

  ! COMMA           [ reduce using rule 31 (declarationTab -> ID .) ]
  ! SEMICOLON       [ reduce using rule 31 (declarationTab -> ID .) ]


state 17

    (3) declaration_list -> declaration .
    (4) declaration_list -> declaration . COMMA declaration_list

    SEMICOLON       reduce using rule 3 (declaration_list -> declaration .)
    COMMA           shift and go to state 28


state 18

    (29) declarationTab_listTab -> declarationTab .
    (30) declarationTab_listTab -> declarationTab . COMMA declarationTab_listTab

    SEMICOLON       reduce using rule 29 (declarationTab_listTab -> declarationTab .)
    COMMA           shift and go to state 29


state 19

    (2) statement -> CONST type . ID EQUALS expression SEMICOLON
    (27) const_declarationTab -> CONST type . ID EQUALS expressionTab SEMICOLON

    ID              shift and go to state 30


state 20

    (7) statement -> ID EQUALS . expression SEMICOLON
    (40) expression -> . expression OR term
    (41) expression -> . term
    (42) term -> . term AND factor
    (43) term -> . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (38) factor -> . ID LBRACKET expression RBRACKET
    (44) factor -> . ID
    (45) factor -> . TRUE
    (46) factor -> . FALSE
    (47) factor -> . NOT ID

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    CHAR            shift and go to state 37
    BOOL            shift and go to state 38
    MINUS           shift and go to state 39
    PLUS            shift and go to state 40
    LPAREN          shift and go to state 41
    ID              shift and go to state 31
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    NOT             shift and go to state 44

    expression                     shift and go to state 32
    term                           shift and go to state 33
    factor                         shift and go to state 34

state 21

    (39) array_assignment -> ID LBRACKET . expressionTab RBRACKET EQUALS expressionTab SEMICOLON
    (34) expressionTab -> . ID
    (35) expressionTab -> . FLOAT
    (36) expressionTab -> . INTEGER
    (37) expressionTab -> . CHAR

    ID              shift and go to state 45
    FLOAT           shift and go to state 47
    INTEGER         shift and go to state 48
    CHAR            shift and go to state 49

    expressionTab                  shift and go to state 46

state 22

    (48) statement -> READ LPAREN . ID RPAREN SEMICOLON
    (49) statement -> READ LPAREN . ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON

    ID              shift and go to state 50


state 23

    (50) statement -> WRITE LPAREN . write_content RPAREN SEMICOLON
    (51) write_content -> . write_item
    (52) write_content -> . write_content COMMA write_item
    (53) write_item -> . ID
    (54) write_item -> . ID LBRACKET INTEGER RBRACKET

    ID              shift and go to state 53

    write_content                  shift and go to state 51
    write_item                     shift and go to state 52

state 24

    (1) statement -> type declaration_list SEMICOLON .

    $end            reduce using rule 1 (statement -> type declaration_list SEMICOLON .)


state 25

    (25) statement -> type declarationTab_listTab SEMICOLON .

    $end            reduce using rule 25 (statement -> type declarationTab_listTab SEMICOLON .)


state 26

    (28) array_declarationTab -> type ID LBRACKET . INTEGER RBRACKET SEMICOLON
    (33) declarationTab -> ID LBRACKET . INTEGER RBRACKET

    INTEGER         shift and go to state 54


state 27

    (6) declaration -> ID EQUALS . expression
    (32) declarationTab -> ID EQUALS . expressionTab
    (40) expression -> . expression OR term
    (41) expression -> . term
    (34) expressionTab -> . ID
    (35) expressionTab -> . FLOAT
    (36) expressionTab -> . INTEGER
    (37) expressionTab -> . CHAR
    (42) term -> . term AND factor
    (43) term -> . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (38) factor -> . ID LBRACKET expression RBRACKET
    (44) factor -> . ID
    (45) factor -> . TRUE
    (46) factor -> . FALSE
    (47) factor -> . NOT ID

    ID              shift and go to state 55
    FLOAT           shift and go to state 58
    INTEGER         shift and go to state 59
    CHAR            shift and go to state 60
    BOOL            shift and go to state 38
    MINUS           shift and go to state 39
    PLUS            shift and go to state 40
    LPAREN          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    NOT             shift and go to state 44

    expression                     shift and go to state 56
    expressionTab                  shift and go to state 57
    term                           shift and go to state 33
    factor                         shift and go to state 34

state 28

    (4) declaration_list -> declaration COMMA . declaration_list
    (3) declaration_list -> . declaration
    (4) declaration_list -> . declaration COMMA declaration_list
    (5) declaration -> . ID
    (6) declaration -> . ID EQUALS expression

    ID              shift and go to state 62

    declaration                    shift and go to state 17
    declaration_list               shift and go to state 61

state 29

    (30) declarationTab_listTab -> declarationTab COMMA . declarationTab_listTab
    (29) declarationTab_listTab -> . declarationTab
    (30) declarationTab_listTab -> . declarationTab COMMA declarationTab_listTab
    (31) declarationTab -> . ID
    (32) declarationTab -> . ID EQUALS expressionTab
    (33) declarationTab -> . ID LBRACKET INTEGER RBRACKET

    ID              shift and go to state 64

    declarationTab                 shift and go to state 18
    declarationTab_listTab         shift and go to state 63

state 30

    (2) statement -> CONST type ID . EQUALS expression SEMICOLON
    (27) const_declarationTab -> CONST type ID . EQUALS expressionTab SEMICOLON

    EQUALS          shift and go to state 65


state 31

    (38) factor -> ID . LBRACKET expression RBRACKET
    (44) factor -> ID .

    LBRACKET        shift and go to state 66
    AND             reduce using rule 44 (factor -> ID .)
    SEMICOLON       reduce using rule 44 (factor -> ID .)
    OR              reduce using rule 44 (factor -> ID .)
    COMMA           reduce using rule 44 (factor -> ID .)
    RBRACKET        reduce using rule 44 (factor -> ID .)


state 32

    (7) statement -> ID EQUALS expression . SEMICOLON
    (40) expression -> expression . OR term

    SEMICOLON       shift and go to state 67
    OR              shift and go to state 68


state 33

    (41) expression -> term .
    (42) term -> term . AND factor

    SEMICOLON       reduce using rule 41 (expression -> term .)
    OR              reduce using rule 41 (expression -> term .)
    COMMA           reduce using rule 41 (expression -> term .)
    RBRACKET        reduce using rule 41 (expression -> term .)
    AND             shift and go to state 69


state 34

    (43) term -> factor .

    AND             reduce using rule 43 (term -> factor .)
    SEMICOLON       reduce using rule 43 (term -> factor .)
    OR              reduce using rule 43 (term -> factor .)
    COMMA           reduce using rule 43 (term -> factor .)
    RBRACKET        reduce using rule 43 (term -> factor .)


state 35

    (12) factor -> INTEGER .

    AND             reduce using rule 12 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 12 (factor -> INTEGER .)
    OR              reduce using rule 12 (factor -> INTEGER .)
    COMMA           reduce using rule 12 (factor -> INTEGER .)
    RBRACKET        reduce using rule 12 (factor -> INTEGER .)


state 36

    (13) factor -> FLOAT .

    AND             reduce using rule 13 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 13 (factor -> FLOAT .)
    OR              reduce using rule 13 (factor -> FLOAT .)
    COMMA           reduce using rule 13 (factor -> FLOAT .)
    RBRACKET        reduce using rule 13 (factor -> FLOAT .)


state 37

    (14) factor -> CHAR .

    AND             reduce using rule 14 (factor -> CHAR .)
    SEMICOLON       reduce using rule 14 (factor -> CHAR .)
    OR              reduce using rule 14 (factor -> CHAR .)
    COMMA           reduce using rule 14 (factor -> CHAR .)
    RBRACKET        reduce using rule 14 (factor -> CHAR .)


state 38

    (15) factor -> BOOL .

    AND             reduce using rule 15 (factor -> BOOL .)
    SEMICOLON       reduce using rule 15 (factor -> BOOL .)
    OR              reduce using rule 15 (factor -> BOOL .)
    COMMA           reduce using rule 15 (factor -> BOOL .)
    RBRACKET        reduce using rule 15 (factor -> BOOL .)


state 39

    (16) factor -> MINUS . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (38) factor -> . ID LBRACKET expression RBRACKET
    (44) factor -> . ID
    (45) factor -> . TRUE
    (46) factor -> . FALSE
    (47) factor -> . NOT ID

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    CHAR            shift and go to state 37
    BOOL            shift and go to state 38
    MINUS           shift and go to state 39
    PLUS            shift and go to state 40
    LPAREN          shift and go to state 41
    ID              shift and go to state 31
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    NOT             shift and go to state 44

    factor                         shift and go to state 70

state 40

    (17) factor -> PLUS . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (38) factor -> . ID LBRACKET expression RBRACKET
    (44) factor -> . ID
    (45) factor -> . TRUE
    (46) factor -> . FALSE
    (47) factor -> . NOT ID

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    CHAR            shift and go to state 37
    BOOL            shift and go to state 38
    MINUS           shift and go to state 39
    PLUS            shift and go to state 40
    LPAREN          shift and go to state 41
    ID              shift and go to state 31
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    NOT             shift and go to state 44

    factor                         shift and go to state 71

state 41

    (18) factor -> LPAREN . INTEGER RPAREN
    (19) factor -> LPAREN . FLOAT RPAREN
    (20) factor -> LPAREN . MINUS FLOAT RPAREN

    INTEGER         shift and go to state 72
    FLOAT           shift and go to state 73
    MINUS           shift and go to state 74


state 42

    (45) factor -> TRUE .

    AND             reduce using rule 45 (factor -> TRUE .)
    SEMICOLON       reduce using rule 45 (factor -> TRUE .)
    OR              reduce using rule 45 (factor -> TRUE .)
    COMMA           reduce using rule 45 (factor -> TRUE .)
    RBRACKET        reduce using rule 45 (factor -> TRUE .)


state 43

    (46) factor -> FALSE .

    AND             reduce using rule 46 (factor -> FALSE .)
    SEMICOLON       reduce using rule 46 (factor -> FALSE .)
    OR              reduce using rule 46 (factor -> FALSE .)
    COMMA           reduce using rule 46 (factor -> FALSE .)
    RBRACKET        reduce using rule 46 (factor -> FALSE .)


state 44

    (47) factor -> NOT . ID

    ID              shift and go to state 75


state 45

    (34) expressionTab -> ID .

    RBRACKET        reduce using rule 34 (expressionTab -> ID .)
    COMMA           reduce using rule 34 (expressionTab -> ID .)
    SEMICOLON       reduce using rule 34 (expressionTab -> ID .)


state 46

    (39) array_assignment -> ID LBRACKET expressionTab . RBRACKET EQUALS expressionTab SEMICOLON

    RBRACKET        shift and go to state 76


state 47

    (35) expressionTab -> FLOAT .

    RBRACKET        reduce using rule 35 (expressionTab -> FLOAT .)
    COMMA           reduce using rule 35 (expressionTab -> FLOAT .)
    SEMICOLON       reduce using rule 35 (expressionTab -> FLOAT .)


state 48

    (36) expressionTab -> INTEGER .

    RBRACKET        reduce using rule 36 (expressionTab -> INTEGER .)
    COMMA           reduce using rule 36 (expressionTab -> INTEGER .)
    SEMICOLON       reduce using rule 36 (expressionTab -> INTEGER .)


state 49

    (37) expressionTab -> CHAR .

    RBRACKET        reduce using rule 37 (expressionTab -> CHAR .)
    COMMA           reduce using rule 37 (expressionTab -> CHAR .)
    SEMICOLON       reduce using rule 37 (expressionTab -> CHAR .)


state 50

    (48) statement -> READ LPAREN ID . RPAREN SEMICOLON
    (49) statement -> READ LPAREN ID . LBRACKET INTEGER RBRACKET RPAREN SEMICOLON

    RPAREN          shift and go to state 77
    LBRACKET        shift and go to state 78


state 51

    (50) statement -> WRITE LPAREN write_content . RPAREN SEMICOLON
    (52) write_content -> write_content . COMMA write_item

    RPAREN          shift and go to state 79
    COMMA           shift and go to state 80


state 52

    (51) write_content -> write_item .

    RPAREN          reduce using rule 51 (write_content -> write_item .)
    COMMA           reduce using rule 51 (write_content -> write_item .)


state 53

    (53) write_item -> ID .
    (54) write_item -> ID . LBRACKET INTEGER RBRACKET

    RPAREN          reduce using rule 53 (write_item -> ID .)
    COMMA           reduce using rule 53 (write_item -> ID .)
    LBRACKET        shift and go to state 81


state 54

    (28) array_declarationTab -> type ID LBRACKET INTEGER . RBRACKET SEMICOLON
    (33) declarationTab -> ID LBRACKET INTEGER . RBRACKET

    RBRACKET        shift and go to state 82


state 55

    (34) expressionTab -> ID .
    (38) factor -> ID . LBRACKET expression RBRACKET
    (44) factor -> ID .

  ! reduce/reduce conflict for COMMA resolved using rule 34 (expressionTab -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 34 (expressionTab -> ID .)
    COMMA           reduce using rule 34 (expressionTab -> ID .)
    SEMICOLON       reduce using rule 34 (expressionTab -> ID .)
    LBRACKET        shift and go to state 66
    AND             reduce using rule 44 (factor -> ID .)
    OR              reduce using rule 44 (factor -> ID .)

  ! COMMA           [ reduce using rule 44 (factor -> ID .) ]
  ! SEMICOLON       [ reduce using rule 44 (factor -> ID .) ]


state 56

    (6) declaration -> ID EQUALS expression .
    (40) expression -> expression . OR term

    COMMA           reduce using rule 6 (declaration -> ID EQUALS expression .)
    SEMICOLON       reduce using rule 6 (declaration -> ID EQUALS expression .)
    OR              shift and go to state 68


state 57

    (32) declarationTab -> ID EQUALS expressionTab .

    COMMA           reduce using rule 32 (declarationTab -> ID EQUALS expressionTab .)
    SEMICOLON       reduce using rule 32 (declarationTab -> ID EQUALS expressionTab .)


state 58

    (35) expressionTab -> FLOAT .
    (13) factor -> FLOAT .

  ! reduce/reduce conflict for COMMA resolved using rule 13 (factor -> FLOAT .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 13 (factor -> FLOAT .)
    AND             reduce using rule 13 (factor -> FLOAT .)
    OR              reduce using rule 13 (factor -> FLOAT .)
    COMMA           reduce using rule 13 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 13 (factor -> FLOAT .)

  ! COMMA           [ reduce using rule 35 (expressionTab -> FLOAT .) ]
  ! SEMICOLON       [ reduce using rule 35 (expressionTab -> FLOAT .) ]


state 59

    (36) expressionTab -> INTEGER .
    (12) factor -> INTEGER .

  ! reduce/reduce conflict for COMMA resolved using rule 12 (factor -> INTEGER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 12 (factor -> INTEGER .)
    AND             reduce using rule 12 (factor -> INTEGER .)
    OR              reduce using rule 12 (factor -> INTEGER .)
    COMMA           reduce using rule 12 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 12 (factor -> INTEGER .)

  ! COMMA           [ reduce using rule 36 (expressionTab -> INTEGER .) ]
  ! SEMICOLON       [ reduce using rule 36 (expressionTab -> INTEGER .) ]


state 60

    (37) expressionTab -> CHAR .
    (14) factor -> CHAR .

  ! reduce/reduce conflict for COMMA resolved using rule 14 (factor -> CHAR .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 14 (factor -> CHAR .)
    AND             reduce using rule 14 (factor -> CHAR .)
    OR              reduce using rule 14 (factor -> CHAR .)
    COMMA           reduce using rule 14 (factor -> CHAR .)
    SEMICOLON       reduce using rule 14 (factor -> CHAR .)

  ! COMMA           [ reduce using rule 37 (expressionTab -> CHAR .) ]
  ! SEMICOLON       [ reduce using rule 37 (expressionTab -> CHAR .) ]


state 61

    (4) declaration_list -> declaration COMMA declaration_list .

    SEMICOLON       reduce using rule 4 (declaration_list -> declaration COMMA declaration_list .)


state 62

    (5) declaration -> ID .
    (6) declaration -> ID . EQUALS expression

    COMMA           reduce using rule 5 (declaration -> ID .)
    SEMICOLON       reduce using rule 5 (declaration -> ID .)
    EQUALS          shift and go to state 83


state 63

    (30) declarationTab_listTab -> declarationTab COMMA declarationTab_listTab .

    SEMICOLON       reduce using rule 30 (declarationTab_listTab -> declarationTab COMMA declarationTab_listTab .)


state 64

    (31) declarationTab -> ID .
    (32) declarationTab -> ID . EQUALS expressionTab
    (33) declarationTab -> ID . LBRACKET INTEGER RBRACKET

    COMMA           reduce using rule 31 (declarationTab -> ID .)
    SEMICOLON       reduce using rule 31 (declarationTab -> ID .)
    EQUALS          shift and go to state 84
    LBRACKET        shift and go to state 85


state 65

    (2) statement -> CONST type ID EQUALS . expression SEMICOLON
    (27) const_declarationTab -> CONST type ID EQUALS . expressionTab SEMICOLON
    (40) expression -> . expression OR term
    (41) expression -> . term
    (34) expressionTab -> . ID
    (35) expressionTab -> . FLOAT
    (36) expressionTab -> . INTEGER
    (37) expressionTab -> . CHAR
    (42) term -> . term AND factor
    (43) term -> . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (38) factor -> . ID LBRACKET expression RBRACKET
    (44) factor -> . ID
    (45) factor -> . TRUE
    (46) factor -> . FALSE
    (47) factor -> . NOT ID

    ID              shift and go to state 55
    FLOAT           shift and go to state 58
    INTEGER         shift and go to state 59
    CHAR            shift and go to state 60
    BOOL            shift and go to state 38
    MINUS           shift and go to state 39
    PLUS            shift and go to state 40
    LPAREN          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    NOT             shift and go to state 44

    expression                     shift and go to state 86
    expressionTab                  shift and go to state 87
    term                           shift and go to state 33
    factor                         shift and go to state 34

state 66

    (38) factor -> ID LBRACKET . expression RBRACKET
    (40) expression -> . expression OR term
    (41) expression -> . term
    (42) term -> . term AND factor
    (43) term -> . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (38) factor -> . ID LBRACKET expression RBRACKET
    (44) factor -> . ID
    (45) factor -> . TRUE
    (46) factor -> . FALSE
    (47) factor -> . NOT ID

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    CHAR            shift and go to state 37
    BOOL            shift and go to state 38
    MINUS           shift and go to state 39
    PLUS            shift and go to state 40
    LPAREN          shift and go to state 41
    ID              shift and go to state 31
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    NOT             shift and go to state 44

    expression                     shift and go to state 88
    term                           shift and go to state 33
    factor                         shift and go to state 34

state 67

    (7) statement -> ID EQUALS expression SEMICOLON .

    $end            reduce using rule 7 (statement -> ID EQUALS expression SEMICOLON .)


state 68

    (40) expression -> expression OR . term
    (42) term -> . term AND factor
    (43) term -> . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (38) factor -> . ID LBRACKET expression RBRACKET
    (44) factor -> . ID
    (45) factor -> . TRUE
    (46) factor -> . FALSE
    (47) factor -> . NOT ID

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    CHAR            shift and go to state 37
    BOOL            shift and go to state 38
    MINUS           shift and go to state 39
    PLUS            shift and go to state 40
    LPAREN          shift and go to state 41
    ID              shift and go to state 31
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    NOT             shift and go to state 44

    term                           shift and go to state 89
    factor                         shift and go to state 34

state 69

    (42) term -> term AND . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (38) factor -> . ID LBRACKET expression RBRACKET
    (44) factor -> . ID
    (45) factor -> . TRUE
    (46) factor -> . FALSE
    (47) factor -> . NOT ID

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    CHAR            shift and go to state 37
    BOOL            shift and go to state 38
    MINUS           shift and go to state 39
    PLUS            shift and go to state 40
    LPAREN          shift and go to state 41
    ID              shift and go to state 31
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    NOT             shift and go to state 44

    factor                         shift and go to state 90

state 70

    (16) factor -> MINUS factor .

    AND             reduce using rule 16 (factor -> MINUS factor .)
    SEMICOLON       reduce using rule 16 (factor -> MINUS factor .)
    OR              reduce using rule 16 (factor -> MINUS factor .)
    COMMA           reduce using rule 16 (factor -> MINUS factor .)
    RBRACKET        reduce using rule 16 (factor -> MINUS factor .)


state 71

    (17) factor -> PLUS factor .

    AND             reduce using rule 17 (factor -> PLUS factor .)
    SEMICOLON       reduce using rule 17 (factor -> PLUS factor .)
    OR              reduce using rule 17 (factor -> PLUS factor .)
    COMMA           reduce using rule 17 (factor -> PLUS factor .)
    RBRACKET        reduce using rule 17 (factor -> PLUS factor .)


state 72

    (18) factor -> LPAREN INTEGER . RPAREN

    RPAREN          shift and go to state 91


state 73

    (19) factor -> LPAREN FLOAT . RPAREN

    RPAREN          shift and go to state 92


state 74

    (20) factor -> LPAREN MINUS . FLOAT RPAREN

    FLOAT           shift and go to state 93


state 75

    (47) factor -> NOT ID .

    AND             reduce using rule 47 (factor -> NOT ID .)
    SEMICOLON       reduce using rule 47 (factor -> NOT ID .)
    OR              reduce using rule 47 (factor -> NOT ID .)
    COMMA           reduce using rule 47 (factor -> NOT ID .)
    RBRACKET        reduce using rule 47 (factor -> NOT ID .)


state 76

    (39) array_assignment -> ID LBRACKET expressionTab RBRACKET . EQUALS expressionTab SEMICOLON

    EQUALS          shift and go to state 94


state 77

    (48) statement -> READ LPAREN ID RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 95


state 78

    (49) statement -> READ LPAREN ID LBRACKET . INTEGER RBRACKET RPAREN SEMICOLON

    INTEGER         shift and go to state 96


state 79

    (50) statement -> WRITE LPAREN write_content RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 97


state 80

    (52) write_content -> write_content COMMA . write_item
    (53) write_item -> . ID
    (54) write_item -> . ID LBRACKET INTEGER RBRACKET

    ID              shift and go to state 53

    write_item                     shift and go to state 98

state 81

    (54) write_item -> ID LBRACKET . INTEGER RBRACKET

    INTEGER         shift and go to state 99


state 82

    (28) array_declarationTab -> type ID LBRACKET INTEGER RBRACKET . SEMICOLON
    (33) declarationTab -> ID LBRACKET INTEGER RBRACKET .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 100
    COMMA           reduce using rule 33 (declarationTab -> ID LBRACKET INTEGER RBRACKET .)

  ! SEMICOLON       [ reduce using rule 33 (declarationTab -> ID LBRACKET INTEGER RBRACKET .) ]


state 83

    (6) declaration -> ID EQUALS . expression
    (40) expression -> . expression OR term
    (41) expression -> . term
    (42) term -> . term AND factor
    (43) term -> . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (38) factor -> . ID LBRACKET expression RBRACKET
    (44) factor -> . ID
    (45) factor -> . TRUE
    (46) factor -> . FALSE
    (47) factor -> . NOT ID

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    CHAR            shift and go to state 37
    BOOL            shift and go to state 38
    MINUS           shift and go to state 39
    PLUS            shift and go to state 40
    LPAREN          shift and go to state 41
    ID              shift and go to state 31
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    NOT             shift and go to state 44

    expression                     shift and go to state 56
    term                           shift and go to state 33
    factor                         shift and go to state 34

state 84

    (32) declarationTab -> ID EQUALS . expressionTab
    (34) expressionTab -> . ID
    (35) expressionTab -> . FLOAT
    (36) expressionTab -> . INTEGER
    (37) expressionTab -> . CHAR

    ID              shift and go to state 45
    FLOAT           shift and go to state 47
    INTEGER         shift and go to state 48
    CHAR            shift and go to state 49

    expressionTab                  shift and go to state 57

state 85

    (33) declarationTab -> ID LBRACKET . INTEGER RBRACKET

    INTEGER         shift and go to state 101


state 86

    (2) statement -> CONST type ID EQUALS expression . SEMICOLON
    (40) expression -> expression . OR term

    SEMICOLON       shift and go to state 102
    OR              shift and go to state 68


state 87

    (27) const_declarationTab -> CONST type ID EQUALS expressionTab . SEMICOLON

    SEMICOLON       shift and go to state 103


state 88

    (38) factor -> ID LBRACKET expression . RBRACKET
    (40) expression -> expression . OR term

    RBRACKET        shift and go to state 104
    OR              shift and go to state 68


state 89

    (40) expression -> expression OR term .
    (42) term -> term . AND factor

    SEMICOLON       reduce using rule 40 (expression -> expression OR term .)
    OR              reduce using rule 40 (expression -> expression OR term .)
    COMMA           reduce using rule 40 (expression -> expression OR term .)
    RBRACKET        reduce using rule 40 (expression -> expression OR term .)
    AND             shift and go to state 69


state 90

    (42) term -> term AND factor .

    AND             reduce using rule 42 (term -> term AND factor .)
    SEMICOLON       reduce using rule 42 (term -> term AND factor .)
    OR              reduce using rule 42 (term -> term AND factor .)
    COMMA           reduce using rule 42 (term -> term AND factor .)
    RBRACKET        reduce using rule 42 (term -> term AND factor .)


state 91

    (18) factor -> LPAREN INTEGER RPAREN .

    AND             reduce using rule 18 (factor -> LPAREN INTEGER RPAREN .)
    SEMICOLON       reduce using rule 18 (factor -> LPAREN INTEGER RPAREN .)
    OR              reduce using rule 18 (factor -> LPAREN INTEGER RPAREN .)
    COMMA           reduce using rule 18 (factor -> LPAREN INTEGER RPAREN .)
    RBRACKET        reduce using rule 18 (factor -> LPAREN INTEGER RPAREN .)


state 92

    (19) factor -> LPAREN FLOAT RPAREN .

    AND             reduce using rule 19 (factor -> LPAREN FLOAT RPAREN .)
    SEMICOLON       reduce using rule 19 (factor -> LPAREN FLOAT RPAREN .)
    OR              reduce using rule 19 (factor -> LPAREN FLOAT RPAREN .)
    COMMA           reduce using rule 19 (factor -> LPAREN FLOAT RPAREN .)
    RBRACKET        reduce using rule 19 (factor -> LPAREN FLOAT RPAREN .)


state 93

    (20) factor -> LPAREN MINUS FLOAT . RPAREN

    RPAREN          shift and go to state 105


state 94

    (39) array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS . expressionTab SEMICOLON
    (34) expressionTab -> . ID
    (35) expressionTab -> . FLOAT
    (36) expressionTab -> . INTEGER
    (37) expressionTab -> . CHAR

    ID              shift and go to state 45
    FLOAT           shift and go to state 47
    INTEGER         shift and go to state 48
    CHAR            shift and go to state 49

    expressionTab                  shift and go to state 106

state 95

    (48) statement -> READ LPAREN ID RPAREN SEMICOLON .

    $end            reduce using rule 48 (statement -> READ LPAREN ID RPAREN SEMICOLON .)


state 96

    (49) statement -> READ LPAREN ID LBRACKET INTEGER . RBRACKET RPAREN SEMICOLON

    RBRACKET        shift and go to state 107


state 97

    (50) statement -> WRITE LPAREN write_content RPAREN SEMICOLON .

    $end            reduce using rule 50 (statement -> WRITE LPAREN write_content RPAREN SEMICOLON .)


state 98

    (52) write_content -> write_content COMMA write_item .

    RPAREN          reduce using rule 52 (write_content -> write_content COMMA write_item .)
    COMMA           reduce using rule 52 (write_content -> write_content COMMA write_item .)


state 99

    (54) write_item -> ID LBRACKET INTEGER . RBRACKET

    RBRACKET        shift and go to state 108


state 100

    (28) array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .

    $end            reduce using rule 28 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)


state 101

    (33) declarationTab -> ID LBRACKET INTEGER . RBRACKET

    RBRACKET        shift and go to state 109


state 102

    (2) statement -> CONST type ID EQUALS expression SEMICOLON .

    $end            reduce using rule 2 (statement -> CONST type ID EQUALS expression SEMICOLON .)


state 103

    (27) const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .

    $end            reduce using rule 27 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)


state 104

    (38) factor -> ID LBRACKET expression RBRACKET .

    AND             reduce using rule 38 (factor -> ID LBRACKET expression RBRACKET .)
    SEMICOLON       reduce using rule 38 (factor -> ID LBRACKET expression RBRACKET .)
    OR              reduce using rule 38 (factor -> ID LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 38 (factor -> ID LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 38 (factor -> ID LBRACKET expression RBRACKET .)


state 105

    (20) factor -> LPAREN MINUS FLOAT RPAREN .

    AND             reduce using rule 20 (factor -> LPAREN MINUS FLOAT RPAREN .)
    SEMICOLON       reduce using rule 20 (factor -> LPAREN MINUS FLOAT RPAREN .)
    OR              reduce using rule 20 (factor -> LPAREN MINUS FLOAT RPAREN .)
    COMMA           reduce using rule 20 (factor -> LPAREN MINUS FLOAT RPAREN .)
    RBRACKET        reduce using rule 20 (factor -> LPAREN MINUS FLOAT RPAREN .)


state 106

    (39) array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab . SEMICOLON

    SEMICOLON       shift and go to state 110


state 107

    (49) statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET . RPAREN SEMICOLON

    RPAREN          shift and go to state 111


state 108

    (54) write_item -> ID LBRACKET INTEGER RBRACKET .

    RPAREN          reduce using rule 54 (write_item -> ID LBRACKET INTEGER RBRACKET .)
    COMMA           reduce using rule 54 (write_item -> ID LBRACKET INTEGER RBRACKET .)


state 109

    (33) declarationTab -> ID LBRACKET INTEGER RBRACKET .

    COMMA           reduce using rule 33 (declarationTab -> ID LBRACKET INTEGER RBRACKET .)
    SEMICOLON       reduce using rule 33 (declarationTab -> ID LBRACKET INTEGER RBRACKET .)


state 110

    (39) array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .

    $end            reduce using rule 39 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)


state 111

    (49) statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 112


state 112

    (49) statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON .

    $end            reduce using rule 49 (statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for SEMICOLON in state 82 resolved as shift
WARNING: reduce/reduce conflict in state 16 resolved using rule (declaration -> ID)
WARNING: rejected rule (declarationTab -> ID) in state 16
WARNING: reduce/reduce conflict in state 55 resolved using rule (expressionTab -> ID)
WARNING: rejected rule (factor -> ID) in state 55
WARNING: reduce/reduce conflict in state 58 resolved using rule (factor -> FLOAT)
WARNING: rejected rule (expressionTab -> FLOAT) in state 58
WARNING: reduce/reduce conflict in state 59 resolved using rule (factor -> INTEGER)
WARNING: rejected rule (expressionTab -> INTEGER) in state 59
WARNING: reduce/reduce conflict in state 60 resolved using rule (factor -> CHAR)
WARNING: rejected rule (expressionTab -> CHAR) in state 60
