Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    ELSE
    EQ
    GT
    GTE
    IF
    LT
    LTE
    NEQ
    NUMBER

Grammar

Rule 0     S' -> PROGRAMME
Rule 1     PROGRAMME -> varGlobal declaration_ instruction
Rule 2     varGlobal -> VAR_GLOBAL LBRACE declarations RBRACE
Rule 3     declaration_ -> DECLARATION LBRACE declarations RBRACE
Rule 4     instruction -> INSTRUCTION LBRACE statements RBRACE
Rule 5     declarations -> declaration declarations
Rule 6     declarations -> declaration
Rule 7     declarations -> empty
Rule 8     empty -> <empty>
Rule 9     declaration -> type declaration_list SEMICOLON
Rule 10    declaration -> CONST type ID EQUALS expression SEMICOLON
Rule 11    declaration_list -> declaration
Rule 12    declaration_list -> declaration COMMA declaration_list
Rule 13    declaration -> ID
Rule 14    declaration -> ID EQUALS expression
Rule 15    statement -> ID EQUALS expression SEMICOLON
Rule 16    type -> INT_TYPE
Rule 17    type -> FLOAT_TYPE
Rule 18    type -> BOOL_TYPE
Rule 19    type -> CHAR_TYPE
Rule 20    factor -> INTEGER
Rule 21    factor -> FLOAT
Rule 22    factor -> CHAR
Rule 23    factor -> BOOL
Rule 24    factor -> MINUS factor
Rule 25    factor -> PLUS factor
Rule 26    factor -> LPAREN INTEGER RPAREN
Rule 27    factor -> LPAREN FLOAT RPAREN
Rule 28    factor -> LPAREN MINUS FLOAT RPAREN
Rule 29    statements -> statement
Rule 30    statements -> statement statements
Rule 31    statements -> empty
Rule 32    statement -> simple_assignment
Rule 33    statement -> array_assignment
Rule 34    declaration -> array_declarationTab
Rule 35    declaration -> type declarationTab_listTab SEMICOLON
Rule 36    declaration -> const_declarationTab
Rule 37    simple_assignment -> ID EQUALS expressionTab SEMICOLON
Rule 38    const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON
Rule 39    array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON
Rule 40    declarationTab_listTab -> declarationTab
Rule 41    declarationTab_listTab -> declarationTab COMMA declarationTab_listTab
Rule 42    declarationTab -> ID
Rule 43    declarationTab -> ID EQUALS expressionTab
Rule 44    declarationTab -> ID LBRACKET INTEGER RBRACKET
Rule 45    expressionTab -> ID
Rule 46    expressionTab -> FLOAT
Rule 47    expressionTab -> INTEGER
Rule 48    expressionTab -> CHAR
Rule 49    factor -> ID LBRACKET expressionTab RBRACKET
Rule 50    array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON
Rule 51    expression -> expression OR term
Rule 52    expression -> term
Rule 53    term -> term AND factor
Rule 54    term -> factor
Rule 55    factor -> ID
Rule 56    factor -> TRUE
Rule 57    factor -> FALSE
Rule 58    factor -> NOT ID
Rule 59    statement -> type ID EQUALS expression_arithmetique SEMICOLON
Rule 60    statement -> ID EQUALS expression_arithmetique SEMICOLON
Rule 61    expression_arithmetique -> expression_arithmetique PLUS term_arithmetique
Rule 62    expression_arithmetique -> expression_arithmetique MINUS term_arithmetique
Rule 63    expression_arithmetique -> term_arithmetique
Rule 64    term_arithmetique -> term_arithmetique MULTIPLY term_arithmetique
Rule 65    term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique
Rule 66    term_arithmetique -> factor_arithmetique
Rule 67    factor_arithmetique -> ID
Rule 68    factor_arithmetique -> INTEGER
Rule 69    factor_arithmetique -> FLOAT
Rule 70    factor_arithmetique -> LPAREN expression_arithmetique RPAREN
Rule 71    statement -> READ LPAREN ID RPAREN SEMICOLON
Rule 72    statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON
Rule 73    statement -> WRITE LPAREN write_content RPAREN SEMICOLON
Rule 74    write_content -> write_item
Rule 75    write_content -> write_content COMMA write_item
Rule 76    write_item -> ID
Rule 77    write_item -> ID LBRACKET INTEGER RBRACKET
Rule 78    statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block
Rule 79    initialisation -> ID EQUALS INTEGER
Rule 80    step -> INTEGER
Rule 81    step -> ID
Rule 82    BorneSup -> ID
Rule 83    block -> LBRACE statements RBRACE

Terminals, with rules where they appear

AND                  : 53
BOOL                 : 23
BOOL_TYPE            : 18
CHAR                 : 22 48
CHAR_TYPE            : 19
COLON                : 78 78
COMMA                : 12 41 75
COMMENT              : 
CONST                : 10 38
DECLARATION          : 3
DIVIDE               : 65
ELSE                 : 
EQ                   : 
EQUALS               : 10 14 15 37 38 43 50 59 60 79
FALSE                : 57
FLOAT                : 21 27 28 46 69
FLOAT_TYPE           : 17
FOR                  : 78
GT                   : 
GTE                  : 
ID                   : 10 13 14 15 37 38 39 42 43 44 45 49 50 55 58 59 60 67 71 72 76 77 79 81 82
IF                   : 
INSTRUCTION          : 4
INTEGER              : 20 26 39 44 47 68 72 77 79 80
INT_TYPE             : 16
LBRACE               : 2 3 4 83
LBRACKET             : 39 44 49 50 72 77
LPAREN               : 26 27 28 70 71 72 73 78
LT                   : 
LTE                  : 
MINUS                : 24 28 62
MULTIPLY             : 64
NEQ                  : 
NOT                  : 58
NUMBER               : 
OR                   : 51
PLUS                 : 25 61
RBRACE               : 2 3 4 83
RBRACKET             : 39 44 49 50 72 77
READ                 : 71 72
RPAREN               : 26 27 28 70 71 72 73 78
SEMICOLON            : 9 10 15 35 37 38 39 50 59 60 71 72 73
TRUE                 : 56
VAR_GLOBAL           : 2
WRITE                : 73
error                : 

Nonterminals, with rules where they appear

BorneSup             : 78
PROGRAMME            : 0
array_assignment     : 33
array_declarationTab : 34
block                : 78
const_declarationTab : 36
declaration          : 5 6 11 12
declarationTab       : 40 41
declarationTab_listTab : 35 41
declaration_         : 1
declaration_list     : 9 12
declarations         : 2 3 5
empty                : 7 31
expression           : 10 14 15 51
expressionTab        : 37 38 43 49 50 50
expression_arithmetique : 59 60 61 62 70
factor               : 24 25 53 54
factor_arithmetique  : 65 66
initialisation       : 78
instruction          : 1
simple_assignment    : 32
statement            : 29 30
statements           : 4 30 83
step                 : 78
term                 : 51 52 53
term_arithmetique    : 61 62 63 64 64 65
type                 : 9 10 35 38 39 59
varGlobal            : 1
write_content        : 73 75
write_item           : 74 75

Parsing method: LALR

state 0

    (0) S' -> . PROGRAMME
    (1) PROGRAMME -> . varGlobal declaration_ instruction
    (2) varGlobal -> . VAR_GLOBAL LBRACE declarations RBRACE

    VAR_GLOBAL      shift and go to state 3

    PROGRAMME                      shift and go to state 1
    varGlobal                      shift and go to state 2

state 1

    (0) S' -> PROGRAMME .



state 2

    (1) PROGRAMME -> varGlobal . declaration_ instruction
    (3) declaration_ -> . DECLARATION LBRACE declarations RBRACE

    DECLARATION     shift and go to state 5

    declaration_                   shift and go to state 4

state 3

    (2) varGlobal -> VAR_GLOBAL . LBRACE declarations RBRACE

    LBRACE          shift and go to state 6


state 4

    (1) PROGRAMME -> varGlobal declaration_ . instruction
    (4) instruction -> . INSTRUCTION LBRACE statements RBRACE

    INSTRUCTION     shift and go to state 8

    instruction                    shift and go to state 7

state 5

    (3) declaration_ -> DECLARATION . LBRACE declarations RBRACE

    LBRACE          shift and go to state 9


state 6

    (2) varGlobal -> VAR_GLOBAL LBRACE . declarations RBRACE
    (5) declarations -> . declaration declarations
    (6) declarations -> . declaration
    (7) declarations -> . empty
    (9) declaration -> . type declaration_list SEMICOLON
    (10) declaration -> . CONST type ID EQUALS expression SEMICOLON
    (13) declaration -> . ID
    (14) declaration -> . ID EQUALS expression
    (34) declaration -> . array_declarationTab
    (35) declaration -> . type declarationTab_listTab SEMICOLON
    (36) declaration -> . const_declarationTab
    (8) empty -> .
    (16) type -> . INT_TYPE
    (17) type -> . FLOAT_TYPE
    (18) type -> . BOOL_TYPE
    (19) type -> . CHAR_TYPE
    (39) array_declarationTab -> . type ID LBRACKET INTEGER RBRACKET SEMICOLON
    (38) const_declarationTab -> . CONST type ID EQUALS expressionTab SEMICOLON

    CONST           shift and go to state 14
    ID              shift and go to state 15
    RBRACE          reduce using rule 8 (empty -> .)
    INT_TYPE        shift and go to state 18
    FLOAT_TYPE      shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    CHAR_TYPE       shift and go to state 21

    declarations                   shift and go to state 10
    declaration                    shift and go to state 11
    empty                          shift and go to state 12
    type                           shift and go to state 13
    array_declarationTab           shift and go to state 16
    const_declarationTab           shift and go to state 17

state 7

    (1) PROGRAMME -> varGlobal declaration_ instruction .

    $end            reduce using rule 1 (PROGRAMME -> varGlobal declaration_ instruction .)


state 8

    (4) instruction -> INSTRUCTION . LBRACE statements RBRACE

    LBRACE          shift and go to state 22


state 9

    (3) declaration_ -> DECLARATION LBRACE . declarations RBRACE
    (5) declarations -> . declaration declarations
    (6) declarations -> . declaration
    (7) declarations -> . empty
    (9) declaration -> . type declaration_list SEMICOLON
    (10) declaration -> . CONST type ID EQUALS expression SEMICOLON
    (13) declaration -> . ID
    (14) declaration -> . ID EQUALS expression
    (34) declaration -> . array_declarationTab
    (35) declaration -> . type declarationTab_listTab SEMICOLON
    (36) declaration -> . const_declarationTab
    (8) empty -> .
    (16) type -> . INT_TYPE
    (17) type -> . FLOAT_TYPE
    (18) type -> . BOOL_TYPE
    (19) type -> . CHAR_TYPE
    (39) array_declarationTab -> . type ID LBRACKET INTEGER RBRACKET SEMICOLON
    (38) const_declarationTab -> . CONST type ID EQUALS expressionTab SEMICOLON

    CONST           shift and go to state 14
    ID              shift and go to state 15
    RBRACE          reduce using rule 8 (empty -> .)
    INT_TYPE        shift and go to state 18
    FLOAT_TYPE      shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    CHAR_TYPE       shift and go to state 21

    declarations                   shift and go to state 23
    declaration                    shift and go to state 11
    empty                          shift and go to state 12
    type                           shift and go to state 13
    array_declarationTab           shift and go to state 16
    const_declarationTab           shift and go to state 17

state 10

    (2) varGlobal -> VAR_GLOBAL LBRACE declarations . RBRACE

    RBRACE          shift and go to state 24


state 11

    (5) declarations -> declaration . declarations
    (6) declarations -> declaration .
    (5) declarations -> . declaration declarations
    (6) declarations -> . declaration
    (7) declarations -> . empty
    (9) declaration -> . type declaration_list SEMICOLON
    (10) declaration -> . CONST type ID EQUALS expression SEMICOLON
    (13) declaration -> . ID
    (14) declaration -> . ID EQUALS expression
    (34) declaration -> . array_declarationTab
    (35) declaration -> . type declarationTab_listTab SEMICOLON
    (36) declaration -> . const_declarationTab
    (8) empty -> .
    (16) type -> . INT_TYPE
    (17) type -> . FLOAT_TYPE
    (18) type -> . BOOL_TYPE
    (19) type -> . CHAR_TYPE
    (39) array_declarationTab -> . type ID LBRACKET INTEGER RBRACKET SEMICOLON
    (38) const_declarationTab -> . CONST type ID EQUALS expressionTab SEMICOLON

  ! reduce/reduce conflict for RBRACE resolved using rule 6 (declarations -> declaration .)
    RBRACE          reduce using rule 6 (declarations -> declaration .)
    CONST           shift and go to state 14
    ID              shift and go to state 15
    INT_TYPE        shift and go to state 18
    FLOAT_TYPE      shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    CHAR_TYPE       shift and go to state 21

  ! RBRACE          [ reduce using rule 8 (empty -> .) ]

    declaration                    shift and go to state 11
    declarations                   shift and go to state 25
    empty                          shift and go to state 12
    type                           shift and go to state 13
    array_declarationTab           shift and go to state 16
    const_declarationTab           shift and go to state 17

state 12

    (7) declarations -> empty .

    RBRACE          reduce using rule 7 (declarations -> empty .)


state 13

    (9) declaration -> type . declaration_list SEMICOLON
    (35) declaration -> type . declarationTab_listTab SEMICOLON
    (39) array_declarationTab -> type . ID LBRACKET INTEGER RBRACKET SEMICOLON
    (11) declaration_list -> . declaration
    (12) declaration_list -> . declaration COMMA declaration_list
    (40) declarationTab_listTab -> . declarationTab
    (41) declarationTab_listTab -> . declarationTab COMMA declarationTab_listTab
    (9) declaration -> . type declaration_list SEMICOLON
    (10) declaration -> . CONST type ID EQUALS expression SEMICOLON
    (13) declaration -> . ID
    (14) declaration -> . ID EQUALS expression
    (34) declaration -> . array_declarationTab
    (35) declaration -> . type declarationTab_listTab SEMICOLON
    (36) declaration -> . const_declarationTab
    (42) declarationTab -> . ID
    (43) declarationTab -> . ID EQUALS expressionTab
    (44) declarationTab -> . ID LBRACKET INTEGER RBRACKET
    (16) type -> . INT_TYPE
    (17) type -> . FLOAT_TYPE
    (18) type -> . BOOL_TYPE
    (19) type -> . CHAR_TYPE
    (39) array_declarationTab -> . type ID LBRACKET INTEGER RBRACKET SEMICOLON
    (38) const_declarationTab -> . CONST type ID EQUALS expressionTab SEMICOLON

    ID              shift and go to state 28
    CONST           shift and go to state 14
    INT_TYPE        shift and go to state 18
    FLOAT_TYPE      shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    CHAR_TYPE       shift and go to state 21

    type                           shift and go to state 13
    declaration_list               shift and go to state 26
    declarationTab_listTab         shift and go to state 27
    declaration                    shift and go to state 29
    declarationTab                 shift and go to state 30
    array_declarationTab           shift and go to state 16
    const_declarationTab           shift and go to state 17

state 14

    (10) declaration -> CONST . type ID EQUALS expression SEMICOLON
    (38) const_declarationTab -> CONST . type ID EQUALS expressionTab SEMICOLON
    (16) type -> . INT_TYPE
    (17) type -> . FLOAT_TYPE
    (18) type -> . BOOL_TYPE
    (19) type -> . CHAR_TYPE

    INT_TYPE        shift and go to state 18
    FLOAT_TYPE      shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    CHAR_TYPE       shift and go to state 21

    type                           shift and go to state 31

state 15

    (13) declaration -> ID .
    (14) declaration -> ID . EQUALS expression

    CONST           reduce using rule 13 (declaration -> ID .)
    ID              reduce using rule 13 (declaration -> ID .)
    INT_TYPE        reduce using rule 13 (declaration -> ID .)
    FLOAT_TYPE      reduce using rule 13 (declaration -> ID .)
    BOOL_TYPE       reduce using rule 13 (declaration -> ID .)
    CHAR_TYPE       reduce using rule 13 (declaration -> ID .)
    RBRACE          reduce using rule 13 (declaration -> ID .)
    COMMA           reduce using rule 13 (declaration -> ID .)
    SEMICOLON       reduce using rule 13 (declaration -> ID .)
    EQUALS          shift and go to state 32


state 16

    (34) declaration -> array_declarationTab .

    CONST           reduce using rule 34 (declaration -> array_declarationTab .)
    ID              reduce using rule 34 (declaration -> array_declarationTab .)
    INT_TYPE        reduce using rule 34 (declaration -> array_declarationTab .)
    FLOAT_TYPE      reduce using rule 34 (declaration -> array_declarationTab .)
    BOOL_TYPE       reduce using rule 34 (declaration -> array_declarationTab .)
    CHAR_TYPE       reduce using rule 34 (declaration -> array_declarationTab .)
    RBRACE          reduce using rule 34 (declaration -> array_declarationTab .)
    COMMA           reduce using rule 34 (declaration -> array_declarationTab .)
    SEMICOLON       reduce using rule 34 (declaration -> array_declarationTab .)


state 17

    (36) declaration -> const_declarationTab .

    CONST           reduce using rule 36 (declaration -> const_declarationTab .)
    ID              reduce using rule 36 (declaration -> const_declarationTab .)
    INT_TYPE        reduce using rule 36 (declaration -> const_declarationTab .)
    FLOAT_TYPE      reduce using rule 36 (declaration -> const_declarationTab .)
    BOOL_TYPE       reduce using rule 36 (declaration -> const_declarationTab .)
    CHAR_TYPE       reduce using rule 36 (declaration -> const_declarationTab .)
    RBRACE          reduce using rule 36 (declaration -> const_declarationTab .)
    COMMA           reduce using rule 36 (declaration -> const_declarationTab .)
    SEMICOLON       reduce using rule 36 (declaration -> const_declarationTab .)


state 18

    (16) type -> INT_TYPE .

    ID              reduce using rule 16 (type -> INT_TYPE .)
    CONST           reduce using rule 16 (type -> INT_TYPE .)
    INT_TYPE        reduce using rule 16 (type -> INT_TYPE .)
    FLOAT_TYPE      reduce using rule 16 (type -> INT_TYPE .)
    BOOL_TYPE       reduce using rule 16 (type -> INT_TYPE .)
    CHAR_TYPE       reduce using rule 16 (type -> INT_TYPE .)


state 19

    (17) type -> FLOAT_TYPE .

    ID              reduce using rule 17 (type -> FLOAT_TYPE .)
    CONST           reduce using rule 17 (type -> FLOAT_TYPE .)
    INT_TYPE        reduce using rule 17 (type -> FLOAT_TYPE .)
    FLOAT_TYPE      reduce using rule 17 (type -> FLOAT_TYPE .)
    BOOL_TYPE       reduce using rule 17 (type -> FLOAT_TYPE .)
    CHAR_TYPE       reduce using rule 17 (type -> FLOAT_TYPE .)


state 20

    (18) type -> BOOL_TYPE .

    ID              reduce using rule 18 (type -> BOOL_TYPE .)
    CONST           reduce using rule 18 (type -> BOOL_TYPE .)
    INT_TYPE        reduce using rule 18 (type -> BOOL_TYPE .)
    FLOAT_TYPE      reduce using rule 18 (type -> BOOL_TYPE .)
    BOOL_TYPE       reduce using rule 18 (type -> BOOL_TYPE .)
    CHAR_TYPE       reduce using rule 18 (type -> BOOL_TYPE .)


state 21

    (19) type -> CHAR_TYPE .

    ID              reduce using rule 19 (type -> CHAR_TYPE .)
    CONST           reduce using rule 19 (type -> CHAR_TYPE .)
    INT_TYPE        reduce using rule 19 (type -> CHAR_TYPE .)
    FLOAT_TYPE      reduce using rule 19 (type -> CHAR_TYPE .)
    BOOL_TYPE       reduce using rule 19 (type -> CHAR_TYPE .)
    CHAR_TYPE       reduce using rule 19 (type -> CHAR_TYPE .)


state 22

    (4) instruction -> INSTRUCTION LBRACE . statements RBRACE
    (29) statements -> . statement
    (30) statements -> . statement statements
    (31) statements -> . empty
    (15) statement -> . ID EQUALS expression SEMICOLON
    (32) statement -> . simple_assignment
    (33) statement -> . array_assignment
    (59) statement -> . type ID EQUALS expression_arithmetique SEMICOLON
    (60) statement -> . ID EQUALS expression_arithmetique SEMICOLON
    (71) statement -> . READ LPAREN ID RPAREN SEMICOLON
    (72) statement -> . READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON
    (73) statement -> . WRITE LPAREN write_content RPAREN SEMICOLON
    (78) statement -> . FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block
    (8) empty -> .
    (37) simple_assignment -> . ID EQUALS expressionTab SEMICOLON
    (50) array_assignment -> . ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON
    (16) type -> . INT_TYPE
    (17) type -> . FLOAT_TYPE
    (18) type -> . BOOL_TYPE
    (19) type -> . CHAR_TYPE

    ID              shift and go to state 36
    READ            shift and go to state 40
    WRITE           shift and go to state 41
    FOR             shift and go to state 42
    RBRACE          reduce using rule 8 (empty -> .)
    INT_TYPE        shift and go to state 18
    FLOAT_TYPE      shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    CHAR_TYPE       shift and go to state 21

    statements                     shift and go to state 33
    statement                      shift and go to state 34
    empty                          shift and go to state 35
    simple_assignment              shift and go to state 37
    array_assignment               shift and go to state 38
    type                           shift and go to state 39

state 23

    (3) declaration_ -> DECLARATION LBRACE declarations . RBRACE

    RBRACE          shift and go to state 43


state 24

    (2) varGlobal -> VAR_GLOBAL LBRACE declarations RBRACE .

    DECLARATION     reduce using rule 2 (varGlobal -> VAR_GLOBAL LBRACE declarations RBRACE .)


state 25

    (5) declarations -> declaration declarations .

    RBRACE          reduce using rule 5 (declarations -> declaration declarations .)


state 26

    (9) declaration -> type declaration_list . SEMICOLON

    SEMICOLON       shift and go to state 44


state 27

    (35) declaration -> type declarationTab_listTab . SEMICOLON

    SEMICOLON       shift and go to state 45


state 28

    (39) array_declarationTab -> type ID . LBRACKET INTEGER RBRACKET SEMICOLON
    (13) declaration -> ID .
    (14) declaration -> ID . EQUALS expression
    (42) declarationTab -> ID .
    (43) declarationTab -> ID . EQUALS expressionTab
    (44) declarationTab -> ID . LBRACKET INTEGER RBRACKET

  ! reduce/reduce conflict for COMMA resolved using rule 13 (declaration -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 13 (declaration -> ID .)
    LBRACKET        shift and go to state 46
    COMMA           reduce using rule 13 (declaration -> ID .)
    SEMICOLON       reduce using rule 13 (declaration -> ID .)
    EQUALS          shift and go to state 47

  ! COMMA           [ reduce using rule 42 (declarationTab -> ID .) ]
  ! SEMICOLON       [ reduce using rule 42 (declarationTab -> ID .) ]


state 29

    (11) declaration_list -> declaration .
    (12) declaration_list -> declaration . COMMA declaration_list

    SEMICOLON       reduce using rule 11 (declaration_list -> declaration .)
    COMMA           shift and go to state 48


state 30

    (40) declarationTab_listTab -> declarationTab .
    (41) declarationTab_listTab -> declarationTab . COMMA declarationTab_listTab

    SEMICOLON       reduce using rule 40 (declarationTab_listTab -> declarationTab .)
    COMMA           shift and go to state 49


state 31

    (10) declaration -> CONST type . ID EQUALS expression SEMICOLON
    (38) const_declarationTab -> CONST type . ID EQUALS expressionTab SEMICOLON

    ID              shift and go to state 50


state 32

    (14) declaration -> ID EQUALS . expression
    (51) expression -> . expression OR term
    (52) expression -> . term
    (53) term -> . term AND factor
    (54) term -> . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . CHAR
    (23) factor -> . BOOL
    (24) factor -> . MINUS factor
    (25) factor -> . PLUS factor
    (26) factor -> . LPAREN INTEGER RPAREN
    (27) factor -> . LPAREN FLOAT RPAREN
    (28) factor -> . LPAREN MINUS FLOAT RPAREN
    (49) factor -> . ID LBRACKET expressionTab RBRACKET
    (55) factor -> . ID
    (56) factor -> . TRUE
    (57) factor -> . FALSE
    (58) factor -> . NOT ID

    INTEGER         shift and go to state 55
    FLOAT           shift and go to state 56
    CHAR            shift and go to state 57
    BOOL            shift and go to state 58
    MINUS           shift and go to state 59
    PLUS            shift and go to state 60
    LPAREN          shift and go to state 61
    ID              shift and go to state 51
    TRUE            shift and go to state 62
    FALSE           shift and go to state 63
    NOT             shift and go to state 64

    expression                     shift and go to state 52
    term                           shift and go to state 53
    factor                         shift and go to state 54

state 33

    (4) instruction -> INSTRUCTION LBRACE statements . RBRACE

    RBRACE          shift and go to state 65


state 34

    (29) statements -> statement .
    (30) statements -> statement . statements
    (29) statements -> . statement
    (30) statements -> . statement statements
    (31) statements -> . empty
    (15) statement -> . ID EQUALS expression SEMICOLON
    (32) statement -> . simple_assignment
    (33) statement -> . array_assignment
    (59) statement -> . type ID EQUALS expression_arithmetique SEMICOLON
    (60) statement -> . ID EQUALS expression_arithmetique SEMICOLON
    (71) statement -> . READ LPAREN ID RPAREN SEMICOLON
    (72) statement -> . READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON
    (73) statement -> . WRITE LPAREN write_content RPAREN SEMICOLON
    (78) statement -> . FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block
    (8) empty -> .
    (37) simple_assignment -> . ID EQUALS expressionTab SEMICOLON
    (50) array_assignment -> . ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON
    (16) type -> . INT_TYPE
    (17) type -> . FLOAT_TYPE
    (18) type -> . BOOL_TYPE
    (19) type -> . CHAR_TYPE

  ! reduce/reduce conflict for RBRACE resolved using rule 8 (empty -> .)
    ID              shift and go to state 36
    READ            shift and go to state 40
    WRITE           shift and go to state 41
    FOR             shift and go to state 42
    RBRACE          reduce using rule 8 (empty -> .)
    INT_TYPE        shift and go to state 18
    FLOAT_TYPE      shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    CHAR_TYPE       shift and go to state 21

  ! RBRACE          [ reduce using rule 29 (statements -> statement .) ]

    statement                      shift and go to state 34
    statements                     shift and go to state 66
    empty                          shift and go to state 35
    simple_assignment              shift and go to state 37
    array_assignment               shift and go to state 38
    type                           shift and go to state 39

state 35

    (31) statements -> empty .

    RBRACE          reduce using rule 31 (statements -> empty .)


state 36

    (15) statement -> ID . EQUALS expression SEMICOLON
    (60) statement -> ID . EQUALS expression_arithmetique SEMICOLON
    (37) simple_assignment -> ID . EQUALS expressionTab SEMICOLON
    (50) array_assignment -> ID . LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON

    EQUALS          shift and go to state 67
    LBRACKET        shift and go to state 68


state 37

    (32) statement -> simple_assignment .

    ID              reduce using rule 32 (statement -> simple_assignment .)
    READ            reduce using rule 32 (statement -> simple_assignment .)
    WRITE           reduce using rule 32 (statement -> simple_assignment .)
    FOR             reduce using rule 32 (statement -> simple_assignment .)
    INT_TYPE        reduce using rule 32 (statement -> simple_assignment .)
    FLOAT_TYPE      reduce using rule 32 (statement -> simple_assignment .)
    BOOL_TYPE       reduce using rule 32 (statement -> simple_assignment .)
    CHAR_TYPE       reduce using rule 32 (statement -> simple_assignment .)
    RBRACE          reduce using rule 32 (statement -> simple_assignment .)


state 38

    (33) statement -> array_assignment .

    ID              reduce using rule 33 (statement -> array_assignment .)
    READ            reduce using rule 33 (statement -> array_assignment .)
    WRITE           reduce using rule 33 (statement -> array_assignment .)
    FOR             reduce using rule 33 (statement -> array_assignment .)
    INT_TYPE        reduce using rule 33 (statement -> array_assignment .)
    FLOAT_TYPE      reduce using rule 33 (statement -> array_assignment .)
    BOOL_TYPE       reduce using rule 33 (statement -> array_assignment .)
    CHAR_TYPE       reduce using rule 33 (statement -> array_assignment .)
    RBRACE          reduce using rule 33 (statement -> array_assignment .)


state 39

    (59) statement -> type . ID EQUALS expression_arithmetique SEMICOLON

    ID              shift and go to state 69


state 40

    (71) statement -> READ . LPAREN ID RPAREN SEMICOLON
    (72) statement -> READ . LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON

    LPAREN          shift and go to state 70


state 41

    (73) statement -> WRITE . LPAREN write_content RPAREN SEMICOLON

    LPAREN          shift and go to state 71


state 42

    (78) statement -> FOR . LPAREN initialisation COLON step COLON BorneSup RPAREN block

    LPAREN          shift and go to state 72


state 43

    (3) declaration_ -> DECLARATION LBRACE declarations RBRACE .

    INSTRUCTION     reduce using rule 3 (declaration_ -> DECLARATION LBRACE declarations RBRACE .)


state 44

    (9) declaration -> type declaration_list SEMICOLON .

    CONST           reduce using rule 9 (declaration -> type declaration_list SEMICOLON .)
    ID              reduce using rule 9 (declaration -> type declaration_list SEMICOLON .)
    INT_TYPE        reduce using rule 9 (declaration -> type declaration_list SEMICOLON .)
    FLOAT_TYPE      reduce using rule 9 (declaration -> type declaration_list SEMICOLON .)
    BOOL_TYPE       reduce using rule 9 (declaration -> type declaration_list SEMICOLON .)
    CHAR_TYPE       reduce using rule 9 (declaration -> type declaration_list SEMICOLON .)
    RBRACE          reduce using rule 9 (declaration -> type declaration_list SEMICOLON .)
    COMMA           reduce using rule 9 (declaration -> type declaration_list SEMICOLON .)
    SEMICOLON       reduce using rule 9 (declaration -> type declaration_list SEMICOLON .)


state 45

    (35) declaration -> type declarationTab_listTab SEMICOLON .

    CONST           reduce using rule 35 (declaration -> type declarationTab_listTab SEMICOLON .)
    ID              reduce using rule 35 (declaration -> type declarationTab_listTab SEMICOLON .)
    INT_TYPE        reduce using rule 35 (declaration -> type declarationTab_listTab SEMICOLON .)
    FLOAT_TYPE      reduce using rule 35 (declaration -> type declarationTab_listTab SEMICOLON .)
    BOOL_TYPE       reduce using rule 35 (declaration -> type declarationTab_listTab SEMICOLON .)
    CHAR_TYPE       reduce using rule 35 (declaration -> type declarationTab_listTab SEMICOLON .)
    RBRACE          reduce using rule 35 (declaration -> type declarationTab_listTab SEMICOLON .)
    COMMA           reduce using rule 35 (declaration -> type declarationTab_listTab SEMICOLON .)
    SEMICOLON       reduce using rule 35 (declaration -> type declarationTab_listTab SEMICOLON .)


state 46

    (39) array_declarationTab -> type ID LBRACKET . INTEGER RBRACKET SEMICOLON
    (44) declarationTab -> ID LBRACKET . INTEGER RBRACKET

    INTEGER         shift and go to state 73


state 47

    (14) declaration -> ID EQUALS . expression
    (43) declarationTab -> ID EQUALS . expressionTab
    (51) expression -> . expression OR term
    (52) expression -> . term
    (45) expressionTab -> . ID
    (46) expressionTab -> . FLOAT
    (47) expressionTab -> . INTEGER
    (48) expressionTab -> . CHAR
    (53) term -> . term AND factor
    (54) term -> . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . CHAR
    (23) factor -> . BOOL
    (24) factor -> . MINUS factor
    (25) factor -> . PLUS factor
    (26) factor -> . LPAREN INTEGER RPAREN
    (27) factor -> . LPAREN FLOAT RPAREN
    (28) factor -> . LPAREN MINUS FLOAT RPAREN
    (49) factor -> . ID LBRACKET expressionTab RBRACKET
    (55) factor -> . ID
    (56) factor -> . TRUE
    (57) factor -> . FALSE
    (58) factor -> . NOT ID

    ID              shift and go to state 74
    FLOAT           shift and go to state 76
    INTEGER         shift and go to state 77
    CHAR            shift and go to state 78
    BOOL            shift and go to state 58
    MINUS           shift and go to state 59
    PLUS            shift and go to state 60
    LPAREN          shift and go to state 61
    TRUE            shift and go to state 62
    FALSE           shift and go to state 63
    NOT             shift and go to state 64

    expression                     shift and go to state 52
    expressionTab                  shift and go to state 75
    term                           shift and go to state 53
    factor                         shift and go to state 54

state 48

    (12) declaration_list -> declaration COMMA . declaration_list
    (11) declaration_list -> . declaration
    (12) declaration_list -> . declaration COMMA declaration_list
    (9) declaration -> . type declaration_list SEMICOLON
    (10) declaration -> . CONST type ID EQUALS expression SEMICOLON
    (13) declaration -> . ID
    (14) declaration -> . ID EQUALS expression
    (34) declaration -> . array_declarationTab
    (35) declaration -> . type declarationTab_listTab SEMICOLON
    (36) declaration -> . const_declarationTab
    (16) type -> . INT_TYPE
    (17) type -> . FLOAT_TYPE
    (18) type -> . BOOL_TYPE
    (19) type -> . CHAR_TYPE
    (39) array_declarationTab -> . type ID LBRACKET INTEGER RBRACKET SEMICOLON
    (38) const_declarationTab -> . CONST type ID EQUALS expressionTab SEMICOLON

    CONST           shift and go to state 14
    ID              shift and go to state 15
    INT_TYPE        shift and go to state 18
    FLOAT_TYPE      shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    CHAR_TYPE       shift and go to state 21

    declaration                    shift and go to state 29
    declaration_list               shift and go to state 79
    type                           shift and go to state 13
    array_declarationTab           shift and go to state 16
    const_declarationTab           shift and go to state 17

state 49

    (41) declarationTab_listTab -> declarationTab COMMA . declarationTab_listTab
    (40) declarationTab_listTab -> . declarationTab
    (41) declarationTab_listTab -> . declarationTab COMMA declarationTab_listTab
    (42) declarationTab -> . ID
    (43) declarationTab -> . ID EQUALS expressionTab
    (44) declarationTab -> . ID LBRACKET INTEGER RBRACKET

    ID              shift and go to state 81

    declarationTab                 shift and go to state 30
    declarationTab_listTab         shift and go to state 80

state 50

    (10) declaration -> CONST type ID . EQUALS expression SEMICOLON
    (38) const_declarationTab -> CONST type ID . EQUALS expressionTab SEMICOLON

    EQUALS          shift and go to state 82


state 51

    (49) factor -> ID . LBRACKET expressionTab RBRACKET
    (55) factor -> ID .

    LBRACKET        shift and go to state 83
    AND             reduce using rule 55 (factor -> ID .)
    OR              reduce using rule 55 (factor -> ID .)
    CONST           reduce using rule 55 (factor -> ID .)
    ID              reduce using rule 55 (factor -> ID .)
    INT_TYPE        reduce using rule 55 (factor -> ID .)
    FLOAT_TYPE      reduce using rule 55 (factor -> ID .)
    BOOL_TYPE       reduce using rule 55 (factor -> ID .)
    CHAR_TYPE       reduce using rule 55 (factor -> ID .)
    RBRACE          reduce using rule 55 (factor -> ID .)
    COMMA           reduce using rule 55 (factor -> ID .)
    SEMICOLON       reduce using rule 55 (factor -> ID .)


state 52

    (14) declaration -> ID EQUALS expression .
    (51) expression -> expression . OR term

    CONST           reduce using rule 14 (declaration -> ID EQUALS expression .)
    ID              reduce using rule 14 (declaration -> ID EQUALS expression .)
    INT_TYPE        reduce using rule 14 (declaration -> ID EQUALS expression .)
    FLOAT_TYPE      reduce using rule 14 (declaration -> ID EQUALS expression .)
    BOOL_TYPE       reduce using rule 14 (declaration -> ID EQUALS expression .)
    CHAR_TYPE       reduce using rule 14 (declaration -> ID EQUALS expression .)
    RBRACE          reduce using rule 14 (declaration -> ID EQUALS expression .)
    COMMA           reduce using rule 14 (declaration -> ID EQUALS expression .)
    SEMICOLON       reduce using rule 14 (declaration -> ID EQUALS expression .)
    OR              shift and go to state 84


state 53

    (52) expression -> term .
    (53) term -> term . AND factor

    OR              reduce using rule 52 (expression -> term .)
    CONST           reduce using rule 52 (expression -> term .)
    ID              reduce using rule 52 (expression -> term .)
    INT_TYPE        reduce using rule 52 (expression -> term .)
    FLOAT_TYPE      reduce using rule 52 (expression -> term .)
    BOOL_TYPE       reduce using rule 52 (expression -> term .)
    CHAR_TYPE       reduce using rule 52 (expression -> term .)
    RBRACE          reduce using rule 52 (expression -> term .)
    COMMA           reduce using rule 52 (expression -> term .)
    SEMICOLON       reduce using rule 52 (expression -> term .)
    AND             shift and go to state 85


state 54

    (54) term -> factor .

    AND             reduce using rule 54 (term -> factor .)
    OR              reduce using rule 54 (term -> factor .)
    CONST           reduce using rule 54 (term -> factor .)
    ID              reduce using rule 54 (term -> factor .)
    INT_TYPE        reduce using rule 54 (term -> factor .)
    FLOAT_TYPE      reduce using rule 54 (term -> factor .)
    BOOL_TYPE       reduce using rule 54 (term -> factor .)
    CHAR_TYPE       reduce using rule 54 (term -> factor .)
    RBRACE          reduce using rule 54 (term -> factor .)
    COMMA           reduce using rule 54 (term -> factor .)
    SEMICOLON       reduce using rule 54 (term -> factor .)


state 55

    (20) factor -> INTEGER .

    AND             reduce using rule 20 (factor -> INTEGER .)
    OR              reduce using rule 20 (factor -> INTEGER .)
    CONST           reduce using rule 20 (factor -> INTEGER .)
    ID              reduce using rule 20 (factor -> INTEGER .)
    INT_TYPE        reduce using rule 20 (factor -> INTEGER .)
    FLOAT_TYPE      reduce using rule 20 (factor -> INTEGER .)
    BOOL_TYPE       reduce using rule 20 (factor -> INTEGER .)
    CHAR_TYPE       reduce using rule 20 (factor -> INTEGER .)
    RBRACE          reduce using rule 20 (factor -> INTEGER .)
    COMMA           reduce using rule 20 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 20 (factor -> INTEGER .)


state 56

    (21) factor -> FLOAT .

    AND             reduce using rule 21 (factor -> FLOAT .)
    OR              reduce using rule 21 (factor -> FLOAT .)
    CONST           reduce using rule 21 (factor -> FLOAT .)
    ID              reduce using rule 21 (factor -> FLOAT .)
    INT_TYPE        reduce using rule 21 (factor -> FLOAT .)
    FLOAT_TYPE      reduce using rule 21 (factor -> FLOAT .)
    BOOL_TYPE       reduce using rule 21 (factor -> FLOAT .)
    CHAR_TYPE       reduce using rule 21 (factor -> FLOAT .)
    RBRACE          reduce using rule 21 (factor -> FLOAT .)
    COMMA           reduce using rule 21 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 21 (factor -> FLOAT .)


state 57

    (22) factor -> CHAR .

    AND             reduce using rule 22 (factor -> CHAR .)
    OR              reduce using rule 22 (factor -> CHAR .)
    CONST           reduce using rule 22 (factor -> CHAR .)
    ID              reduce using rule 22 (factor -> CHAR .)
    INT_TYPE        reduce using rule 22 (factor -> CHAR .)
    FLOAT_TYPE      reduce using rule 22 (factor -> CHAR .)
    BOOL_TYPE       reduce using rule 22 (factor -> CHAR .)
    CHAR_TYPE       reduce using rule 22 (factor -> CHAR .)
    RBRACE          reduce using rule 22 (factor -> CHAR .)
    COMMA           reduce using rule 22 (factor -> CHAR .)
    SEMICOLON       reduce using rule 22 (factor -> CHAR .)


state 58

    (23) factor -> BOOL .

    AND             reduce using rule 23 (factor -> BOOL .)
    OR              reduce using rule 23 (factor -> BOOL .)
    CONST           reduce using rule 23 (factor -> BOOL .)
    ID              reduce using rule 23 (factor -> BOOL .)
    INT_TYPE        reduce using rule 23 (factor -> BOOL .)
    FLOAT_TYPE      reduce using rule 23 (factor -> BOOL .)
    BOOL_TYPE       reduce using rule 23 (factor -> BOOL .)
    CHAR_TYPE       reduce using rule 23 (factor -> BOOL .)
    RBRACE          reduce using rule 23 (factor -> BOOL .)
    COMMA           reduce using rule 23 (factor -> BOOL .)
    SEMICOLON       reduce using rule 23 (factor -> BOOL .)


state 59

    (24) factor -> MINUS . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . CHAR
    (23) factor -> . BOOL
    (24) factor -> . MINUS factor
    (25) factor -> . PLUS factor
    (26) factor -> . LPAREN INTEGER RPAREN
    (27) factor -> . LPAREN FLOAT RPAREN
    (28) factor -> . LPAREN MINUS FLOAT RPAREN
    (49) factor -> . ID LBRACKET expressionTab RBRACKET
    (55) factor -> . ID
    (56) factor -> . TRUE
    (57) factor -> . FALSE
    (58) factor -> . NOT ID

    INTEGER         shift and go to state 55
    FLOAT           shift and go to state 56
    CHAR            shift and go to state 57
    BOOL            shift and go to state 58
    MINUS           shift and go to state 59
    PLUS            shift and go to state 60
    LPAREN          shift and go to state 61
    ID              shift and go to state 51
    TRUE            shift and go to state 62
    FALSE           shift and go to state 63
    NOT             shift and go to state 64

    factor                         shift and go to state 86

state 60

    (25) factor -> PLUS . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . CHAR
    (23) factor -> . BOOL
    (24) factor -> . MINUS factor
    (25) factor -> . PLUS factor
    (26) factor -> . LPAREN INTEGER RPAREN
    (27) factor -> . LPAREN FLOAT RPAREN
    (28) factor -> . LPAREN MINUS FLOAT RPAREN
    (49) factor -> . ID LBRACKET expressionTab RBRACKET
    (55) factor -> . ID
    (56) factor -> . TRUE
    (57) factor -> . FALSE
    (58) factor -> . NOT ID

    INTEGER         shift and go to state 55
    FLOAT           shift and go to state 56
    CHAR            shift and go to state 57
    BOOL            shift and go to state 58
    MINUS           shift and go to state 59
    PLUS            shift and go to state 60
    LPAREN          shift and go to state 61
    ID              shift and go to state 51
    TRUE            shift and go to state 62
    FALSE           shift and go to state 63
    NOT             shift and go to state 64

    factor                         shift and go to state 87

state 61

    (26) factor -> LPAREN . INTEGER RPAREN
    (27) factor -> LPAREN . FLOAT RPAREN
    (28) factor -> LPAREN . MINUS FLOAT RPAREN

    INTEGER         shift and go to state 88
    FLOAT           shift and go to state 89
    MINUS           shift and go to state 90


state 62

    (56) factor -> TRUE .

    AND             reduce using rule 56 (factor -> TRUE .)
    OR              reduce using rule 56 (factor -> TRUE .)
    CONST           reduce using rule 56 (factor -> TRUE .)
    ID              reduce using rule 56 (factor -> TRUE .)
    INT_TYPE        reduce using rule 56 (factor -> TRUE .)
    FLOAT_TYPE      reduce using rule 56 (factor -> TRUE .)
    BOOL_TYPE       reduce using rule 56 (factor -> TRUE .)
    CHAR_TYPE       reduce using rule 56 (factor -> TRUE .)
    RBRACE          reduce using rule 56 (factor -> TRUE .)
    COMMA           reduce using rule 56 (factor -> TRUE .)
    SEMICOLON       reduce using rule 56 (factor -> TRUE .)


state 63

    (57) factor -> FALSE .

    AND             reduce using rule 57 (factor -> FALSE .)
    OR              reduce using rule 57 (factor -> FALSE .)
    CONST           reduce using rule 57 (factor -> FALSE .)
    ID              reduce using rule 57 (factor -> FALSE .)
    INT_TYPE        reduce using rule 57 (factor -> FALSE .)
    FLOAT_TYPE      reduce using rule 57 (factor -> FALSE .)
    BOOL_TYPE       reduce using rule 57 (factor -> FALSE .)
    CHAR_TYPE       reduce using rule 57 (factor -> FALSE .)
    RBRACE          reduce using rule 57 (factor -> FALSE .)
    COMMA           reduce using rule 57 (factor -> FALSE .)
    SEMICOLON       reduce using rule 57 (factor -> FALSE .)


state 64

    (58) factor -> NOT . ID

    ID              shift and go to state 91


state 65

    (4) instruction -> INSTRUCTION LBRACE statements RBRACE .

    $end            reduce using rule 4 (instruction -> INSTRUCTION LBRACE statements RBRACE .)


state 66

    (30) statements -> statement statements .

    RBRACE          reduce using rule 30 (statements -> statement statements .)


state 67

    (15) statement -> ID EQUALS . expression SEMICOLON
    (60) statement -> ID EQUALS . expression_arithmetique SEMICOLON
    (37) simple_assignment -> ID EQUALS . expressionTab SEMICOLON
    (51) expression -> . expression OR term
    (52) expression -> . term
    (61) expression_arithmetique -> . expression_arithmetique PLUS term_arithmetique
    (62) expression_arithmetique -> . expression_arithmetique MINUS term_arithmetique
    (63) expression_arithmetique -> . term_arithmetique
    (45) expressionTab -> . ID
    (46) expressionTab -> . FLOAT
    (47) expressionTab -> . INTEGER
    (48) expressionTab -> . CHAR
    (53) term -> . term AND factor
    (54) term -> . factor
    (64) term_arithmetique -> . term_arithmetique MULTIPLY term_arithmetique
    (65) term_arithmetique -> . term_arithmetique DIVIDE factor_arithmetique
    (66) term_arithmetique -> . factor_arithmetique
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . CHAR
    (23) factor -> . BOOL
    (24) factor -> . MINUS factor
    (25) factor -> . PLUS factor
    (26) factor -> . LPAREN INTEGER RPAREN
    (27) factor -> . LPAREN FLOAT RPAREN
    (28) factor -> . LPAREN MINUS FLOAT RPAREN
    (49) factor -> . ID LBRACKET expressionTab RBRACKET
    (55) factor -> . ID
    (56) factor -> . TRUE
    (57) factor -> . FALSE
    (58) factor -> . NOT ID
    (67) factor_arithmetique -> . ID
    (68) factor_arithmetique -> . INTEGER
    (69) factor_arithmetique -> . FLOAT
    (70) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN

    ID              shift and go to state 92
    FLOAT           shift and go to state 97
    INTEGER         shift and go to state 98
    CHAR            shift and go to state 78
    BOOL            shift and go to state 58
    MINUS           shift and go to state 59
    PLUS            shift and go to state 60
    LPAREN          shift and go to state 100
    TRUE            shift and go to state 62
    FALSE           shift and go to state 63
    NOT             shift and go to state 64

    expression                     shift and go to state 93
    expression_arithmetique        shift and go to state 94
    expressionTab                  shift and go to state 95
    term                           shift and go to state 53
    term_arithmetique              shift and go to state 96
    factor                         shift and go to state 54
    factor_arithmetique            shift and go to state 99

state 68

    (50) array_assignment -> ID LBRACKET . expressionTab RBRACKET EQUALS expressionTab SEMICOLON
    (45) expressionTab -> . ID
    (46) expressionTab -> . FLOAT
    (47) expressionTab -> . INTEGER
    (48) expressionTab -> . CHAR

    ID              shift and go to state 101
    FLOAT           shift and go to state 103
    INTEGER         shift and go to state 104
    CHAR            shift and go to state 105

    expressionTab                  shift and go to state 102

state 69

    (59) statement -> type ID . EQUALS expression_arithmetique SEMICOLON

    EQUALS          shift and go to state 106


state 70

    (71) statement -> READ LPAREN . ID RPAREN SEMICOLON
    (72) statement -> READ LPAREN . ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON

    ID              shift and go to state 107


state 71

    (73) statement -> WRITE LPAREN . write_content RPAREN SEMICOLON
    (74) write_content -> . write_item
    (75) write_content -> . write_content COMMA write_item
    (76) write_item -> . ID
    (77) write_item -> . ID LBRACKET INTEGER RBRACKET

    ID              shift and go to state 110

    write_content                  shift and go to state 108
    write_item                     shift and go to state 109

state 72

    (78) statement -> FOR LPAREN . initialisation COLON step COLON BorneSup RPAREN block
    (79) initialisation -> . ID EQUALS INTEGER

    ID              shift and go to state 112

    initialisation                 shift and go to state 111

state 73

    (39) array_declarationTab -> type ID LBRACKET INTEGER . RBRACKET SEMICOLON
    (44) declarationTab -> ID LBRACKET INTEGER . RBRACKET

    RBRACKET        shift and go to state 113


state 74

    (45) expressionTab -> ID .
    (49) factor -> ID . LBRACKET expressionTab RBRACKET
    (55) factor -> ID .

  ! reduce/reduce conflict for COMMA resolved using rule 45 (expressionTab -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 45 (expressionTab -> ID .)
    COMMA           reduce using rule 45 (expressionTab -> ID .)
    SEMICOLON       reduce using rule 45 (expressionTab -> ID .)
    LBRACKET        shift and go to state 83
    AND             reduce using rule 55 (factor -> ID .)
    OR              reduce using rule 55 (factor -> ID .)

  ! COMMA           [ reduce using rule 55 (factor -> ID .) ]
  ! SEMICOLON       [ reduce using rule 55 (factor -> ID .) ]


state 75

    (43) declarationTab -> ID EQUALS expressionTab .

    COMMA           reduce using rule 43 (declarationTab -> ID EQUALS expressionTab .)
    SEMICOLON       reduce using rule 43 (declarationTab -> ID EQUALS expressionTab .)


state 76

    (46) expressionTab -> FLOAT .
    (21) factor -> FLOAT .

  ! reduce/reduce conflict for COMMA resolved using rule 21 (factor -> FLOAT .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 21 (factor -> FLOAT .)
    AND             reduce using rule 21 (factor -> FLOAT .)
    OR              reduce using rule 21 (factor -> FLOAT .)
    COMMA           reduce using rule 21 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 21 (factor -> FLOAT .)

  ! COMMA           [ reduce using rule 46 (expressionTab -> FLOAT .) ]
  ! SEMICOLON       [ reduce using rule 46 (expressionTab -> FLOAT .) ]


state 77

    (47) expressionTab -> INTEGER .
    (20) factor -> INTEGER .

  ! reduce/reduce conflict for COMMA resolved using rule 20 (factor -> INTEGER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 20 (factor -> INTEGER .)
    AND             reduce using rule 20 (factor -> INTEGER .)
    OR              reduce using rule 20 (factor -> INTEGER .)
    COMMA           reduce using rule 20 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 20 (factor -> INTEGER .)

  ! COMMA           [ reduce using rule 47 (expressionTab -> INTEGER .) ]
  ! SEMICOLON       [ reduce using rule 47 (expressionTab -> INTEGER .) ]


state 78

    (48) expressionTab -> CHAR .
    (22) factor -> CHAR .

  ! reduce/reduce conflict for COMMA resolved using rule 22 (factor -> CHAR .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 22 (factor -> CHAR .)
    AND             reduce using rule 22 (factor -> CHAR .)
    OR              reduce using rule 22 (factor -> CHAR .)
    COMMA           reduce using rule 22 (factor -> CHAR .)
    SEMICOLON       reduce using rule 22 (factor -> CHAR .)

  ! COMMA           [ reduce using rule 48 (expressionTab -> CHAR .) ]
  ! SEMICOLON       [ reduce using rule 48 (expressionTab -> CHAR .) ]


state 79

    (12) declaration_list -> declaration COMMA declaration_list .

    SEMICOLON       reduce using rule 12 (declaration_list -> declaration COMMA declaration_list .)


state 80

    (41) declarationTab_listTab -> declarationTab COMMA declarationTab_listTab .

    SEMICOLON       reduce using rule 41 (declarationTab_listTab -> declarationTab COMMA declarationTab_listTab .)


state 81

    (42) declarationTab -> ID .
    (43) declarationTab -> ID . EQUALS expressionTab
    (44) declarationTab -> ID . LBRACKET INTEGER RBRACKET

    COMMA           reduce using rule 42 (declarationTab -> ID .)
    SEMICOLON       reduce using rule 42 (declarationTab -> ID .)
    EQUALS          shift and go to state 114
    LBRACKET        shift and go to state 115


state 82

    (10) declaration -> CONST type ID EQUALS . expression SEMICOLON
    (38) const_declarationTab -> CONST type ID EQUALS . expressionTab SEMICOLON
    (51) expression -> . expression OR term
    (52) expression -> . term
    (45) expressionTab -> . ID
    (46) expressionTab -> . FLOAT
    (47) expressionTab -> . INTEGER
    (48) expressionTab -> . CHAR
    (53) term -> . term AND factor
    (54) term -> . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . CHAR
    (23) factor -> . BOOL
    (24) factor -> . MINUS factor
    (25) factor -> . PLUS factor
    (26) factor -> . LPAREN INTEGER RPAREN
    (27) factor -> . LPAREN FLOAT RPAREN
    (28) factor -> . LPAREN MINUS FLOAT RPAREN
    (49) factor -> . ID LBRACKET expressionTab RBRACKET
    (55) factor -> . ID
    (56) factor -> . TRUE
    (57) factor -> . FALSE
    (58) factor -> . NOT ID

    ID              shift and go to state 74
    FLOAT           shift and go to state 76
    INTEGER         shift and go to state 77
    CHAR            shift and go to state 78
    BOOL            shift and go to state 58
    MINUS           shift and go to state 59
    PLUS            shift and go to state 60
    LPAREN          shift and go to state 61
    TRUE            shift and go to state 62
    FALSE           shift and go to state 63
    NOT             shift and go to state 64

    expression                     shift and go to state 116
    expressionTab                  shift and go to state 117
    term                           shift and go to state 53
    factor                         shift and go to state 54

state 83

    (49) factor -> ID LBRACKET . expressionTab RBRACKET
    (45) expressionTab -> . ID
    (46) expressionTab -> . FLOAT
    (47) expressionTab -> . INTEGER
    (48) expressionTab -> . CHAR

    ID              shift and go to state 101
    FLOAT           shift and go to state 103
    INTEGER         shift and go to state 104
    CHAR            shift and go to state 105

    expressionTab                  shift and go to state 118

state 84

    (51) expression -> expression OR . term
    (53) term -> . term AND factor
    (54) term -> . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . CHAR
    (23) factor -> . BOOL
    (24) factor -> . MINUS factor
    (25) factor -> . PLUS factor
    (26) factor -> . LPAREN INTEGER RPAREN
    (27) factor -> . LPAREN FLOAT RPAREN
    (28) factor -> . LPAREN MINUS FLOAT RPAREN
    (49) factor -> . ID LBRACKET expressionTab RBRACKET
    (55) factor -> . ID
    (56) factor -> . TRUE
    (57) factor -> . FALSE
    (58) factor -> . NOT ID

    INTEGER         shift and go to state 55
    FLOAT           shift and go to state 56
    CHAR            shift and go to state 57
    BOOL            shift and go to state 58
    MINUS           shift and go to state 59
    PLUS            shift and go to state 60
    LPAREN          shift and go to state 61
    ID              shift and go to state 51
    TRUE            shift and go to state 62
    FALSE           shift and go to state 63
    NOT             shift and go to state 64

    term                           shift and go to state 119
    factor                         shift and go to state 54

state 85

    (53) term -> term AND . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . CHAR
    (23) factor -> . BOOL
    (24) factor -> . MINUS factor
    (25) factor -> . PLUS factor
    (26) factor -> . LPAREN INTEGER RPAREN
    (27) factor -> . LPAREN FLOAT RPAREN
    (28) factor -> . LPAREN MINUS FLOAT RPAREN
    (49) factor -> . ID LBRACKET expressionTab RBRACKET
    (55) factor -> . ID
    (56) factor -> . TRUE
    (57) factor -> . FALSE
    (58) factor -> . NOT ID

    INTEGER         shift and go to state 55
    FLOAT           shift and go to state 56
    CHAR            shift and go to state 57
    BOOL            shift and go to state 58
    MINUS           shift and go to state 59
    PLUS            shift and go to state 60
    LPAREN          shift and go to state 61
    ID              shift and go to state 51
    TRUE            shift and go to state 62
    FALSE           shift and go to state 63
    NOT             shift and go to state 64

    factor                         shift and go to state 120

state 86

    (24) factor -> MINUS factor .

    AND             reduce using rule 24 (factor -> MINUS factor .)
    OR              reduce using rule 24 (factor -> MINUS factor .)
    CONST           reduce using rule 24 (factor -> MINUS factor .)
    ID              reduce using rule 24 (factor -> MINUS factor .)
    INT_TYPE        reduce using rule 24 (factor -> MINUS factor .)
    FLOAT_TYPE      reduce using rule 24 (factor -> MINUS factor .)
    BOOL_TYPE       reduce using rule 24 (factor -> MINUS factor .)
    CHAR_TYPE       reduce using rule 24 (factor -> MINUS factor .)
    RBRACE          reduce using rule 24 (factor -> MINUS factor .)
    COMMA           reduce using rule 24 (factor -> MINUS factor .)
    SEMICOLON       reduce using rule 24 (factor -> MINUS factor .)


state 87

    (25) factor -> PLUS factor .

    AND             reduce using rule 25 (factor -> PLUS factor .)
    OR              reduce using rule 25 (factor -> PLUS factor .)
    CONST           reduce using rule 25 (factor -> PLUS factor .)
    ID              reduce using rule 25 (factor -> PLUS factor .)
    INT_TYPE        reduce using rule 25 (factor -> PLUS factor .)
    FLOAT_TYPE      reduce using rule 25 (factor -> PLUS factor .)
    BOOL_TYPE       reduce using rule 25 (factor -> PLUS factor .)
    CHAR_TYPE       reduce using rule 25 (factor -> PLUS factor .)
    RBRACE          reduce using rule 25 (factor -> PLUS factor .)
    COMMA           reduce using rule 25 (factor -> PLUS factor .)
    SEMICOLON       reduce using rule 25 (factor -> PLUS factor .)


state 88

    (26) factor -> LPAREN INTEGER . RPAREN

    RPAREN          shift and go to state 121


state 89

    (27) factor -> LPAREN FLOAT . RPAREN

    RPAREN          shift and go to state 122


state 90

    (28) factor -> LPAREN MINUS . FLOAT RPAREN

    FLOAT           shift and go to state 123


state 91

    (58) factor -> NOT ID .

    AND             reduce using rule 58 (factor -> NOT ID .)
    OR              reduce using rule 58 (factor -> NOT ID .)
    CONST           reduce using rule 58 (factor -> NOT ID .)
    ID              reduce using rule 58 (factor -> NOT ID .)
    INT_TYPE        reduce using rule 58 (factor -> NOT ID .)
    FLOAT_TYPE      reduce using rule 58 (factor -> NOT ID .)
    BOOL_TYPE       reduce using rule 58 (factor -> NOT ID .)
    CHAR_TYPE       reduce using rule 58 (factor -> NOT ID .)
    RBRACE          reduce using rule 58 (factor -> NOT ID .)
    COMMA           reduce using rule 58 (factor -> NOT ID .)
    SEMICOLON       reduce using rule 58 (factor -> NOT ID .)


state 92

    (45) expressionTab -> ID .
    (49) factor -> ID . LBRACKET expressionTab RBRACKET
    (55) factor -> ID .
    (67) factor_arithmetique -> ID .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 45 (expressionTab -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 45 (expressionTab -> ID .)
    SEMICOLON       reduce using rule 45 (expressionTab -> ID .)
    LBRACKET        shift and go to state 83
    AND             reduce using rule 55 (factor -> ID .)
    OR              reduce using rule 55 (factor -> ID .)
    MULTIPLY        reduce using rule 67 (factor_arithmetique -> ID .)
    DIVIDE          reduce using rule 67 (factor_arithmetique -> ID .)
    PLUS            reduce using rule 67 (factor_arithmetique -> ID .)
    MINUS           reduce using rule 67 (factor_arithmetique -> ID .)

  ! SEMICOLON       [ reduce using rule 55 (factor -> ID .) ]
  ! SEMICOLON       [ reduce using rule 67 (factor_arithmetique -> ID .) ]


state 93

    (15) statement -> ID EQUALS expression . SEMICOLON
    (51) expression -> expression . OR term

    SEMICOLON       shift and go to state 124
    OR              shift and go to state 84


state 94

    (60) statement -> ID EQUALS expression_arithmetique . SEMICOLON
    (61) expression_arithmetique -> expression_arithmetique . PLUS term_arithmetique
    (62) expression_arithmetique -> expression_arithmetique . MINUS term_arithmetique

    SEMICOLON       shift and go to state 125
    PLUS            shift and go to state 126
    MINUS           shift and go to state 127


state 95

    (37) simple_assignment -> ID EQUALS expressionTab . SEMICOLON

    SEMICOLON       shift and go to state 128


state 96

    (63) expression_arithmetique -> term_arithmetique .
    (64) term_arithmetique -> term_arithmetique . MULTIPLY term_arithmetique
    (65) term_arithmetique -> term_arithmetique . DIVIDE factor_arithmetique

    SEMICOLON       reduce using rule 63 (expression_arithmetique -> term_arithmetique .)
    PLUS            reduce using rule 63 (expression_arithmetique -> term_arithmetique .)
    MINUS           reduce using rule 63 (expression_arithmetique -> term_arithmetique .)
    RPAREN          reduce using rule 63 (expression_arithmetique -> term_arithmetique .)
    MULTIPLY        shift and go to state 129
    DIVIDE          shift and go to state 130


state 97

    (46) expressionTab -> FLOAT .
    (21) factor -> FLOAT .
    (69) factor_arithmetique -> FLOAT .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 21 (factor -> FLOAT .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 21 (factor -> FLOAT .)
    AND             reduce using rule 21 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 21 (factor -> FLOAT .)
    OR              reduce using rule 21 (factor -> FLOAT .)
    MULTIPLY        reduce using rule 69 (factor_arithmetique -> FLOAT .)
    DIVIDE          reduce using rule 69 (factor_arithmetique -> FLOAT .)
    PLUS            reduce using rule 69 (factor_arithmetique -> FLOAT .)
    MINUS           reduce using rule 69 (factor_arithmetique -> FLOAT .)

  ! SEMICOLON       [ reduce using rule 46 (expressionTab -> FLOAT .) ]
  ! SEMICOLON       [ reduce using rule 69 (factor_arithmetique -> FLOAT .) ]


state 98

    (47) expressionTab -> INTEGER .
    (20) factor -> INTEGER .
    (68) factor_arithmetique -> INTEGER .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 20 (factor -> INTEGER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 20 (factor -> INTEGER .)
    AND             reduce using rule 20 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 20 (factor -> INTEGER .)
    OR              reduce using rule 20 (factor -> INTEGER .)
    MULTIPLY        reduce using rule 68 (factor_arithmetique -> INTEGER .)
    DIVIDE          reduce using rule 68 (factor_arithmetique -> INTEGER .)
    PLUS            reduce using rule 68 (factor_arithmetique -> INTEGER .)
    MINUS           reduce using rule 68 (factor_arithmetique -> INTEGER .)

  ! SEMICOLON       [ reduce using rule 47 (expressionTab -> INTEGER .) ]
  ! SEMICOLON       [ reduce using rule 68 (factor_arithmetique -> INTEGER .) ]


state 99

    (66) term_arithmetique -> factor_arithmetique .

    MULTIPLY        reduce using rule 66 (term_arithmetique -> factor_arithmetique .)
    DIVIDE          reduce using rule 66 (term_arithmetique -> factor_arithmetique .)
    SEMICOLON       reduce using rule 66 (term_arithmetique -> factor_arithmetique .)
    PLUS            reduce using rule 66 (term_arithmetique -> factor_arithmetique .)
    MINUS           reduce using rule 66 (term_arithmetique -> factor_arithmetique .)
    RPAREN          reduce using rule 66 (term_arithmetique -> factor_arithmetique .)


state 100

    (26) factor -> LPAREN . INTEGER RPAREN
    (27) factor -> LPAREN . FLOAT RPAREN
    (28) factor -> LPAREN . MINUS FLOAT RPAREN
    (70) factor_arithmetique -> LPAREN . expression_arithmetique RPAREN
    (61) expression_arithmetique -> . expression_arithmetique PLUS term_arithmetique
    (62) expression_arithmetique -> . expression_arithmetique MINUS term_arithmetique
    (63) expression_arithmetique -> . term_arithmetique
    (64) term_arithmetique -> . term_arithmetique MULTIPLY term_arithmetique
    (65) term_arithmetique -> . term_arithmetique DIVIDE factor_arithmetique
    (66) term_arithmetique -> . factor_arithmetique
    (67) factor_arithmetique -> . ID
    (68) factor_arithmetique -> . INTEGER
    (69) factor_arithmetique -> . FLOAT
    (70) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN

    INTEGER         shift and go to state 132
    FLOAT           shift and go to state 133
    MINUS           shift and go to state 90
    ID              shift and go to state 135
    LPAREN          shift and go to state 131

    expression_arithmetique        shift and go to state 134
    term_arithmetique              shift and go to state 96
    factor_arithmetique            shift and go to state 99

state 101

    (45) expressionTab -> ID .

    RBRACKET        reduce using rule 45 (expressionTab -> ID .)
    COMMA           reduce using rule 45 (expressionTab -> ID .)
    SEMICOLON       reduce using rule 45 (expressionTab -> ID .)


state 102

    (50) array_assignment -> ID LBRACKET expressionTab . RBRACKET EQUALS expressionTab SEMICOLON

    RBRACKET        shift and go to state 136


state 103

    (46) expressionTab -> FLOAT .

    RBRACKET        reduce using rule 46 (expressionTab -> FLOAT .)
    COMMA           reduce using rule 46 (expressionTab -> FLOAT .)
    SEMICOLON       reduce using rule 46 (expressionTab -> FLOAT .)


state 104

    (47) expressionTab -> INTEGER .

    RBRACKET        reduce using rule 47 (expressionTab -> INTEGER .)
    COMMA           reduce using rule 47 (expressionTab -> INTEGER .)
    SEMICOLON       reduce using rule 47 (expressionTab -> INTEGER .)


state 105

    (48) expressionTab -> CHAR .

    RBRACKET        reduce using rule 48 (expressionTab -> CHAR .)
    COMMA           reduce using rule 48 (expressionTab -> CHAR .)
    SEMICOLON       reduce using rule 48 (expressionTab -> CHAR .)


state 106

    (59) statement -> type ID EQUALS . expression_arithmetique SEMICOLON
    (61) expression_arithmetique -> . expression_arithmetique PLUS term_arithmetique
    (62) expression_arithmetique -> . expression_arithmetique MINUS term_arithmetique
    (63) expression_arithmetique -> . term_arithmetique
    (64) term_arithmetique -> . term_arithmetique MULTIPLY term_arithmetique
    (65) term_arithmetique -> . term_arithmetique DIVIDE factor_arithmetique
    (66) term_arithmetique -> . factor_arithmetique
    (67) factor_arithmetique -> . ID
    (68) factor_arithmetique -> . INTEGER
    (69) factor_arithmetique -> . FLOAT
    (70) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN

    ID              shift and go to state 135
    INTEGER         shift and go to state 138
    FLOAT           shift and go to state 139
    LPAREN          shift and go to state 131

    expression_arithmetique        shift and go to state 137
    term_arithmetique              shift and go to state 96
    factor_arithmetique            shift and go to state 99

state 107

    (71) statement -> READ LPAREN ID . RPAREN SEMICOLON
    (72) statement -> READ LPAREN ID . LBRACKET INTEGER RBRACKET RPAREN SEMICOLON

    RPAREN          shift and go to state 140
    LBRACKET        shift and go to state 141


state 108

    (73) statement -> WRITE LPAREN write_content . RPAREN SEMICOLON
    (75) write_content -> write_content . COMMA write_item

    RPAREN          shift and go to state 142
    COMMA           shift and go to state 143


state 109

    (74) write_content -> write_item .

    RPAREN          reduce using rule 74 (write_content -> write_item .)
    COMMA           reduce using rule 74 (write_content -> write_item .)


state 110

    (76) write_item -> ID .
    (77) write_item -> ID . LBRACKET INTEGER RBRACKET

    RPAREN          reduce using rule 76 (write_item -> ID .)
    COMMA           reduce using rule 76 (write_item -> ID .)
    LBRACKET        shift and go to state 144


state 111

    (78) statement -> FOR LPAREN initialisation . COLON step COLON BorneSup RPAREN block

    COLON           shift and go to state 145


state 112

    (79) initialisation -> ID . EQUALS INTEGER

    EQUALS          shift and go to state 146


state 113

    (39) array_declarationTab -> type ID LBRACKET INTEGER RBRACKET . SEMICOLON
    (44) declarationTab -> ID LBRACKET INTEGER RBRACKET .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 147
    COMMA           reduce using rule 44 (declarationTab -> ID LBRACKET INTEGER RBRACKET .)

  ! SEMICOLON       [ reduce using rule 44 (declarationTab -> ID LBRACKET INTEGER RBRACKET .) ]


state 114

    (43) declarationTab -> ID EQUALS . expressionTab
    (45) expressionTab -> . ID
    (46) expressionTab -> . FLOAT
    (47) expressionTab -> . INTEGER
    (48) expressionTab -> . CHAR

    ID              shift and go to state 101
    FLOAT           shift and go to state 103
    INTEGER         shift and go to state 104
    CHAR            shift and go to state 105

    expressionTab                  shift and go to state 75

state 115

    (44) declarationTab -> ID LBRACKET . INTEGER RBRACKET

    INTEGER         shift and go to state 148


state 116

    (10) declaration -> CONST type ID EQUALS expression . SEMICOLON
    (51) expression -> expression . OR term

    SEMICOLON       shift and go to state 149
    OR              shift and go to state 84


state 117

    (38) const_declarationTab -> CONST type ID EQUALS expressionTab . SEMICOLON

    SEMICOLON       shift and go to state 150


state 118

    (49) factor -> ID LBRACKET expressionTab . RBRACKET

    RBRACKET        shift and go to state 151


state 119

    (51) expression -> expression OR term .
    (53) term -> term . AND factor

    OR              reduce using rule 51 (expression -> expression OR term .)
    CONST           reduce using rule 51 (expression -> expression OR term .)
    ID              reduce using rule 51 (expression -> expression OR term .)
    INT_TYPE        reduce using rule 51 (expression -> expression OR term .)
    FLOAT_TYPE      reduce using rule 51 (expression -> expression OR term .)
    BOOL_TYPE       reduce using rule 51 (expression -> expression OR term .)
    CHAR_TYPE       reduce using rule 51 (expression -> expression OR term .)
    RBRACE          reduce using rule 51 (expression -> expression OR term .)
    COMMA           reduce using rule 51 (expression -> expression OR term .)
    SEMICOLON       reduce using rule 51 (expression -> expression OR term .)
    AND             shift and go to state 85


state 120

    (53) term -> term AND factor .

    AND             reduce using rule 53 (term -> term AND factor .)
    OR              reduce using rule 53 (term -> term AND factor .)
    CONST           reduce using rule 53 (term -> term AND factor .)
    ID              reduce using rule 53 (term -> term AND factor .)
    INT_TYPE        reduce using rule 53 (term -> term AND factor .)
    FLOAT_TYPE      reduce using rule 53 (term -> term AND factor .)
    BOOL_TYPE       reduce using rule 53 (term -> term AND factor .)
    CHAR_TYPE       reduce using rule 53 (term -> term AND factor .)
    RBRACE          reduce using rule 53 (term -> term AND factor .)
    COMMA           reduce using rule 53 (term -> term AND factor .)
    SEMICOLON       reduce using rule 53 (term -> term AND factor .)


state 121

    (26) factor -> LPAREN INTEGER RPAREN .

    AND             reduce using rule 26 (factor -> LPAREN INTEGER RPAREN .)
    OR              reduce using rule 26 (factor -> LPAREN INTEGER RPAREN .)
    CONST           reduce using rule 26 (factor -> LPAREN INTEGER RPAREN .)
    ID              reduce using rule 26 (factor -> LPAREN INTEGER RPAREN .)
    INT_TYPE        reduce using rule 26 (factor -> LPAREN INTEGER RPAREN .)
    FLOAT_TYPE      reduce using rule 26 (factor -> LPAREN INTEGER RPAREN .)
    BOOL_TYPE       reduce using rule 26 (factor -> LPAREN INTEGER RPAREN .)
    CHAR_TYPE       reduce using rule 26 (factor -> LPAREN INTEGER RPAREN .)
    RBRACE          reduce using rule 26 (factor -> LPAREN INTEGER RPAREN .)
    COMMA           reduce using rule 26 (factor -> LPAREN INTEGER RPAREN .)
    SEMICOLON       reduce using rule 26 (factor -> LPAREN INTEGER RPAREN .)


state 122

    (27) factor -> LPAREN FLOAT RPAREN .

    AND             reduce using rule 27 (factor -> LPAREN FLOAT RPAREN .)
    OR              reduce using rule 27 (factor -> LPAREN FLOAT RPAREN .)
    CONST           reduce using rule 27 (factor -> LPAREN FLOAT RPAREN .)
    ID              reduce using rule 27 (factor -> LPAREN FLOAT RPAREN .)
    INT_TYPE        reduce using rule 27 (factor -> LPAREN FLOAT RPAREN .)
    FLOAT_TYPE      reduce using rule 27 (factor -> LPAREN FLOAT RPAREN .)
    BOOL_TYPE       reduce using rule 27 (factor -> LPAREN FLOAT RPAREN .)
    CHAR_TYPE       reduce using rule 27 (factor -> LPAREN FLOAT RPAREN .)
    RBRACE          reduce using rule 27 (factor -> LPAREN FLOAT RPAREN .)
    COMMA           reduce using rule 27 (factor -> LPAREN FLOAT RPAREN .)
    SEMICOLON       reduce using rule 27 (factor -> LPAREN FLOAT RPAREN .)


state 123

    (28) factor -> LPAREN MINUS FLOAT . RPAREN

    RPAREN          shift and go to state 152


state 124

    (15) statement -> ID EQUALS expression SEMICOLON .

    ID              reduce using rule 15 (statement -> ID EQUALS expression SEMICOLON .)
    READ            reduce using rule 15 (statement -> ID EQUALS expression SEMICOLON .)
    WRITE           reduce using rule 15 (statement -> ID EQUALS expression SEMICOLON .)
    FOR             reduce using rule 15 (statement -> ID EQUALS expression SEMICOLON .)
    INT_TYPE        reduce using rule 15 (statement -> ID EQUALS expression SEMICOLON .)
    FLOAT_TYPE      reduce using rule 15 (statement -> ID EQUALS expression SEMICOLON .)
    BOOL_TYPE       reduce using rule 15 (statement -> ID EQUALS expression SEMICOLON .)
    CHAR_TYPE       reduce using rule 15 (statement -> ID EQUALS expression SEMICOLON .)
    RBRACE          reduce using rule 15 (statement -> ID EQUALS expression SEMICOLON .)


state 125

    (60) statement -> ID EQUALS expression_arithmetique SEMICOLON .

    ID              reduce using rule 60 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    READ            reduce using rule 60 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    WRITE           reduce using rule 60 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    FOR             reduce using rule 60 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    INT_TYPE        reduce using rule 60 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    FLOAT_TYPE      reduce using rule 60 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    BOOL_TYPE       reduce using rule 60 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    CHAR_TYPE       reduce using rule 60 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    RBRACE          reduce using rule 60 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)


state 126

    (61) expression_arithmetique -> expression_arithmetique PLUS . term_arithmetique
    (64) term_arithmetique -> . term_arithmetique MULTIPLY term_arithmetique
    (65) term_arithmetique -> . term_arithmetique DIVIDE factor_arithmetique
    (66) term_arithmetique -> . factor_arithmetique
    (67) factor_arithmetique -> . ID
    (68) factor_arithmetique -> . INTEGER
    (69) factor_arithmetique -> . FLOAT
    (70) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN

    ID              shift and go to state 135
    INTEGER         shift and go to state 138
    FLOAT           shift and go to state 139
    LPAREN          shift and go to state 131

    term_arithmetique              shift and go to state 153
    factor_arithmetique            shift and go to state 99

state 127

    (62) expression_arithmetique -> expression_arithmetique MINUS . term_arithmetique
    (64) term_arithmetique -> . term_arithmetique MULTIPLY term_arithmetique
    (65) term_arithmetique -> . term_arithmetique DIVIDE factor_arithmetique
    (66) term_arithmetique -> . factor_arithmetique
    (67) factor_arithmetique -> . ID
    (68) factor_arithmetique -> . INTEGER
    (69) factor_arithmetique -> . FLOAT
    (70) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN

    ID              shift and go to state 135
    INTEGER         shift and go to state 138
    FLOAT           shift and go to state 139
    LPAREN          shift and go to state 131

    term_arithmetique              shift and go to state 154
    factor_arithmetique            shift and go to state 99

state 128

    (37) simple_assignment -> ID EQUALS expressionTab SEMICOLON .

    ID              reduce using rule 37 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    READ            reduce using rule 37 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    WRITE           reduce using rule 37 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    FOR             reduce using rule 37 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    INT_TYPE        reduce using rule 37 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    FLOAT_TYPE      reduce using rule 37 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    BOOL_TYPE       reduce using rule 37 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    CHAR_TYPE       reduce using rule 37 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    RBRACE          reduce using rule 37 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)


state 129

    (64) term_arithmetique -> term_arithmetique MULTIPLY . term_arithmetique
    (64) term_arithmetique -> . term_arithmetique MULTIPLY term_arithmetique
    (65) term_arithmetique -> . term_arithmetique DIVIDE factor_arithmetique
    (66) term_arithmetique -> . factor_arithmetique
    (67) factor_arithmetique -> . ID
    (68) factor_arithmetique -> . INTEGER
    (69) factor_arithmetique -> . FLOAT
    (70) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN

    ID              shift and go to state 135
    INTEGER         shift and go to state 138
    FLOAT           shift and go to state 139
    LPAREN          shift and go to state 131

    term_arithmetique              shift and go to state 155
    factor_arithmetique            shift and go to state 99

state 130

    (65) term_arithmetique -> term_arithmetique DIVIDE . factor_arithmetique
    (67) factor_arithmetique -> . ID
    (68) factor_arithmetique -> . INTEGER
    (69) factor_arithmetique -> . FLOAT
    (70) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN

    ID              shift and go to state 135
    INTEGER         shift and go to state 138
    FLOAT           shift and go to state 139
    LPAREN          shift and go to state 131

    factor_arithmetique            shift and go to state 156

state 131

    (70) factor_arithmetique -> LPAREN . expression_arithmetique RPAREN
    (61) expression_arithmetique -> . expression_arithmetique PLUS term_arithmetique
    (62) expression_arithmetique -> . expression_arithmetique MINUS term_arithmetique
    (63) expression_arithmetique -> . term_arithmetique
    (64) term_arithmetique -> . term_arithmetique MULTIPLY term_arithmetique
    (65) term_arithmetique -> . term_arithmetique DIVIDE factor_arithmetique
    (66) term_arithmetique -> . factor_arithmetique
    (67) factor_arithmetique -> . ID
    (68) factor_arithmetique -> . INTEGER
    (69) factor_arithmetique -> . FLOAT
    (70) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN

    ID              shift and go to state 135
    INTEGER         shift and go to state 138
    FLOAT           shift and go to state 139
    LPAREN          shift and go to state 131

    expression_arithmetique        shift and go to state 134
    term_arithmetique              shift and go to state 96
    factor_arithmetique            shift and go to state 99

state 132

    (26) factor -> LPAREN INTEGER . RPAREN
    (68) factor_arithmetique -> INTEGER .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 121
    MULTIPLY        reduce using rule 68 (factor_arithmetique -> INTEGER .)
    DIVIDE          reduce using rule 68 (factor_arithmetique -> INTEGER .)
    PLUS            reduce using rule 68 (factor_arithmetique -> INTEGER .)
    MINUS           reduce using rule 68 (factor_arithmetique -> INTEGER .)

  ! RPAREN          [ reduce using rule 68 (factor_arithmetique -> INTEGER .) ]


state 133

    (27) factor -> LPAREN FLOAT . RPAREN
    (69) factor_arithmetique -> FLOAT .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 122
    MULTIPLY        reduce using rule 69 (factor_arithmetique -> FLOAT .)
    DIVIDE          reduce using rule 69 (factor_arithmetique -> FLOAT .)
    PLUS            reduce using rule 69 (factor_arithmetique -> FLOAT .)
    MINUS           reduce using rule 69 (factor_arithmetique -> FLOAT .)

  ! RPAREN          [ reduce using rule 69 (factor_arithmetique -> FLOAT .) ]


state 134

    (70) factor_arithmetique -> LPAREN expression_arithmetique . RPAREN
    (61) expression_arithmetique -> expression_arithmetique . PLUS term_arithmetique
    (62) expression_arithmetique -> expression_arithmetique . MINUS term_arithmetique

    RPAREN          shift and go to state 157
    PLUS            shift and go to state 126
    MINUS           shift and go to state 127


state 135

    (67) factor_arithmetique -> ID .

    MULTIPLY        reduce using rule 67 (factor_arithmetique -> ID .)
    DIVIDE          reduce using rule 67 (factor_arithmetique -> ID .)
    RPAREN          reduce using rule 67 (factor_arithmetique -> ID .)
    PLUS            reduce using rule 67 (factor_arithmetique -> ID .)
    MINUS           reduce using rule 67 (factor_arithmetique -> ID .)
    SEMICOLON       reduce using rule 67 (factor_arithmetique -> ID .)


state 136

    (50) array_assignment -> ID LBRACKET expressionTab RBRACKET . EQUALS expressionTab SEMICOLON

    EQUALS          shift and go to state 158


state 137

    (59) statement -> type ID EQUALS expression_arithmetique . SEMICOLON
    (61) expression_arithmetique -> expression_arithmetique . PLUS term_arithmetique
    (62) expression_arithmetique -> expression_arithmetique . MINUS term_arithmetique

    SEMICOLON       shift and go to state 159
    PLUS            shift and go to state 126
    MINUS           shift and go to state 127


state 138

    (68) factor_arithmetique -> INTEGER .

    MULTIPLY        reduce using rule 68 (factor_arithmetique -> INTEGER .)
    DIVIDE          reduce using rule 68 (factor_arithmetique -> INTEGER .)
    SEMICOLON       reduce using rule 68 (factor_arithmetique -> INTEGER .)
    PLUS            reduce using rule 68 (factor_arithmetique -> INTEGER .)
    MINUS           reduce using rule 68 (factor_arithmetique -> INTEGER .)
    RPAREN          reduce using rule 68 (factor_arithmetique -> INTEGER .)


state 139

    (69) factor_arithmetique -> FLOAT .

    MULTIPLY        reduce using rule 69 (factor_arithmetique -> FLOAT .)
    DIVIDE          reduce using rule 69 (factor_arithmetique -> FLOAT .)
    SEMICOLON       reduce using rule 69 (factor_arithmetique -> FLOAT .)
    PLUS            reduce using rule 69 (factor_arithmetique -> FLOAT .)
    MINUS           reduce using rule 69 (factor_arithmetique -> FLOAT .)
    RPAREN          reduce using rule 69 (factor_arithmetique -> FLOAT .)


state 140

    (71) statement -> READ LPAREN ID RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 160


state 141

    (72) statement -> READ LPAREN ID LBRACKET . INTEGER RBRACKET RPAREN SEMICOLON

    INTEGER         shift and go to state 161


state 142

    (73) statement -> WRITE LPAREN write_content RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 162


state 143

    (75) write_content -> write_content COMMA . write_item
    (76) write_item -> . ID
    (77) write_item -> . ID LBRACKET INTEGER RBRACKET

    ID              shift and go to state 110

    write_item                     shift and go to state 163

state 144

    (77) write_item -> ID LBRACKET . INTEGER RBRACKET

    INTEGER         shift and go to state 164


state 145

    (78) statement -> FOR LPAREN initialisation COLON . step COLON BorneSup RPAREN block
    (80) step -> . INTEGER
    (81) step -> . ID

    INTEGER         shift and go to state 166
    ID              shift and go to state 167

    step                           shift and go to state 165

state 146

    (79) initialisation -> ID EQUALS . INTEGER

    INTEGER         shift and go to state 168


state 147

    (39) array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .

    CONST           reduce using rule 39 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    ID              reduce using rule 39 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    INT_TYPE        reduce using rule 39 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    FLOAT_TYPE      reduce using rule 39 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    BOOL_TYPE       reduce using rule 39 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    CHAR_TYPE       reduce using rule 39 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    RBRACE          reduce using rule 39 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    COMMA           reduce using rule 39 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 39 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)


state 148

    (44) declarationTab -> ID LBRACKET INTEGER . RBRACKET

    RBRACKET        shift and go to state 169


state 149

    (10) declaration -> CONST type ID EQUALS expression SEMICOLON .

    CONST           reduce using rule 10 (declaration -> CONST type ID EQUALS expression SEMICOLON .)
    ID              reduce using rule 10 (declaration -> CONST type ID EQUALS expression SEMICOLON .)
    INT_TYPE        reduce using rule 10 (declaration -> CONST type ID EQUALS expression SEMICOLON .)
    FLOAT_TYPE      reduce using rule 10 (declaration -> CONST type ID EQUALS expression SEMICOLON .)
    BOOL_TYPE       reduce using rule 10 (declaration -> CONST type ID EQUALS expression SEMICOLON .)
    CHAR_TYPE       reduce using rule 10 (declaration -> CONST type ID EQUALS expression SEMICOLON .)
    RBRACE          reduce using rule 10 (declaration -> CONST type ID EQUALS expression SEMICOLON .)
    COMMA           reduce using rule 10 (declaration -> CONST type ID EQUALS expression SEMICOLON .)
    SEMICOLON       reduce using rule 10 (declaration -> CONST type ID EQUALS expression SEMICOLON .)


state 150

    (38) const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .

    CONST           reduce using rule 38 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    ID              reduce using rule 38 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    INT_TYPE        reduce using rule 38 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    FLOAT_TYPE      reduce using rule 38 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    BOOL_TYPE       reduce using rule 38 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    CHAR_TYPE       reduce using rule 38 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    RBRACE          reduce using rule 38 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    COMMA           reduce using rule 38 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    SEMICOLON       reduce using rule 38 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)


state 151

    (49) factor -> ID LBRACKET expressionTab RBRACKET .

    AND             reduce using rule 49 (factor -> ID LBRACKET expressionTab RBRACKET .)
    OR              reduce using rule 49 (factor -> ID LBRACKET expressionTab RBRACKET .)
    CONST           reduce using rule 49 (factor -> ID LBRACKET expressionTab RBRACKET .)
    ID              reduce using rule 49 (factor -> ID LBRACKET expressionTab RBRACKET .)
    INT_TYPE        reduce using rule 49 (factor -> ID LBRACKET expressionTab RBRACKET .)
    FLOAT_TYPE      reduce using rule 49 (factor -> ID LBRACKET expressionTab RBRACKET .)
    BOOL_TYPE       reduce using rule 49 (factor -> ID LBRACKET expressionTab RBRACKET .)
    CHAR_TYPE       reduce using rule 49 (factor -> ID LBRACKET expressionTab RBRACKET .)
    RBRACE          reduce using rule 49 (factor -> ID LBRACKET expressionTab RBRACKET .)
    COMMA           reduce using rule 49 (factor -> ID LBRACKET expressionTab RBRACKET .)
    SEMICOLON       reduce using rule 49 (factor -> ID LBRACKET expressionTab RBRACKET .)


state 152

    (28) factor -> LPAREN MINUS FLOAT RPAREN .

    AND             reduce using rule 28 (factor -> LPAREN MINUS FLOAT RPAREN .)
    OR              reduce using rule 28 (factor -> LPAREN MINUS FLOAT RPAREN .)
    CONST           reduce using rule 28 (factor -> LPAREN MINUS FLOAT RPAREN .)
    ID              reduce using rule 28 (factor -> LPAREN MINUS FLOAT RPAREN .)
    INT_TYPE        reduce using rule 28 (factor -> LPAREN MINUS FLOAT RPAREN .)
    FLOAT_TYPE      reduce using rule 28 (factor -> LPAREN MINUS FLOAT RPAREN .)
    BOOL_TYPE       reduce using rule 28 (factor -> LPAREN MINUS FLOAT RPAREN .)
    CHAR_TYPE       reduce using rule 28 (factor -> LPAREN MINUS FLOAT RPAREN .)
    RBRACE          reduce using rule 28 (factor -> LPAREN MINUS FLOAT RPAREN .)
    COMMA           reduce using rule 28 (factor -> LPAREN MINUS FLOAT RPAREN .)
    SEMICOLON       reduce using rule 28 (factor -> LPAREN MINUS FLOAT RPAREN .)


state 153

    (61) expression_arithmetique -> expression_arithmetique PLUS term_arithmetique .
    (64) term_arithmetique -> term_arithmetique . MULTIPLY term_arithmetique
    (65) term_arithmetique -> term_arithmetique . DIVIDE factor_arithmetique

    SEMICOLON       reduce using rule 61 (expression_arithmetique -> expression_arithmetique PLUS term_arithmetique .)
    PLUS            reduce using rule 61 (expression_arithmetique -> expression_arithmetique PLUS term_arithmetique .)
    MINUS           reduce using rule 61 (expression_arithmetique -> expression_arithmetique PLUS term_arithmetique .)
    RPAREN          reduce using rule 61 (expression_arithmetique -> expression_arithmetique PLUS term_arithmetique .)
    MULTIPLY        shift and go to state 129
    DIVIDE          shift and go to state 130


state 154

    (62) expression_arithmetique -> expression_arithmetique MINUS term_arithmetique .
    (64) term_arithmetique -> term_arithmetique . MULTIPLY term_arithmetique
    (65) term_arithmetique -> term_arithmetique . DIVIDE factor_arithmetique

    SEMICOLON       reduce using rule 62 (expression_arithmetique -> expression_arithmetique MINUS term_arithmetique .)
    PLUS            reduce using rule 62 (expression_arithmetique -> expression_arithmetique MINUS term_arithmetique .)
    MINUS           reduce using rule 62 (expression_arithmetique -> expression_arithmetique MINUS term_arithmetique .)
    RPAREN          reduce using rule 62 (expression_arithmetique -> expression_arithmetique MINUS term_arithmetique .)
    MULTIPLY        shift and go to state 129
    DIVIDE          shift and go to state 130


state 155

    (64) term_arithmetique -> term_arithmetique MULTIPLY term_arithmetique .
    (64) term_arithmetique -> term_arithmetique . MULTIPLY term_arithmetique
    (65) term_arithmetique -> term_arithmetique . DIVIDE factor_arithmetique

  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    SEMICOLON       reduce using rule 64 (term_arithmetique -> term_arithmetique MULTIPLY term_arithmetique .)
    PLUS            reduce using rule 64 (term_arithmetique -> term_arithmetique MULTIPLY term_arithmetique .)
    MINUS           reduce using rule 64 (term_arithmetique -> term_arithmetique MULTIPLY term_arithmetique .)
    RPAREN          reduce using rule 64 (term_arithmetique -> term_arithmetique MULTIPLY term_arithmetique .)
    MULTIPLY        shift and go to state 129
    DIVIDE          shift and go to state 130

  ! MULTIPLY        [ reduce using rule 64 (term_arithmetique -> term_arithmetique MULTIPLY term_arithmetique .) ]
  ! DIVIDE          [ reduce using rule 64 (term_arithmetique -> term_arithmetique MULTIPLY term_arithmetique .) ]


state 156

    (65) term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique .

    MULTIPLY        reduce using rule 65 (term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique .)
    DIVIDE          reduce using rule 65 (term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique .)
    SEMICOLON       reduce using rule 65 (term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique .)
    PLUS            reduce using rule 65 (term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique .)
    MINUS           reduce using rule 65 (term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique .)
    RPAREN          reduce using rule 65 (term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique .)


state 157

    (70) factor_arithmetique -> LPAREN expression_arithmetique RPAREN .

    MULTIPLY        reduce using rule 70 (factor_arithmetique -> LPAREN expression_arithmetique RPAREN .)
    DIVIDE          reduce using rule 70 (factor_arithmetique -> LPAREN expression_arithmetique RPAREN .)
    SEMICOLON       reduce using rule 70 (factor_arithmetique -> LPAREN expression_arithmetique RPAREN .)
    PLUS            reduce using rule 70 (factor_arithmetique -> LPAREN expression_arithmetique RPAREN .)
    MINUS           reduce using rule 70 (factor_arithmetique -> LPAREN expression_arithmetique RPAREN .)
    RPAREN          reduce using rule 70 (factor_arithmetique -> LPAREN expression_arithmetique RPAREN .)


state 158

    (50) array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS . expressionTab SEMICOLON
    (45) expressionTab -> . ID
    (46) expressionTab -> . FLOAT
    (47) expressionTab -> . INTEGER
    (48) expressionTab -> . CHAR

    ID              shift and go to state 101
    FLOAT           shift and go to state 103
    INTEGER         shift and go to state 104
    CHAR            shift and go to state 105

    expressionTab                  shift and go to state 170

state 159

    (59) statement -> type ID EQUALS expression_arithmetique SEMICOLON .

    ID              reduce using rule 59 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    READ            reduce using rule 59 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    WRITE           reduce using rule 59 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    FOR             reduce using rule 59 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    INT_TYPE        reduce using rule 59 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    FLOAT_TYPE      reduce using rule 59 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    BOOL_TYPE       reduce using rule 59 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    CHAR_TYPE       reduce using rule 59 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    RBRACE          reduce using rule 59 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)


state 160

    (71) statement -> READ LPAREN ID RPAREN SEMICOLON .

    ID              reduce using rule 71 (statement -> READ LPAREN ID RPAREN SEMICOLON .)
    READ            reduce using rule 71 (statement -> READ LPAREN ID RPAREN SEMICOLON .)
    WRITE           reduce using rule 71 (statement -> READ LPAREN ID RPAREN SEMICOLON .)
    FOR             reduce using rule 71 (statement -> READ LPAREN ID RPAREN SEMICOLON .)
    INT_TYPE        reduce using rule 71 (statement -> READ LPAREN ID RPAREN SEMICOLON .)
    FLOAT_TYPE      reduce using rule 71 (statement -> READ LPAREN ID RPAREN SEMICOLON .)
    BOOL_TYPE       reduce using rule 71 (statement -> READ LPAREN ID RPAREN SEMICOLON .)
    CHAR_TYPE       reduce using rule 71 (statement -> READ LPAREN ID RPAREN SEMICOLON .)
    RBRACE          reduce using rule 71 (statement -> READ LPAREN ID RPAREN SEMICOLON .)


state 161

    (72) statement -> READ LPAREN ID LBRACKET INTEGER . RBRACKET RPAREN SEMICOLON

    RBRACKET        shift and go to state 171


state 162

    (73) statement -> WRITE LPAREN write_content RPAREN SEMICOLON .

    ID              reduce using rule 73 (statement -> WRITE LPAREN write_content RPAREN SEMICOLON .)
    READ            reduce using rule 73 (statement -> WRITE LPAREN write_content RPAREN SEMICOLON .)
    WRITE           reduce using rule 73 (statement -> WRITE LPAREN write_content RPAREN SEMICOLON .)
    FOR             reduce using rule 73 (statement -> WRITE LPAREN write_content RPAREN SEMICOLON .)
    INT_TYPE        reduce using rule 73 (statement -> WRITE LPAREN write_content RPAREN SEMICOLON .)
    FLOAT_TYPE      reduce using rule 73 (statement -> WRITE LPAREN write_content RPAREN SEMICOLON .)
    BOOL_TYPE       reduce using rule 73 (statement -> WRITE LPAREN write_content RPAREN SEMICOLON .)
    CHAR_TYPE       reduce using rule 73 (statement -> WRITE LPAREN write_content RPAREN SEMICOLON .)
    RBRACE          reduce using rule 73 (statement -> WRITE LPAREN write_content RPAREN SEMICOLON .)


state 163

    (75) write_content -> write_content COMMA write_item .

    RPAREN          reduce using rule 75 (write_content -> write_content COMMA write_item .)
    COMMA           reduce using rule 75 (write_content -> write_content COMMA write_item .)


state 164

    (77) write_item -> ID LBRACKET INTEGER . RBRACKET

    RBRACKET        shift and go to state 172


state 165

    (78) statement -> FOR LPAREN initialisation COLON step . COLON BorneSup RPAREN block

    COLON           shift and go to state 173


state 166

    (80) step -> INTEGER .

    COLON           reduce using rule 80 (step -> INTEGER .)


state 167

    (81) step -> ID .

    COLON           reduce using rule 81 (step -> ID .)


state 168

    (79) initialisation -> ID EQUALS INTEGER .

    COLON           reduce using rule 79 (initialisation -> ID EQUALS INTEGER .)


state 169

    (44) declarationTab -> ID LBRACKET INTEGER RBRACKET .

    COMMA           reduce using rule 44 (declarationTab -> ID LBRACKET INTEGER RBRACKET .)
    SEMICOLON       reduce using rule 44 (declarationTab -> ID LBRACKET INTEGER RBRACKET .)


state 170

    (50) array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab . SEMICOLON

    SEMICOLON       shift and go to state 174


state 171

    (72) statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET . RPAREN SEMICOLON

    RPAREN          shift and go to state 175


state 172

    (77) write_item -> ID LBRACKET INTEGER RBRACKET .

    RPAREN          reduce using rule 77 (write_item -> ID LBRACKET INTEGER RBRACKET .)
    COMMA           reduce using rule 77 (write_item -> ID LBRACKET INTEGER RBRACKET .)


state 173

    (78) statement -> FOR LPAREN initialisation COLON step COLON . BorneSup RPAREN block
    (82) BorneSup -> . ID

    ID              shift and go to state 177

    BorneSup                       shift and go to state 176

state 174

    (50) array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .

    ID              reduce using rule 50 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    READ            reduce using rule 50 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    WRITE           reduce using rule 50 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    FOR             reduce using rule 50 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    INT_TYPE        reduce using rule 50 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    FLOAT_TYPE      reduce using rule 50 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    BOOL_TYPE       reduce using rule 50 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    CHAR_TYPE       reduce using rule 50 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    RBRACE          reduce using rule 50 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)


state 175

    (72) statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 178


state 176

    (78) statement -> FOR LPAREN initialisation COLON step COLON BorneSup . RPAREN block

    RPAREN          shift and go to state 179


state 177

    (82) BorneSup -> ID .

    RPAREN          reduce using rule 82 (BorneSup -> ID .)


state 178

    (72) statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON .

    ID              reduce using rule 72 (statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON .)
    READ            reduce using rule 72 (statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON .)
    WRITE           reduce using rule 72 (statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON .)
    FOR             reduce using rule 72 (statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON .)
    INT_TYPE        reduce using rule 72 (statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON .)
    FLOAT_TYPE      reduce using rule 72 (statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON .)
    BOOL_TYPE       reduce using rule 72 (statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON .)
    CHAR_TYPE       reduce using rule 72 (statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON .)
    RBRACE          reduce using rule 72 (statement -> READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON .)


state 179

    (78) statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN . block
    (83) block -> . LBRACE statements RBRACE

    LBRACE          shift and go to state 181

    block                          shift and go to state 180

state 180

    (78) statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .

    ID              reduce using rule 78 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    READ            reduce using rule 78 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    WRITE           reduce using rule 78 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    FOR             reduce using rule 78 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    INT_TYPE        reduce using rule 78 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    FLOAT_TYPE      reduce using rule 78 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    BOOL_TYPE       reduce using rule 78 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    CHAR_TYPE       reduce using rule 78 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    RBRACE          reduce using rule 78 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)


state 181

    (83) block -> LBRACE . statements RBRACE
    (29) statements -> . statement
    (30) statements -> . statement statements
    (31) statements -> . empty
    (15) statement -> . ID EQUALS expression SEMICOLON
    (32) statement -> . simple_assignment
    (33) statement -> . array_assignment
    (59) statement -> . type ID EQUALS expression_arithmetique SEMICOLON
    (60) statement -> . ID EQUALS expression_arithmetique SEMICOLON
    (71) statement -> . READ LPAREN ID RPAREN SEMICOLON
    (72) statement -> . READ LPAREN ID LBRACKET INTEGER RBRACKET RPAREN SEMICOLON
    (73) statement -> . WRITE LPAREN write_content RPAREN SEMICOLON
    (78) statement -> . FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block
    (8) empty -> .
    (37) simple_assignment -> . ID EQUALS expressionTab SEMICOLON
    (50) array_assignment -> . ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON
    (16) type -> . INT_TYPE
    (17) type -> . FLOAT_TYPE
    (18) type -> . BOOL_TYPE
    (19) type -> . CHAR_TYPE

    ID              shift and go to state 36
    READ            shift and go to state 40
    WRITE           shift and go to state 41
    FOR             shift and go to state 42
    RBRACE          reduce using rule 8 (empty -> .)
    INT_TYPE        shift and go to state 18
    FLOAT_TYPE      shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    CHAR_TYPE       shift and go to state 21

    statements                     shift and go to state 182
    statement                      shift and go to state 34
    empty                          shift and go to state 35
    simple_assignment              shift and go to state 37
    array_assignment               shift and go to state 38
    type                           shift and go to state 39

state 182

    (83) block -> LBRACE statements . RBRACE

    RBRACE          shift and go to state 183


state 183

    (83) block -> LBRACE statements RBRACE .

    ID              reduce using rule 83 (block -> LBRACE statements RBRACE .)
    READ            reduce using rule 83 (block -> LBRACE statements RBRACE .)
    WRITE           reduce using rule 83 (block -> LBRACE statements RBRACE .)
    FOR             reduce using rule 83 (block -> LBRACE statements RBRACE .)
    INT_TYPE        reduce using rule 83 (block -> LBRACE statements RBRACE .)
    FLOAT_TYPE      reduce using rule 83 (block -> LBRACE statements RBRACE .)
    BOOL_TYPE       reduce using rule 83 (block -> LBRACE statements RBRACE .)
    CHAR_TYPE       reduce using rule 83 (block -> LBRACE statements RBRACE .)
    RBRACE          reduce using rule 83 (block -> LBRACE statements RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for SEMICOLON in state 113 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 132 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 133 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 155 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 155 resolved as shift
WARNING: reduce/reduce conflict in state 11 resolved using rule (declarations -> declaration)
WARNING: rejected rule (empty -> <empty>) in state 11
WARNING: reduce/reduce conflict in state 28 resolved using rule (declaration -> ID)
WARNING: rejected rule (declarationTab -> ID) in state 28
WARNING: reduce/reduce conflict in state 34 resolved using rule (empty -> <empty>)
WARNING: rejected rule (statements -> statement) in state 34
WARNING: reduce/reduce conflict in state 74 resolved using rule (expressionTab -> ID)
WARNING: rejected rule (factor -> ID) in state 74
WARNING: reduce/reduce conflict in state 76 resolved using rule (factor -> FLOAT)
WARNING: rejected rule (expressionTab -> FLOAT) in state 76
WARNING: reduce/reduce conflict in state 77 resolved using rule (factor -> INTEGER)
WARNING: rejected rule (expressionTab -> INTEGER) in state 77
WARNING: reduce/reduce conflict in state 78 resolved using rule (factor -> CHAR)
WARNING: rejected rule (expressionTab -> CHAR) in state 78
WARNING: reduce/reduce conflict in state 92 resolved using rule (expressionTab -> ID)
WARNING: rejected rule (factor -> ID) in state 92
WARNING: reduce/reduce conflict in state 92 resolved using rule (expressionTab -> ID)
WARNING: rejected rule (factor_arithmetique -> ID) in state 92
WARNING: reduce/reduce conflict in state 97 resolved using rule (factor -> FLOAT)
WARNING: rejected rule (expressionTab -> FLOAT) in state 97
WARNING: reduce/reduce conflict in state 97 resolved using rule (factor -> FLOAT)
WARNING: rejected rule (factor_arithmetique -> FLOAT) in state 97
WARNING: reduce/reduce conflict in state 98 resolved using rule (factor -> INTEGER)
WARNING: rejected rule (expressionTab -> INTEGER) in state 98
WARNING: reduce/reduce conflict in state 98 resolved using rule (factor -> INTEGER)
WARNING: rejected rule (factor_arithmetique -> INTEGER) in state 98
WARNING: Rule (statements -> statement) is never reduced
