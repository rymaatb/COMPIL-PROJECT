Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    DECLARATION
    ELSE
    EQ
    GT
    GTE
    IF
    INSTRUCTION
    LT
    LTE
    NEQ
    NUMBER
    READ
    VAR_GLOBAL
    WRITE

Grammar

Rule 0     S' -> statement
Rule 1     statement -> type declaration_list SEMICOLON
Rule 2     statement -> CONST type ID EQUALS expression SEMICOLON
Rule 3     declaration_list -> declaration
Rule 4     declaration_list -> declaration COMMA declaration_list
Rule 5     declaration -> ID
Rule 6     declaration -> ID EQUALS expression
Rule 7     statement -> ID EQUALS expression SEMICOLON
Rule 8     type -> INT_TYPE
Rule 9     type -> FLOAT_TYPE
Rule 10    type -> BOOL_TYPE
Rule 11    type -> CHAR_TYPE
Rule 12    factor -> INTEGER
Rule 13    factor -> FLOAT
Rule 14    factor -> CHAR
Rule 15    factor -> BOOL
Rule 16    factor -> MINUS factor
Rule 17    factor -> PLUS factor
Rule 18    factor -> LPAREN INTEGER RPAREN
Rule 19    factor -> LPAREN FLOAT RPAREN
Rule 20    factor -> LPAREN MINUS FLOAT RPAREN
Rule 21    statements -> statement
Rule 22    statements -> statement statements
Rule 23    statement -> simple_assignment
Rule 24    statement -> array_declarationTab
Rule 25    statement -> array_assignment
Rule 26    statement -> type declarationTab_listTab SEMICOLON
Rule 27    statement -> const_declarationTab
Rule 28    simple_assignment -> ID EQUALS expressionTab SEMICOLON
Rule 29    const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON
Rule 30    array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON
Rule 31    declarationTab_listTab -> declarationTab
Rule 32    declarationTab_listTab -> declarationTab COMMA declarationTab_listTab
Rule 33    declarationTab -> ID
Rule 34    declarationTab -> ID EQUALS expressionTab
Rule 35    declarationTab -> ID LBRACKET INTEGER RBRACKET
Rule 36    expressionTab -> ID
Rule 37    expressionTab -> FLOAT
Rule 38    expressionTab -> INTEGER
Rule 39    expressionTab -> CHAR
Rule 40    factor -> ID LBRACKET expressionTab RBRACKET
Rule 41    array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON
Rule 42    expression -> expression OR term
Rule 43    expression -> term
Rule 44    term -> term AND factor
Rule 45    term -> factor
Rule 46    factor -> ID
Rule 47    factor -> TRUE
Rule 48    factor -> FALSE
Rule 49    factor -> NOT ID
Rule 50    statement -> type ID EQUALS expression_arithmetique SEMICOLON
Rule 51    statement -> ID EQUALS expression_arithmetique SEMICOLON
Rule 52    expression_arithmetique -> expression_arithmetique PLUS term_arithmetique
Rule 53    expression_arithmetique -> expression_arithmetique MINUS term_arithmetique
Rule 54    expression_arithmetique -> term_arithmetique
Rule 55    term_arithmetique -> term_arithmetique MULTIPLY term_arithmetique
Rule 56    term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique
Rule 57    term_arithmetique -> factor_arithmetique
Rule 58    factor_arithmetique -> ID
Rule 59    factor_arithmetique -> INTEGER
Rule 60    factor_arithmetique -> FLOAT
Rule 61    factor_arithmetique -> LPAREN expression_arithmetique RPAREN
Rule 62    statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block
Rule 63    initialisation -> ID EQUALS INTEGER
Rule 64    step -> INTEGER
Rule 65    step -> ID
Rule 66    BorneSup -> ID
Rule 67    block -> LBRACE statements RBRACE

Terminals, with rules where they appear

AND                  : 44
BOOL                 : 15
BOOL_TYPE            : 10
CHAR                 : 14 39
CHAR_TYPE            : 11
COLON                : 62 62
COMMA                : 4 32
COMMENT              : 
CONST                : 2 29
DECLARATION          : 
DIVIDE               : 56
ELSE                 : 
EQ                   : 
EQUALS               : 2 6 7 28 29 34 41 50 51 63
FALSE                : 48
FLOAT                : 13 19 20 37 60
FLOAT_TYPE           : 9
FOR                  : 62
GT                   : 
GTE                  : 
ID                   : 2 5 6 7 28 29 30 33 34 35 36 40 41 46 49 50 51 58 63 65 66
IF                   : 
INSTRUCTION          : 
INTEGER              : 12 18 30 35 38 59 63 64
INT_TYPE             : 8
LBRACE               : 67
LBRACKET             : 30 35 40 41
LPAREN               : 18 19 20 61 62
LT                   : 
LTE                  : 
MINUS                : 16 20 53
MULTIPLY             : 55
NEQ                  : 
NOT                  : 49
NUMBER               : 
OR                   : 42
PLUS                 : 17 52
RBRACE               : 67
RBRACKET             : 30 35 40 41
READ                 : 
RPAREN               : 18 19 20 61 62
SEMICOLON            : 1 2 7 26 28 29 30 41 50 51
TRUE                 : 47
VAR_GLOBAL           : 
WRITE                : 
error                : 

Nonterminals, with rules where they appear

BorneSup             : 62
array_assignment     : 25
array_declarationTab : 24
block                : 62
const_declarationTab : 27
declaration          : 3 4
declarationTab       : 31 32
declarationTab_listTab : 26 32
declaration_list     : 1 4
expression           : 2 6 7 42
expressionTab        : 28 29 34 40 41 41
expression_arithmetique : 50 51 52 53 61
factor               : 16 17 44 45
factor_arithmetique  : 56 57
initialisation       : 62
simple_assignment    : 23
statement            : 21 22 0
statements           : 22 67
step                 : 62
term                 : 42 43 44
term_arithmetique    : 52 53 54 55 55 56
type                 : 1 2 26 29 30 50

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . type declaration_list SEMICOLON
    (2) statement -> . CONST type ID EQUALS expression SEMICOLON
    (7) statement -> . ID EQUALS expression SEMICOLON
    (23) statement -> . simple_assignment
    (24) statement -> . array_declarationTab
    (25) statement -> . array_assignment
    (26) statement -> . type declarationTab_listTab SEMICOLON
    (27) statement -> . const_declarationTab
    (50) statement -> . type ID EQUALS expression_arithmetique SEMICOLON
    (51) statement -> . ID EQUALS expression_arithmetique SEMICOLON
    (62) statement -> . FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block
    (8) type -> . INT_TYPE
    (9) type -> . FLOAT_TYPE
    (10) type -> . BOOL_TYPE
    (11) type -> . CHAR_TYPE
    (28) simple_assignment -> . ID EQUALS expressionTab SEMICOLON
    (30) array_declarationTab -> . type ID LBRACKET INTEGER RBRACKET SEMICOLON
    (41) array_assignment -> . ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON
    (29) const_declarationTab -> . CONST type ID EQUALS expressionTab SEMICOLON

    CONST           shift and go to state 3
    ID              shift and go to state 4
    FOR             shift and go to state 9
    INT_TYPE        shift and go to state 10
    FLOAT_TYPE      shift and go to state 11
    BOOL_TYPE       shift and go to state 12
    CHAR_TYPE       shift and go to state 13

    statement                      shift and go to state 1
    type                           shift and go to state 2
    simple_assignment              shift and go to state 5
    array_declarationTab           shift and go to state 6
    array_assignment               shift and go to state 7
    const_declarationTab           shift and go to state 8

state 1

    (0) S' -> statement .



state 2

    (1) statement -> type . declaration_list SEMICOLON
    (26) statement -> type . declarationTab_listTab SEMICOLON
    (50) statement -> type . ID EQUALS expression_arithmetique SEMICOLON
    (30) array_declarationTab -> type . ID LBRACKET INTEGER RBRACKET SEMICOLON
    (3) declaration_list -> . declaration
    (4) declaration_list -> . declaration COMMA declaration_list
    (31) declarationTab_listTab -> . declarationTab
    (32) declarationTab_listTab -> . declarationTab COMMA declarationTab_listTab
    (5) declaration -> . ID
    (6) declaration -> . ID EQUALS expression
    (33) declarationTab -> . ID
    (34) declarationTab -> . ID EQUALS expressionTab
    (35) declarationTab -> . ID LBRACKET INTEGER RBRACKET

    ID              shift and go to state 16

    declaration_list               shift and go to state 14
    declarationTab_listTab         shift and go to state 15
    declaration                    shift and go to state 17
    declarationTab                 shift and go to state 18

state 3

    (2) statement -> CONST . type ID EQUALS expression SEMICOLON
    (29) const_declarationTab -> CONST . type ID EQUALS expressionTab SEMICOLON
    (8) type -> . INT_TYPE
    (9) type -> . FLOAT_TYPE
    (10) type -> . BOOL_TYPE
    (11) type -> . CHAR_TYPE

    INT_TYPE        shift and go to state 10
    FLOAT_TYPE      shift and go to state 11
    BOOL_TYPE       shift and go to state 12
    CHAR_TYPE       shift and go to state 13

    type                           shift and go to state 19

state 4

    (7) statement -> ID . EQUALS expression SEMICOLON
    (51) statement -> ID . EQUALS expression_arithmetique SEMICOLON
    (28) simple_assignment -> ID . EQUALS expressionTab SEMICOLON
    (41) array_assignment -> ID . LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON

    EQUALS          shift and go to state 20
    LBRACKET        shift and go to state 21


state 5

    (23) statement -> simple_assignment .

    $end            reduce using rule 23 (statement -> simple_assignment .)
    CONST           reduce using rule 23 (statement -> simple_assignment .)
    ID              reduce using rule 23 (statement -> simple_assignment .)
    FOR             reduce using rule 23 (statement -> simple_assignment .)
    INT_TYPE        reduce using rule 23 (statement -> simple_assignment .)
    FLOAT_TYPE      reduce using rule 23 (statement -> simple_assignment .)
    BOOL_TYPE       reduce using rule 23 (statement -> simple_assignment .)
    CHAR_TYPE       reduce using rule 23 (statement -> simple_assignment .)
    RBRACE          reduce using rule 23 (statement -> simple_assignment .)


state 6

    (24) statement -> array_declarationTab .

    $end            reduce using rule 24 (statement -> array_declarationTab .)
    CONST           reduce using rule 24 (statement -> array_declarationTab .)
    ID              reduce using rule 24 (statement -> array_declarationTab .)
    FOR             reduce using rule 24 (statement -> array_declarationTab .)
    INT_TYPE        reduce using rule 24 (statement -> array_declarationTab .)
    FLOAT_TYPE      reduce using rule 24 (statement -> array_declarationTab .)
    BOOL_TYPE       reduce using rule 24 (statement -> array_declarationTab .)
    CHAR_TYPE       reduce using rule 24 (statement -> array_declarationTab .)
    RBRACE          reduce using rule 24 (statement -> array_declarationTab .)


state 7

    (25) statement -> array_assignment .

    $end            reduce using rule 25 (statement -> array_assignment .)
    CONST           reduce using rule 25 (statement -> array_assignment .)
    ID              reduce using rule 25 (statement -> array_assignment .)
    FOR             reduce using rule 25 (statement -> array_assignment .)
    INT_TYPE        reduce using rule 25 (statement -> array_assignment .)
    FLOAT_TYPE      reduce using rule 25 (statement -> array_assignment .)
    BOOL_TYPE       reduce using rule 25 (statement -> array_assignment .)
    CHAR_TYPE       reduce using rule 25 (statement -> array_assignment .)
    RBRACE          reduce using rule 25 (statement -> array_assignment .)


state 8

    (27) statement -> const_declarationTab .

    $end            reduce using rule 27 (statement -> const_declarationTab .)
    CONST           reduce using rule 27 (statement -> const_declarationTab .)
    ID              reduce using rule 27 (statement -> const_declarationTab .)
    FOR             reduce using rule 27 (statement -> const_declarationTab .)
    INT_TYPE        reduce using rule 27 (statement -> const_declarationTab .)
    FLOAT_TYPE      reduce using rule 27 (statement -> const_declarationTab .)
    BOOL_TYPE       reduce using rule 27 (statement -> const_declarationTab .)
    CHAR_TYPE       reduce using rule 27 (statement -> const_declarationTab .)
    RBRACE          reduce using rule 27 (statement -> const_declarationTab .)


state 9

    (62) statement -> FOR . LPAREN initialisation COLON step COLON BorneSup RPAREN block

    LPAREN          shift and go to state 22


state 10

    (8) type -> INT_TYPE .

    ID              reduce using rule 8 (type -> INT_TYPE .)


state 11

    (9) type -> FLOAT_TYPE .

    ID              reduce using rule 9 (type -> FLOAT_TYPE .)


state 12

    (10) type -> BOOL_TYPE .

    ID              reduce using rule 10 (type -> BOOL_TYPE .)


state 13

    (11) type -> CHAR_TYPE .

    ID              reduce using rule 11 (type -> CHAR_TYPE .)


state 14

    (1) statement -> type declaration_list . SEMICOLON

    SEMICOLON       shift and go to state 23


state 15

    (26) statement -> type declarationTab_listTab . SEMICOLON

    SEMICOLON       shift and go to state 24


state 16

    (50) statement -> type ID . EQUALS expression_arithmetique SEMICOLON
    (30) array_declarationTab -> type ID . LBRACKET INTEGER RBRACKET SEMICOLON
    (5) declaration -> ID .
    (6) declaration -> ID . EQUALS expression
    (33) declarationTab -> ID .
    (34) declarationTab -> ID . EQUALS expressionTab
    (35) declarationTab -> ID . LBRACKET INTEGER RBRACKET

  ! reduce/reduce conflict for COMMA resolved using rule 5 (declaration -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 5 (declaration -> ID .)
    EQUALS          shift and go to state 25
    LBRACKET        shift and go to state 26
    COMMA           reduce using rule 5 (declaration -> ID .)
    SEMICOLON       reduce using rule 5 (declaration -> ID .)

  ! COMMA           [ reduce using rule 33 (declarationTab -> ID .) ]
  ! SEMICOLON       [ reduce using rule 33 (declarationTab -> ID .) ]


state 17

    (3) declaration_list -> declaration .
    (4) declaration_list -> declaration . COMMA declaration_list

    SEMICOLON       reduce using rule 3 (declaration_list -> declaration .)
    COMMA           shift and go to state 27


state 18

    (31) declarationTab_listTab -> declarationTab .
    (32) declarationTab_listTab -> declarationTab . COMMA declarationTab_listTab

    SEMICOLON       reduce using rule 31 (declarationTab_listTab -> declarationTab .)
    COMMA           shift and go to state 28


state 19

    (2) statement -> CONST type . ID EQUALS expression SEMICOLON
    (29) const_declarationTab -> CONST type . ID EQUALS expressionTab SEMICOLON

    ID              shift and go to state 29


state 20

    (7) statement -> ID EQUALS . expression SEMICOLON
    (51) statement -> ID EQUALS . expression_arithmetique SEMICOLON
    (28) simple_assignment -> ID EQUALS . expressionTab SEMICOLON
    (42) expression -> . expression OR term
    (43) expression -> . term
    (52) expression_arithmetique -> . expression_arithmetique PLUS term_arithmetique
    (53) expression_arithmetique -> . expression_arithmetique MINUS term_arithmetique
    (54) expression_arithmetique -> . term_arithmetique
    (36) expressionTab -> . ID
    (37) expressionTab -> . FLOAT
    (38) expressionTab -> . INTEGER
    (39) expressionTab -> . CHAR
    (44) term -> . term AND factor
    (45) term -> . factor
    (55) term_arithmetique -> . term_arithmetique MULTIPLY term_arithmetique
    (56) term_arithmetique -> . term_arithmetique DIVIDE factor_arithmetique
    (57) term_arithmetique -> . factor_arithmetique
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (40) factor -> . ID LBRACKET expressionTab RBRACKET
    (46) factor -> . ID
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . NOT ID
    (58) factor_arithmetique -> . ID
    (59) factor_arithmetique -> . INTEGER
    (60) factor_arithmetique -> . FLOAT
    (61) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN

    ID              shift and go to state 30
    FLOAT           shift and go to state 38
    INTEGER         shift and go to state 39
    CHAR            shift and go to state 40
    BOOL            shift and go to state 43
    MINUS           shift and go to state 37
    PLUS            shift and go to state 35
    LPAREN          shift and go to state 44
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46
    NOT             shift and go to state 47

    expression                     shift and go to state 31
    expression_arithmetique        shift and go to state 32
    expressionTab                  shift and go to state 33
    term                           shift and go to state 34
    term_arithmetique              shift and go to state 36
    factor                         shift and go to state 41
    factor_arithmetique            shift and go to state 42

state 21

    (41) array_assignment -> ID LBRACKET . expressionTab RBRACKET EQUALS expressionTab SEMICOLON
    (36) expressionTab -> . ID
    (37) expressionTab -> . FLOAT
    (38) expressionTab -> . INTEGER
    (39) expressionTab -> . CHAR

    ID              shift and go to state 48
    FLOAT           shift and go to state 50
    INTEGER         shift and go to state 51
    CHAR            shift and go to state 52

    expressionTab                  shift and go to state 49

state 22

    (62) statement -> FOR LPAREN . initialisation COLON step COLON BorneSup RPAREN block
    (63) initialisation -> . ID EQUALS INTEGER

    ID              shift and go to state 54

    initialisation                 shift and go to state 53

state 23

    (1) statement -> type declaration_list SEMICOLON .

    $end            reduce using rule 1 (statement -> type declaration_list SEMICOLON .)
    CONST           reduce using rule 1 (statement -> type declaration_list SEMICOLON .)
    ID              reduce using rule 1 (statement -> type declaration_list SEMICOLON .)
    FOR             reduce using rule 1 (statement -> type declaration_list SEMICOLON .)
    INT_TYPE        reduce using rule 1 (statement -> type declaration_list SEMICOLON .)
    FLOAT_TYPE      reduce using rule 1 (statement -> type declaration_list SEMICOLON .)
    BOOL_TYPE       reduce using rule 1 (statement -> type declaration_list SEMICOLON .)
    CHAR_TYPE       reduce using rule 1 (statement -> type declaration_list SEMICOLON .)
    RBRACE          reduce using rule 1 (statement -> type declaration_list SEMICOLON .)


state 24

    (26) statement -> type declarationTab_listTab SEMICOLON .

    $end            reduce using rule 26 (statement -> type declarationTab_listTab SEMICOLON .)
    CONST           reduce using rule 26 (statement -> type declarationTab_listTab SEMICOLON .)
    ID              reduce using rule 26 (statement -> type declarationTab_listTab SEMICOLON .)
    FOR             reduce using rule 26 (statement -> type declarationTab_listTab SEMICOLON .)
    INT_TYPE        reduce using rule 26 (statement -> type declarationTab_listTab SEMICOLON .)
    FLOAT_TYPE      reduce using rule 26 (statement -> type declarationTab_listTab SEMICOLON .)
    BOOL_TYPE       reduce using rule 26 (statement -> type declarationTab_listTab SEMICOLON .)
    CHAR_TYPE       reduce using rule 26 (statement -> type declarationTab_listTab SEMICOLON .)
    RBRACE          reduce using rule 26 (statement -> type declarationTab_listTab SEMICOLON .)


state 25

    (50) statement -> type ID EQUALS . expression_arithmetique SEMICOLON
    (6) declaration -> ID EQUALS . expression
    (34) declarationTab -> ID EQUALS . expressionTab
    (52) expression_arithmetique -> . expression_arithmetique PLUS term_arithmetique
    (53) expression_arithmetique -> . expression_arithmetique MINUS term_arithmetique
    (54) expression_arithmetique -> . term_arithmetique
    (42) expression -> . expression OR term
    (43) expression -> . term
    (36) expressionTab -> . ID
    (37) expressionTab -> . FLOAT
    (38) expressionTab -> . INTEGER
    (39) expressionTab -> . CHAR
    (55) term_arithmetique -> . term_arithmetique MULTIPLY term_arithmetique
    (56) term_arithmetique -> . term_arithmetique DIVIDE factor_arithmetique
    (57) term_arithmetique -> . factor_arithmetique
    (44) term -> . term AND factor
    (45) term -> . factor
    (58) factor_arithmetique -> . ID
    (59) factor_arithmetique -> . INTEGER
    (60) factor_arithmetique -> . FLOAT
    (61) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (40) factor -> . ID LBRACKET expressionTab RBRACKET
    (46) factor -> . ID
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . NOT ID

    ID              shift and go to state 55
    FLOAT           shift and go to state 59
    INTEGER         shift and go to state 60
    CHAR            shift and go to state 40
    LPAREN          shift and go to state 61
    BOOL            shift and go to state 43
    MINUS           shift and go to state 37
    PLUS            shift and go to state 35
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46
    NOT             shift and go to state 47

    expression_arithmetique        shift and go to state 56
    expression                     shift and go to state 57
    expressionTab                  shift and go to state 58
    term_arithmetique              shift and go to state 36
    term                           shift and go to state 34
    factor_arithmetique            shift and go to state 42
    factor                         shift and go to state 41

state 26

    (30) array_declarationTab -> type ID LBRACKET . INTEGER RBRACKET SEMICOLON
    (35) declarationTab -> ID LBRACKET . INTEGER RBRACKET

    INTEGER         shift and go to state 62


state 27

    (4) declaration_list -> declaration COMMA . declaration_list
    (3) declaration_list -> . declaration
    (4) declaration_list -> . declaration COMMA declaration_list
    (5) declaration -> . ID
    (6) declaration -> . ID EQUALS expression

    ID              shift and go to state 64

    declaration                    shift and go to state 17
    declaration_list               shift and go to state 63

state 28

    (32) declarationTab_listTab -> declarationTab COMMA . declarationTab_listTab
    (31) declarationTab_listTab -> . declarationTab
    (32) declarationTab_listTab -> . declarationTab COMMA declarationTab_listTab
    (33) declarationTab -> . ID
    (34) declarationTab -> . ID EQUALS expressionTab
    (35) declarationTab -> . ID LBRACKET INTEGER RBRACKET

    ID              shift and go to state 66

    declarationTab                 shift and go to state 18
    declarationTab_listTab         shift and go to state 65

state 29

    (2) statement -> CONST type ID . EQUALS expression SEMICOLON
    (29) const_declarationTab -> CONST type ID . EQUALS expressionTab SEMICOLON

    EQUALS          shift and go to state 67


state 30

    (36) expressionTab -> ID .
    (40) factor -> ID . LBRACKET expressionTab RBRACKET
    (46) factor -> ID .
    (58) factor_arithmetique -> ID .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 36 (expressionTab -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 36 (expressionTab -> ID .)
    SEMICOLON       reduce using rule 36 (expressionTab -> ID .)
    LBRACKET        shift and go to state 68
    AND             reduce using rule 46 (factor -> ID .)
    OR              reduce using rule 46 (factor -> ID .)
    MULTIPLY        reduce using rule 58 (factor_arithmetique -> ID .)
    DIVIDE          reduce using rule 58 (factor_arithmetique -> ID .)
    PLUS            reduce using rule 58 (factor_arithmetique -> ID .)
    MINUS           reduce using rule 58 (factor_arithmetique -> ID .)

  ! SEMICOLON       [ reduce using rule 46 (factor -> ID .) ]
  ! SEMICOLON       [ reduce using rule 58 (factor_arithmetique -> ID .) ]


state 31

    (7) statement -> ID EQUALS expression . SEMICOLON
    (42) expression -> expression . OR term

    SEMICOLON       shift and go to state 69
    OR              shift and go to state 70


state 32

    (51) statement -> ID EQUALS expression_arithmetique . SEMICOLON
    (52) expression_arithmetique -> expression_arithmetique . PLUS term_arithmetique
    (53) expression_arithmetique -> expression_arithmetique . MINUS term_arithmetique

    SEMICOLON       shift and go to state 71
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 33

    (28) simple_assignment -> ID EQUALS expressionTab . SEMICOLON

    SEMICOLON       shift and go to state 74


state 34

    (43) expression -> term .
    (44) term -> term . AND factor

    SEMICOLON       reduce using rule 43 (expression -> term .)
    OR              reduce using rule 43 (expression -> term .)
    COMMA           reduce using rule 43 (expression -> term .)
    AND             shift and go to state 75


state 35

    (17) factor -> PLUS . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (40) factor -> . ID LBRACKET expressionTab RBRACKET
    (46) factor -> . ID
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . NOT ID

    INTEGER         shift and go to state 77
    FLOAT           shift and go to state 78
    CHAR            shift and go to state 79
    BOOL            shift and go to state 43
    MINUS           shift and go to state 37
    PLUS            shift and go to state 35
    LPAREN          shift and go to state 80
    ID              shift and go to state 81
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46
    NOT             shift and go to state 47

    factor                         shift and go to state 76

state 36

    (54) expression_arithmetique -> term_arithmetique .
    (55) term_arithmetique -> term_arithmetique . MULTIPLY term_arithmetique
    (56) term_arithmetique -> term_arithmetique . DIVIDE factor_arithmetique

    SEMICOLON       reduce using rule 54 (expression_arithmetique -> term_arithmetique .)
    PLUS            reduce using rule 54 (expression_arithmetique -> term_arithmetique .)
    MINUS           reduce using rule 54 (expression_arithmetique -> term_arithmetique .)
    RPAREN          reduce using rule 54 (expression_arithmetique -> term_arithmetique .)
    MULTIPLY        shift and go to state 82
    DIVIDE          shift and go to state 83


state 37

    (16) factor -> MINUS . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (40) factor -> . ID LBRACKET expressionTab RBRACKET
    (46) factor -> . ID
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . NOT ID

    INTEGER         shift and go to state 77
    FLOAT           shift and go to state 78
    CHAR            shift and go to state 79
    BOOL            shift and go to state 43
    MINUS           shift and go to state 37
    PLUS            shift and go to state 35
    LPAREN          shift and go to state 80
    ID              shift and go to state 81
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46
    NOT             shift and go to state 47

    factor                         shift and go to state 84

state 38

    (37) expressionTab -> FLOAT .
    (13) factor -> FLOAT .
    (60) factor_arithmetique -> FLOAT .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 13 (factor -> FLOAT .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 13 (factor -> FLOAT .)
    AND             reduce using rule 13 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 13 (factor -> FLOAT .)
    OR              reduce using rule 13 (factor -> FLOAT .)
    MULTIPLY        reduce using rule 60 (factor_arithmetique -> FLOAT .)
    DIVIDE          reduce using rule 60 (factor_arithmetique -> FLOAT .)
    PLUS            reduce using rule 60 (factor_arithmetique -> FLOAT .)
    MINUS           reduce using rule 60 (factor_arithmetique -> FLOAT .)

  ! SEMICOLON       [ reduce using rule 37 (expressionTab -> FLOAT .) ]
  ! SEMICOLON       [ reduce using rule 60 (factor_arithmetique -> FLOAT .) ]


state 39

    (38) expressionTab -> INTEGER .
    (12) factor -> INTEGER .
    (59) factor_arithmetique -> INTEGER .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 12 (factor -> INTEGER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 12 (factor -> INTEGER .)
    AND             reduce using rule 12 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 12 (factor -> INTEGER .)
    OR              reduce using rule 12 (factor -> INTEGER .)
    MULTIPLY        reduce using rule 59 (factor_arithmetique -> INTEGER .)
    DIVIDE          reduce using rule 59 (factor_arithmetique -> INTEGER .)
    PLUS            reduce using rule 59 (factor_arithmetique -> INTEGER .)
    MINUS           reduce using rule 59 (factor_arithmetique -> INTEGER .)

  ! SEMICOLON       [ reduce using rule 38 (expressionTab -> INTEGER .) ]
  ! SEMICOLON       [ reduce using rule 59 (factor_arithmetique -> INTEGER .) ]


state 40

    (39) expressionTab -> CHAR .
    (14) factor -> CHAR .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 14 (factor -> CHAR .)
  ! reduce/reduce conflict for COMMA resolved using rule 14 (factor -> CHAR .)
    AND             reduce using rule 14 (factor -> CHAR .)
    SEMICOLON       reduce using rule 14 (factor -> CHAR .)
    OR              reduce using rule 14 (factor -> CHAR .)
    COMMA           reduce using rule 14 (factor -> CHAR .)

  ! SEMICOLON       [ reduce using rule 39 (expressionTab -> CHAR .) ]
  ! COMMA           [ reduce using rule 39 (expressionTab -> CHAR .) ]


state 41

    (45) term -> factor .

    AND             reduce using rule 45 (term -> factor .)
    SEMICOLON       reduce using rule 45 (term -> factor .)
    OR              reduce using rule 45 (term -> factor .)
    COMMA           reduce using rule 45 (term -> factor .)


state 42

    (57) term_arithmetique -> factor_arithmetique .

    MULTIPLY        reduce using rule 57 (term_arithmetique -> factor_arithmetique .)
    DIVIDE          reduce using rule 57 (term_arithmetique -> factor_arithmetique .)
    SEMICOLON       reduce using rule 57 (term_arithmetique -> factor_arithmetique .)
    PLUS            reduce using rule 57 (term_arithmetique -> factor_arithmetique .)
    MINUS           reduce using rule 57 (term_arithmetique -> factor_arithmetique .)
    RPAREN          reduce using rule 57 (term_arithmetique -> factor_arithmetique .)


state 43

    (15) factor -> BOOL .

    AND             reduce using rule 15 (factor -> BOOL .)
    SEMICOLON       reduce using rule 15 (factor -> BOOL .)
    OR              reduce using rule 15 (factor -> BOOL .)
    COMMA           reduce using rule 15 (factor -> BOOL .)


state 44

    (18) factor -> LPAREN . INTEGER RPAREN
    (19) factor -> LPAREN . FLOAT RPAREN
    (20) factor -> LPAREN . MINUS FLOAT RPAREN
    (61) factor_arithmetique -> LPAREN . expression_arithmetique RPAREN
    (52) expression_arithmetique -> . expression_arithmetique PLUS term_arithmetique
    (53) expression_arithmetique -> . expression_arithmetique MINUS term_arithmetique
    (54) expression_arithmetique -> . term_arithmetique
    (55) term_arithmetique -> . term_arithmetique MULTIPLY term_arithmetique
    (56) term_arithmetique -> . term_arithmetique DIVIDE factor_arithmetique
    (57) term_arithmetique -> . factor_arithmetique
    (58) factor_arithmetique -> . ID
    (59) factor_arithmetique -> . INTEGER
    (60) factor_arithmetique -> . FLOAT
    (61) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN

    INTEGER         shift and go to state 86
    FLOAT           shift and go to state 87
    MINUS           shift and go to state 88
    ID              shift and go to state 90
    LPAREN          shift and go to state 85

    expression_arithmetique        shift and go to state 89
    term_arithmetique              shift and go to state 36
    factor_arithmetique            shift and go to state 42

state 45

    (47) factor -> TRUE .

    AND             reduce using rule 47 (factor -> TRUE .)
    SEMICOLON       reduce using rule 47 (factor -> TRUE .)
    OR              reduce using rule 47 (factor -> TRUE .)
    COMMA           reduce using rule 47 (factor -> TRUE .)


state 46

    (48) factor -> FALSE .

    AND             reduce using rule 48 (factor -> FALSE .)
    SEMICOLON       reduce using rule 48 (factor -> FALSE .)
    OR              reduce using rule 48 (factor -> FALSE .)
    COMMA           reduce using rule 48 (factor -> FALSE .)


state 47

    (49) factor -> NOT . ID

    ID              shift and go to state 91


state 48

    (36) expressionTab -> ID .

    RBRACKET        reduce using rule 36 (expressionTab -> ID .)
    COMMA           reduce using rule 36 (expressionTab -> ID .)
    SEMICOLON       reduce using rule 36 (expressionTab -> ID .)


state 49

    (41) array_assignment -> ID LBRACKET expressionTab . RBRACKET EQUALS expressionTab SEMICOLON

    RBRACKET        shift and go to state 92


state 50

    (37) expressionTab -> FLOAT .

    RBRACKET        reduce using rule 37 (expressionTab -> FLOAT .)
    COMMA           reduce using rule 37 (expressionTab -> FLOAT .)
    SEMICOLON       reduce using rule 37 (expressionTab -> FLOAT .)


state 51

    (38) expressionTab -> INTEGER .

    RBRACKET        reduce using rule 38 (expressionTab -> INTEGER .)
    COMMA           reduce using rule 38 (expressionTab -> INTEGER .)
    SEMICOLON       reduce using rule 38 (expressionTab -> INTEGER .)


state 52

    (39) expressionTab -> CHAR .

    RBRACKET        reduce using rule 39 (expressionTab -> CHAR .)
    COMMA           reduce using rule 39 (expressionTab -> CHAR .)
    SEMICOLON       reduce using rule 39 (expressionTab -> CHAR .)


state 53

    (62) statement -> FOR LPAREN initialisation . COLON step COLON BorneSup RPAREN block

    COLON           shift and go to state 93


state 54

    (63) initialisation -> ID . EQUALS INTEGER

    EQUALS          shift and go to state 94


state 55

    (36) expressionTab -> ID .
    (58) factor_arithmetique -> ID .
    (40) factor -> ID . LBRACKET expressionTab RBRACKET
    (46) factor -> ID .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 36 (expressionTab -> ID .)
  ! reduce/reduce conflict for COMMA resolved using rule 36 (expressionTab -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 36 (expressionTab -> ID .)
    COMMA           reduce using rule 36 (expressionTab -> ID .)
    SEMICOLON       reduce using rule 36 (expressionTab -> ID .)
    MULTIPLY        reduce using rule 58 (factor_arithmetique -> ID .)
    DIVIDE          reduce using rule 58 (factor_arithmetique -> ID .)
    PLUS            reduce using rule 58 (factor_arithmetique -> ID .)
    MINUS           reduce using rule 58 (factor_arithmetique -> ID .)
    LBRACKET        shift and go to state 68
    AND             reduce using rule 46 (factor -> ID .)
    OR              reduce using rule 46 (factor -> ID .)

  ! SEMICOLON       [ reduce using rule 58 (factor_arithmetique -> ID .) ]
  ! COMMA           [ reduce using rule 46 (factor -> ID .) ]
  ! SEMICOLON       [ reduce using rule 46 (factor -> ID .) ]


state 56

    (50) statement -> type ID EQUALS expression_arithmetique . SEMICOLON
    (52) expression_arithmetique -> expression_arithmetique . PLUS term_arithmetique
    (53) expression_arithmetique -> expression_arithmetique . MINUS term_arithmetique

    SEMICOLON       shift and go to state 95
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 57

    (6) declaration -> ID EQUALS expression .
    (42) expression -> expression . OR term

    COMMA           reduce using rule 6 (declaration -> ID EQUALS expression .)
    SEMICOLON       reduce using rule 6 (declaration -> ID EQUALS expression .)
    OR              shift and go to state 70


state 58

    (34) declarationTab -> ID EQUALS expressionTab .

    COMMA           reduce using rule 34 (declarationTab -> ID EQUALS expressionTab .)
    SEMICOLON       reduce using rule 34 (declarationTab -> ID EQUALS expressionTab .)


state 59

    (37) expressionTab -> FLOAT .
    (60) factor_arithmetique -> FLOAT .
    (13) factor -> FLOAT .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 37 (expressionTab -> FLOAT .)
  ! reduce/reduce conflict for COMMA resolved using rule 13 (factor -> FLOAT .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 13 (factor -> FLOAT .)
    MULTIPLY        reduce using rule 60 (factor_arithmetique -> FLOAT .)
    DIVIDE          reduce using rule 60 (factor_arithmetique -> FLOAT .)
    PLUS            reduce using rule 60 (factor_arithmetique -> FLOAT .)
    MINUS           reduce using rule 60 (factor_arithmetique -> FLOAT .)
    AND             reduce using rule 13 (factor -> FLOAT .)
    OR              reduce using rule 13 (factor -> FLOAT .)
    COMMA           reduce using rule 13 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 13 (factor -> FLOAT .)

  ! COMMA           [ reduce using rule 37 (expressionTab -> FLOAT .) ]
  ! SEMICOLON       [ reduce using rule 37 (expressionTab -> FLOAT .) ]
  ! SEMICOLON       [ reduce using rule 60 (factor_arithmetique -> FLOAT .) ]


state 60

    (38) expressionTab -> INTEGER .
    (59) factor_arithmetique -> INTEGER .
    (12) factor -> INTEGER .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 38 (expressionTab -> INTEGER .)
  ! reduce/reduce conflict for COMMA resolved using rule 12 (factor -> INTEGER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 12 (factor -> INTEGER .)
    MULTIPLY        reduce using rule 59 (factor_arithmetique -> INTEGER .)
    DIVIDE          reduce using rule 59 (factor_arithmetique -> INTEGER .)
    PLUS            reduce using rule 59 (factor_arithmetique -> INTEGER .)
    MINUS           reduce using rule 59 (factor_arithmetique -> INTEGER .)
    AND             reduce using rule 12 (factor -> INTEGER .)
    OR              reduce using rule 12 (factor -> INTEGER .)
    COMMA           reduce using rule 12 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 12 (factor -> INTEGER .)

  ! COMMA           [ reduce using rule 38 (expressionTab -> INTEGER .) ]
  ! SEMICOLON       [ reduce using rule 38 (expressionTab -> INTEGER .) ]
  ! SEMICOLON       [ reduce using rule 59 (factor_arithmetique -> INTEGER .) ]


state 61

    (61) factor_arithmetique -> LPAREN . expression_arithmetique RPAREN
    (18) factor -> LPAREN . INTEGER RPAREN
    (19) factor -> LPAREN . FLOAT RPAREN
    (20) factor -> LPAREN . MINUS FLOAT RPAREN
    (52) expression_arithmetique -> . expression_arithmetique PLUS term_arithmetique
    (53) expression_arithmetique -> . expression_arithmetique MINUS term_arithmetique
    (54) expression_arithmetique -> . term_arithmetique
    (55) term_arithmetique -> . term_arithmetique MULTIPLY term_arithmetique
    (56) term_arithmetique -> . term_arithmetique DIVIDE factor_arithmetique
    (57) term_arithmetique -> . factor_arithmetique
    (58) factor_arithmetique -> . ID
    (59) factor_arithmetique -> . INTEGER
    (60) factor_arithmetique -> . FLOAT
    (61) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN

    INTEGER         shift and go to state 86
    FLOAT           shift and go to state 87
    MINUS           shift and go to state 88
    ID              shift and go to state 90
    LPAREN          shift and go to state 85

    expression_arithmetique        shift and go to state 89
    term_arithmetique              shift and go to state 36
    factor_arithmetique            shift and go to state 42

state 62

    (30) array_declarationTab -> type ID LBRACKET INTEGER . RBRACKET SEMICOLON
    (35) declarationTab -> ID LBRACKET INTEGER . RBRACKET

    RBRACKET        shift and go to state 96


state 63

    (4) declaration_list -> declaration COMMA declaration_list .

    SEMICOLON       reduce using rule 4 (declaration_list -> declaration COMMA declaration_list .)


state 64

    (5) declaration -> ID .
    (6) declaration -> ID . EQUALS expression

    COMMA           reduce using rule 5 (declaration -> ID .)
    SEMICOLON       reduce using rule 5 (declaration -> ID .)
    EQUALS          shift and go to state 97


state 65

    (32) declarationTab_listTab -> declarationTab COMMA declarationTab_listTab .

    SEMICOLON       reduce using rule 32 (declarationTab_listTab -> declarationTab COMMA declarationTab_listTab .)


state 66

    (33) declarationTab -> ID .
    (34) declarationTab -> ID . EQUALS expressionTab
    (35) declarationTab -> ID . LBRACKET INTEGER RBRACKET

    COMMA           reduce using rule 33 (declarationTab -> ID .)
    SEMICOLON       reduce using rule 33 (declarationTab -> ID .)
    EQUALS          shift and go to state 98
    LBRACKET        shift and go to state 99


state 67

    (2) statement -> CONST type ID EQUALS . expression SEMICOLON
    (29) const_declarationTab -> CONST type ID EQUALS . expressionTab SEMICOLON
    (42) expression -> . expression OR term
    (43) expression -> . term
    (36) expressionTab -> . ID
    (37) expressionTab -> . FLOAT
    (38) expressionTab -> . INTEGER
    (39) expressionTab -> . CHAR
    (44) term -> . term AND factor
    (45) term -> . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (40) factor -> . ID LBRACKET expressionTab RBRACKET
    (46) factor -> . ID
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . NOT ID

    ID              shift and go to state 100
    FLOAT           shift and go to state 103
    INTEGER         shift and go to state 104
    CHAR            shift and go to state 40
    BOOL            shift and go to state 43
    MINUS           shift and go to state 37
    PLUS            shift and go to state 35
    LPAREN          shift and go to state 80
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46
    NOT             shift and go to state 47

    expression                     shift and go to state 101
    expressionTab                  shift and go to state 102
    term                           shift and go to state 34
    factor                         shift and go to state 41

state 68

    (40) factor -> ID LBRACKET . expressionTab RBRACKET
    (36) expressionTab -> . ID
    (37) expressionTab -> . FLOAT
    (38) expressionTab -> . INTEGER
    (39) expressionTab -> . CHAR

    ID              shift and go to state 48
    FLOAT           shift and go to state 50
    INTEGER         shift and go to state 51
    CHAR            shift and go to state 52

    expressionTab                  shift and go to state 105

state 69

    (7) statement -> ID EQUALS expression SEMICOLON .

    $end            reduce using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
    CONST           reduce using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
    ID              reduce using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
    FOR             reduce using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
    INT_TYPE        reduce using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
    FLOAT_TYPE      reduce using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
    BOOL_TYPE       reduce using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
    CHAR_TYPE       reduce using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
    RBRACE          reduce using rule 7 (statement -> ID EQUALS expression SEMICOLON .)


state 70

    (42) expression -> expression OR . term
    (44) term -> . term AND factor
    (45) term -> . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (40) factor -> . ID LBRACKET expressionTab RBRACKET
    (46) factor -> . ID
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . NOT ID

    INTEGER         shift and go to state 77
    FLOAT           shift and go to state 78
    CHAR            shift and go to state 79
    BOOL            shift and go to state 43
    MINUS           shift and go to state 37
    PLUS            shift and go to state 35
    LPAREN          shift and go to state 80
    ID              shift and go to state 81
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46
    NOT             shift and go to state 47

    term                           shift and go to state 106
    factor                         shift and go to state 41

state 71

    (51) statement -> ID EQUALS expression_arithmetique SEMICOLON .

    $end            reduce using rule 51 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    CONST           reduce using rule 51 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    ID              reduce using rule 51 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    FOR             reduce using rule 51 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    INT_TYPE        reduce using rule 51 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    FLOAT_TYPE      reduce using rule 51 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    BOOL_TYPE       reduce using rule 51 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    CHAR_TYPE       reduce using rule 51 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)
    RBRACE          reduce using rule 51 (statement -> ID EQUALS expression_arithmetique SEMICOLON .)


state 72

    (52) expression_arithmetique -> expression_arithmetique PLUS . term_arithmetique
    (55) term_arithmetique -> . term_arithmetique MULTIPLY term_arithmetique
    (56) term_arithmetique -> . term_arithmetique DIVIDE factor_arithmetique
    (57) term_arithmetique -> . factor_arithmetique
    (58) factor_arithmetique -> . ID
    (59) factor_arithmetique -> . INTEGER
    (60) factor_arithmetique -> . FLOAT
    (61) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN

    ID              shift and go to state 90
    INTEGER         shift and go to state 108
    FLOAT           shift and go to state 109
    LPAREN          shift and go to state 85

    term_arithmetique              shift and go to state 107
    factor_arithmetique            shift and go to state 42

state 73

    (53) expression_arithmetique -> expression_arithmetique MINUS . term_arithmetique
    (55) term_arithmetique -> . term_arithmetique MULTIPLY term_arithmetique
    (56) term_arithmetique -> . term_arithmetique DIVIDE factor_arithmetique
    (57) term_arithmetique -> . factor_arithmetique
    (58) factor_arithmetique -> . ID
    (59) factor_arithmetique -> . INTEGER
    (60) factor_arithmetique -> . FLOAT
    (61) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN

    ID              shift and go to state 90
    INTEGER         shift and go to state 108
    FLOAT           shift and go to state 109
    LPAREN          shift and go to state 85

    term_arithmetique              shift and go to state 110
    factor_arithmetique            shift and go to state 42

state 74

    (28) simple_assignment -> ID EQUALS expressionTab SEMICOLON .

    $end            reduce using rule 28 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    CONST           reduce using rule 28 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    ID              reduce using rule 28 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    FOR             reduce using rule 28 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    INT_TYPE        reduce using rule 28 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    FLOAT_TYPE      reduce using rule 28 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    BOOL_TYPE       reduce using rule 28 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    CHAR_TYPE       reduce using rule 28 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    RBRACE          reduce using rule 28 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)


state 75

    (44) term -> term AND . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (40) factor -> . ID LBRACKET expressionTab RBRACKET
    (46) factor -> . ID
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . NOT ID

    INTEGER         shift and go to state 77
    FLOAT           shift and go to state 78
    CHAR            shift and go to state 79
    BOOL            shift and go to state 43
    MINUS           shift and go to state 37
    PLUS            shift and go to state 35
    LPAREN          shift and go to state 80
    ID              shift and go to state 81
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46
    NOT             shift and go to state 47

    factor                         shift and go to state 111

state 76

    (17) factor -> PLUS factor .

    AND             reduce using rule 17 (factor -> PLUS factor .)
    SEMICOLON       reduce using rule 17 (factor -> PLUS factor .)
    OR              reduce using rule 17 (factor -> PLUS factor .)
    COMMA           reduce using rule 17 (factor -> PLUS factor .)


state 77

    (12) factor -> INTEGER .

    AND             reduce using rule 12 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 12 (factor -> INTEGER .)
    OR              reduce using rule 12 (factor -> INTEGER .)
    COMMA           reduce using rule 12 (factor -> INTEGER .)


state 78

    (13) factor -> FLOAT .

    AND             reduce using rule 13 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 13 (factor -> FLOAT .)
    OR              reduce using rule 13 (factor -> FLOAT .)
    COMMA           reduce using rule 13 (factor -> FLOAT .)


state 79

    (14) factor -> CHAR .

    AND             reduce using rule 14 (factor -> CHAR .)
    SEMICOLON       reduce using rule 14 (factor -> CHAR .)
    OR              reduce using rule 14 (factor -> CHAR .)
    COMMA           reduce using rule 14 (factor -> CHAR .)


state 80

    (18) factor -> LPAREN . INTEGER RPAREN
    (19) factor -> LPAREN . FLOAT RPAREN
    (20) factor -> LPAREN . MINUS FLOAT RPAREN

    INTEGER         shift and go to state 112
    FLOAT           shift and go to state 113
    MINUS           shift and go to state 88


state 81

    (40) factor -> ID . LBRACKET expressionTab RBRACKET
    (46) factor -> ID .

    LBRACKET        shift and go to state 68
    AND             reduce using rule 46 (factor -> ID .)
    SEMICOLON       reduce using rule 46 (factor -> ID .)
    OR              reduce using rule 46 (factor -> ID .)
    COMMA           reduce using rule 46 (factor -> ID .)


state 82

    (55) term_arithmetique -> term_arithmetique MULTIPLY . term_arithmetique
    (55) term_arithmetique -> . term_arithmetique MULTIPLY term_arithmetique
    (56) term_arithmetique -> . term_arithmetique DIVIDE factor_arithmetique
    (57) term_arithmetique -> . factor_arithmetique
    (58) factor_arithmetique -> . ID
    (59) factor_arithmetique -> . INTEGER
    (60) factor_arithmetique -> . FLOAT
    (61) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN

    ID              shift and go to state 90
    INTEGER         shift and go to state 108
    FLOAT           shift and go to state 109
    LPAREN          shift and go to state 85

    term_arithmetique              shift and go to state 114
    factor_arithmetique            shift and go to state 42

state 83

    (56) term_arithmetique -> term_arithmetique DIVIDE . factor_arithmetique
    (58) factor_arithmetique -> . ID
    (59) factor_arithmetique -> . INTEGER
    (60) factor_arithmetique -> . FLOAT
    (61) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN

    ID              shift and go to state 90
    INTEGER         shift and go to state 108
    FLOAT           shift and go to state 109
    LPAREN          shift and go to state 85

    factor_arithmetique            shift and go to state 115

state 84

    (16) factor -> MINUS factor .

    AND             reduce using rule 16 (factor -> MINUS factor .)
    SEMICOLON       reduce using rule 16 (factor -> MINUS factor .)
    OR              reduce using rule 16 (factor -> MINUS factor .)
    COMMA           reduce using rule 16 (factor -> MINUS factor .)


state 85

    (61) factor_arithmetique -> LPAREN . expression_arithmetique RPAREN
    (52) expression_arithmetique -> . expression_arithmetique PLUS term_arithmetique
    (53) expression_arithmetique -> . expression_arithmetique MINUS term_arithmetique
    (54) expression_arithmetique -> . term_arithmetique
    (55) term_arithmetique -> . term_arithmetique MULTIPLY term_arithmetique
    (56) term_arithmetique -> . term_arithmetique DIVIDE factor_arithmetique
    (57) term_arithmetique -> . factor_arithmetique
    (58) factor_arithmetique -> . ID
    (59) factor_arithmetique -> . INTEGER
    (60) factor_arithmetique -> . FLOAT
    (61) factor_arithmetique -> . LPAREN expression_arithmetique RPAREN

    ID              shift and go to state 90
    INTEGER         shift and go to state 108
    FLOAT           shift and go to state 109
    LPAREN          shift and go to state 85

    expression_arithmetique        shift and go to state 89
    term_arithmetique              shift and go to state 36
    factor_arithmetique            shift and go to state 42

state 86

    (18) factor -> LPAREN INTEGER . RPAREN
    (59) factor_arithmetique -> INTEGER .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 116
    MULTIPLY        reduce using rule 59 (factor_arithmetique -> INTEGER .)
    DIVIDE          reduce using rule 59 (factor_arithmetique -> INTEGER .)
    PLUS            reduce using rule 59 (factor_arithmetique -> INTEGER .)
    MINUS           reduce using rule 59 (factor_arithmetique -> INTEGER .)

  ! RPAREN          [ reduce using rule 59 (factor_arithmetique -> INTEGER .) ]


state 87

    (19) factor -> LPAREN FLOAT . RPAREN
    (60) factor_arithmetique -> FLOAT .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 117
    MULTIPLY        reduce using rule 60 (factor_arithmetique -> FLOAT .)
    DIVIDE          reduce using rule 60 (factor_arithmetique -> FLOAT .)
    PLUS            reduce using rule 60 (factor_arithmetique -> FLOAT .)
    MINUS           reduce using rule 60 (factor_arithmetique -> FLOAT .)

  ! RPAREN          [ reduce using rule 60 (factor_arithmetique -> FLOAT .) ]


state 88

    (20) factor -> LPAREN MINUS . FLOAT RPAREN

    FLOAT           shift and go to state 118


state 89

    (61) factor_arithmetique -> LPAREN expression_arithmetique . RPAREN
    (52) expression_arithmetique -> expression_arithmetique . PLUS term_arithmetique
    (53) expression_arithmetique -> expression_arithmetique . MINUS term_arithmetique

    RPAREN          shift and go to state 119
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 90

    (58) factor_arithmetique -> ID .

    MULTIPLY        reduce using rule 58 (factor_arithmetique -> ID .)
    DIVIDE          reduce using rule 58 (factor_arithmetique -> ID .)
    RPAREN          reduce using rule 58 (factor_arithmetique -> ID .)
    PLUS            reduce using rule 58 (factor_arithmetique -> ID .)
    MINUS           reduce using rule 58 (factor_arithmetique -> ID .)
    SEMICOLON       reduce using rule 58 (factor_arithmetique -> ID .)


state 91

    (49) factor -> NOT ID .

    AND             reduce using rule 49 (factor -> NOT ID .)
    SEMICOLON       reduce using rule 49 (factor -> NOT ID .)
    OR              reduce using rule 49 (factor -> NOT ID .)
    COMMA           reduce using rule 49 (factor -> NOT ID .)


state 92

    (41) array_assignment -> ID LBRACKET expressionTab RBRACKET . EQUALS expressionTab SEMICOLON

    EQUALS          shift and go to state 120


state 93

    (62) statement -> FOR LPAREN initialisation COLON . step COLON BorneSup RPAREN block
    (64) step -> . INTEGER
    (65) step -> . ID

    INTEGER         shift and go to state 122
    ID              shift and go to state 123

    step                           shift and go to state 121

state 94

    (63) initialisation -> ID EQUALS . INTEGER

    INTEGER         shift and go to state 124


state 95

    (50) statement -> type ID EQUALS expression_arithmetique SEMICOLON .

    $end            reduce using rule 50 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    CONST           reduce using rule 50 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    ID              reduce using rule 50 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    FOR             reduce using rule 50 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    INT_TYPE        reduce using rule 50 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    FLOAT_TYPE      reduce using rule 50 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    BOOL_TYPE       reduce using rule 50 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    CHAR_TYPE       reduce using rule 50 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)
    RBRACE          reduce using rule 50 (statement -> type ID EQUALS expression_arithmetique SEMICOLON .)


state 96

    (30) array_declarationTab -> type ID LBRACKET INTEGER RBRACKET . SEMICOLON
    (35) declarationTab -> ID LBRACKET INTEGER RBRACKET .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 125
    COMMA           reduce using rule 35 (declarationTab -> ID LBRACKET INTEGER RBRACKET .)

  ! SEMICOLON       [ reduce using rule 35 (declarationTab -> ID LBRACKET INTEGER RBRACKET .) ]


state 97

    (6) declaration -> ID EQUALS . expression
    (42) expression -> . expression OR term
    (43) expression -> . term
    (44) term -> . term AND factor
    (45) term -> . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (40) factor -> . ID LBRACKET expressionTab RBRACKET
    (46) factor -> . ID
    (47) factor -> . TRUE
    (48) factor -> . FALSE
    (49) factor -> . NOT ID

    INTEGER         shift and go to state 77
    FLOAT           shift and go to state 78
    CHAR            shift and go to state 79
    BOOL            shift and go to state 43
    MINUS           shift and go to state 37
    PLUS            shift and go to state 35
    LPAREN          shift and go to state 80
    ID              shift and go to state 81
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46
    NOT             shift and go to state 47

    expression                     shift and go to state 57
    term                           shift and go to state 34
    factor                         shift and go to state 41

state 98

    (34) declarationTab -> ID EQUALS . expressionTab
    (36) expressionTab -> . ID
    (37) expressionTab -> . FLOAT
    (38) expressionTab -> . INTEGER
    (39) expressionTab -> . CHAR

    ID              shift and go to state 48
    FLOAT           shift and go to state 50
    INTEGER         shift and go to state 51
    CHAR            shift and go to state 52

    expressionTab                  shift and go to state 58

state 99

    (35) declarationTab -> ID LBRACKET . INTEGER RBRACKET

    INTEGER         shift and go to state 126


state 100

    (36) expressionTab -> ID .
    (40) factor -> ID . LBRACKET expressionTab RBRACKET
    (46) factor -> ID .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 36 (expressionTab -> ID .)
    SEMICOLON       reduce using rule 36 (expressionTab -> ID .)
    LBRACKET        shift and go to state 68
    AND             reduce using rule 46 (factor -> ID .)
    OR              reduce using rule 46 (factor -> ID .)

  ! SEMICOLON       [ reduce using rule 46 (factor -> ID .) ]


state 101

    (2) statement -> CONST type ID EQUALS expression . SEMICOLON
    (42) expression -> expression . OR term

    SEMICOLON       shift and go to state 127
    OR              shift and go to state 70


state 102

    (29) const_declarationTab -> CONST type ID EQUALS expressionTab . SEMICOLON

    SEMICOLON       shift and go to state 128


state 103

    (37) expressionTab -> FLOAT .
    (13) factor -> FLOAT .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 13 (factor -> FLOAT .)
    AND             reduce using rule 13 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 13 (factor -> FLOAT .)
    OR              reduce using rule 13 (factor -> FLOAT .)

  ! SEMICOLON       [ reduce using rule 37 (expressionTab -> FLOAT .) ]


state 104

    (38) expressionTab -> INTEGER .
    (12) factor -> INTEGER .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 12 (factor -> INTEGER .)
    AND             reduce using rule 12 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 12 (factor -> INTEGER .)
    OR              reduce using rule 12 (factor -> INTEGER .)

  ! SEMICOLON       [ reduce using rule 38 (expressionTab -> INTEGER .) ]


state 105

    (40) factor -> ID LBRACKET expressionTab . RBRACKET

    RBRACKET        shift and go to state 129


state 106

    (42) expression -> expression OR term .
    (44) term -> term . AND factor

    SEMICOLON       reduce using rule 42 (expression -> expression OR term .)
    OR              reduce using rule 42 (expression -> expression OR term .)
    COMMA           reduce using rule 42 (expression -> expression OR term .)
    AND             shift and go to state 75


state 107

    (52) expression_arithmetique -> expression_arithmetique PLUS term_arithmetique .
    (55) term_arithmetique -> term_arithmetique . MULTIPLY term_arithmetique
    (56) term_arithmetique -> term_arithmetique . DIVIDE factor_arithmetique

    SEMICOLON       reduce using rule 52 (expression_arithmetique -> expression_arithmetique PLUS term_arithmetique .)
    PLUS            reduce using rule 52 (expression_arithmetique -> expression_arithmetique PLUS term_arithmetique .)
    MINUS           reduce using rule 52 (expression_arithmetique -> expression_arithmetique PLUS term_arithmetique .)
    RPAREN          reduce using rule 52 (expression_arithmetique -> expression_arithmetique PLUS term_arithmetique .)
    MULTIPLY        shift and go to state 82
    DIVIDE          shift and go to state 83


state 108

    (59) factor_arithmetique -> INTEGER .

    MULTIPLY        reduce using rule 59 (factor_arithmetique -> INTEGER .)
    DIVIDE          reduce using rule 59 (factor_arithmetique -> INTEGER .)
    SEMICOLON       reduce using rule 59 (factor_arithmetique -> INTEGER .)
    PLUS            reduce using rule 59 (factor_arithmetique -> INTEGER .)
    MINUS           reduce using rule 59 (factor_arithmetique -> INTEGER .)
    RPAREN          reduce using rule 59 (factor_arithmetique -> INTEGER .)


state 109

    (60) factor_arithmetique -> FLOAT .

    MULTIPLY        reduce using rule 60 (factor_arithmetique -> FLOAT .)
    DIVIDE          reduce using rule 60 (factor_arithmetique -> FLOAT .)
    SEMICOLON       reduce using rule 60 (factor_arithmetique -> FLOAT .)
    PLUS            reduce using rule 60 (factor_arithmetique -> FLOAT .)
    MINUS           reduce using rule 60 (factor_arithmetique -> FLOAT .)
    RPAREN          reduce using rule 60 (factor_arithmetique -> FLOAT .)


state 110

    (53) expression_arithmetique -> expression_arithmetique MINUS term_arithmetique .
    (55) term_arithmetique -> term_arithmetique . MULTIPLY term_arithmetique
    (56) term_arithmetique -> term_arithmetique . DIVIDE factor_arithmetique

    SEMICOLON       reduce using rule 53 (expression_arithmetique -> expression_arithmetique MINUS term_arithmetique .)
    PLUS            reduce using rule 53 (expression_arithmetique -> expression_arithmetique MINUS term_arithmetique .)
    MINUS           reduce using rule 53 (expression_arithmetique -> expression_arithmetique MINUS term_arithmetique .)
    RPAREN          reduce using rule 53 (expression_arithmetique -> expression_arithmetique MINUS term_arithmetique .)
    MULTIPLY        shift and go to state 82
    DIVIDE          shift and go to state 83


state 111

    (44) term -> term AND factor .

    AND             reduce using rule 44 (term -> term AND factor .)
    SEMICOLON       reduce using rule 44 (term -> term AND factor .)
    OR              reduce using rule 44 (term -> term AND factor .)
    COMMA           reduce using rule 44 (term -> term AND factor .)


state 112

    (18) factor -> LPAREN INTEGER . RPAREN

    RPAREN          shift and go to state 116


state 113

    (19) factor -> LPAREN FLOAT . RPAREN

    RPAREN          shift and go to state 117


state 114

    (55) term_arithmetique -> term_arithmetique MULTIPLY term_arithmetique .
    (55) term_arithmetique -> term_arithmetique . MULTIPLY term_arithmetique
    (56) term_arithmetique -> term_arithmetique . DIVIDE factor_arithmetique

  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    SEMICOLON       reduce using rule 55 (term_arithmetique -> term_arithmetique MULTIPLY term_arithmetique .)
    PLUS            reduce using rule 55 (term_arithmetique -> term_arithmetique MULTIPLY term_arithmetique .)
    MINUS           reduce using rule 55 (term_arithmetique -> term_arithmetique MULTIPLY term_arithmetique .)
    RPAREN          reduce using rule 55 (term_arithmetique -> term_arithmetique MULTIPLY term_arithmetique .)
    MULTIPLY        shift and go to state 82
    DIVIDE          shift and go to state 83

  ! MULTIPLY        [ reduce using rule 55 (term_arithmetique -> term_arithmetique MULTIPLY term_arithmetique .) ]
  ! DIVIDE          [ reduce using rule 55 (term_arithmetique -> term_arithmetique MULTIPLY term_arithmetique .) ]


state 115

    (56) term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique .

    MULTIPLY        reduce using rule 56 (term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique .)
    DIVIDE          reduce using rule 56 (term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique .)
    SEMICOLON       reduce using rule 56 (term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique .)
    PLUS            reduce using rule 56 (term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique .)
    MINUS           reduce using rule 56 (term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique .)
    RPAREN          reduce using rule 56 (term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique .)


state 116

    (18) factor -> LPAREN INTEGER RPAREN .

    AND             reduce using rule 18 (factor -> LPAREN INTEGER RPAREN .)
    SEMICOLON       reduce using rule 18 (factor -> LPAREN INTEGER RPAREN .)
    OR              reduce using rule 18 (factor -> LPAREN INTEGER RPAREN .)
    COMMA           reduce using rule 18 (factor -> LPAREN INTEGER RPAREN .)


state 117

    (19) factor -> LPAREN FLOAT RPAREN .

    AND             reduce using rule 19 (factor -> LPAREN FLOAT RPAREN .)
    SEMICOLON       reduce using rule 19 (factor -> LPAREN FLOAT RPAREN .)
    OR              reduce using rule 19 (factor -> LPAREN FLOAT RPAREN .)
    COMMA           reduce using rule 19 (factor -> LPAREN FLOAT RPAREN .)


state 118

    (20) factor -> LPAREN MINUS FLOAT . RPAREN

    RPAREN          shift and go to state 130


state 119

    (61) factor_arithmetique -> LPAREN expression_arithmetique RPAREN .

    MULTIPLY        reduce using rule 61 (factor_arithmetique -> LPAREN expression_arithmetique RPAREN .)
    DIVIDE          reduce using rule 61 (factor_arithmetique -> LPAREN expression_arithmetique RPAREN .)
    SEMICOLON       reduce using rule 61 (factor_arithmetique -> LPAREN expression_arithmetique RPAREN .)
    PLUS            reduce using rule 61 (factor_arithmetique -> LPAREN expression_arithmetique RPAREN .)
    MINUS           reduce using rule 61 (factor_arithmetique -> LPAREN expression_arithmetique RPAREN .)
    RPAREN          reduce using rule 61 (factor_arithmetique -> LPAREN expression_arithmetique RPAREN .)


state 120

    (41) array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS . expressionTab SEMICOLON
    (36) expressionTab -> . ID
    (37) expressionTab -> . FLOAT
    (38) expressionTab -> . INTEGER
    (39) expressionTab -> . CHAR

    ID              shift and go to state 48
    FLOAT           shift and go to state 50
    INTEGER         shift and go to state 51
    CHAR            shift and go to state 52

    expressionTab                  shift and go to state 131

state 121

    (62) statement -> FOR LPAREN initialisation COLON step . COLON BorneSup RPAREN block

    COLON           shift and go to state 132


state 122

    (64) step -> INTEGER .

    COLON           reduce using rule 64 (step -> INTEGER .)


state 123

    (65) step -> ID .

    COLON           reduce using rule 65 (step -> ID .)


state 124

    (63) initialisation -> ID EQUALS INTEGER .

    COLON           reduce using rule 63 (initialisation -> ID EQUALS INTEGER .)


state 125

    (30) array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .

    $end            reduce using rule 30 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    CONST           reduce using rule 30 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    ID              reduce using rule 30 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    FOR             reduce using rule 30 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    INT_TYPE        reduce using rule 30 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    FLOAT_TYPE      reduce using rule 30 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    BOOL_TYPE       reduce using rule 30 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    CHAR_TYPE       reduce using rule 30 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    RBRACE          reduce using rule 30 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)


state 126

    (35) declarationTab -> ID LBRACKET INTEGER . RBRACKET

    RBRACKET        shift and go to state 133


state 127

    (2) statement -> CONST type ID EQUALS expression SEMICOLON .

    $end            reduce using rule 2 (statement -> CONST type ID EQUALS expression SEMICOLON .)
    CONST           reduce using rule 2 (statement -> CONST type ID EQUALS expression SEMICOLON .)
    ID              reduce using rule 2 (statement -> CONST type ID EQUALS expression SEMICOLON .)
    FOR             reduce using rule 2 (statement -> CONST type ID EQUALS expression SEMICOLON .)
    INT_TYPE        reduce using rule 2 (statement -> CONST type ID EQUALS expression SEMICOLON .)
    FLOAT_TYPE      reduce using rule 2 (statement -> CONST type ID EQUALS expression SEMICOLON .)
    BOOL_TYPE       reduce using rule 2 (statement -> CONST type ID EQUALS expression SEMICOLON .)
    CHAR_TYPE       reduce using rule 2 (statement -> CONST type ID EQUALS expression SEMICOLON .)
    RBRACE          reduce using rule 2 (statement -> CONST type ID EQUALS expression SEMICOLON .)


state 128

    (29) const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .

    $end            reduce using rule 29 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    CONST           reduce using rule 29 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    ID              reduce using rule 29 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    FOR             reduce using rule 29 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    INT_TYPE        reduce using rule 29 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    FLOAT_TYPE      reduce using rule 29 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    BOOL_TYPE       reduce using rule 29 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    CHAR_TYPE       reduce using rule 29 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    RBRACE          reduce using rule 29 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)


state 129

    (40) factor -> ID LBRACKET expressionTab RBRACKET .

    AND             reduce using rule 40 (factor -> ID LBRACKET expressionTab RBRACKET .)
    SEMICOLON       reduce using rule 40 (factor -> ID LBRACKET expressionTab RBRACKET .)
    OR              reduce using rule 40 (factor -> ID LBRACKET expressionTab RBRACKET .)
    COMMA           reduce using rule 40 (factor -> ID LBRACKET expressionTab RBRACKET .)


state 130

    (20) factor -> LPAREN MINUS FLOAT RPAREN .

    AND             reduce using rule 20 (factor -> LPAREN MINUS FLOAT RPAREN .)
    SEMICOLON       reduce using rule 20 (factor -> LPAREN MINUS FLOAT RPAREN .)
    OR              reduce using rule 20 (factor -> LPAREN MINUS FLOAT RPAREN .)
    COMMA           reduce using rule 20 (factor -> LPAREN MINUS FLOAT RPAREN .)


state 131

    (41) array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab . SEMICOLON

    SEMICOLON       shift and go to state 134


state 132

    (62) statement -> FOR LPAREN initialisation COLON step COLON . BorneSup RPAREN block
    (66) BorneSup -> . ID

    ID              shift and go to state 136

    BorneSup                       shift and go to state 135

state 133

    (35) declarationTab -> ID LBRACKET INTEGER RBRACKET .

    COMMA           reduce using rule 35 (declarationTab -> ID LBRACKET INTEGER RBRACKET .)
    SEMICOLON       reduce using rule 35 (declarationTab -> ID LBRACKET INTEGER RBRACKET .)


state 134

    (41) array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .

    $end            reduce using rule 41 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    CONST           reduce using rule 41 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    ID              reduce using rule 41 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    FOR             reduce using rule 41 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    INT_TYPE        reduce using rule 41 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    FLOAT_TYPE      reduce using rule 41 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    BOOL_TYPE       reduce using rule 41 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    CHAR_TYPE       reduce using rule 41 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    RBRACE          reduce using rule 41 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)


state 135

    (62) statement -> FOR LPAREN initialisation COLON step COLON BorneSup . RPAREN block

    RPAREN          shift and go to state 137


state 136

    (66) BorneSup -> ID .

    RPAREN          reduce using rule 66 (BorneSup -> ID .)


state 137

    (62) statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN . block
    (67) block -> . LBRACE statements RBRACE

    LBRACE          shift and go to state 139

    block                          shift and go to state 138

state 138

    (62) statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .

    $end            reduce using rule 62 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    CONST           reduce using rule 62 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    ID              reduce using rule 62 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    FOR             reduce using rule 62 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    INT_TYPE        reduce using rule 62 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    FLOAT_TYPE      reduce using rule 62 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    BOOL_TYPE       reduce using rule 62 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    CHAR_TYPE       reduce using rule 62 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    RBRACE          reduce using rule 62 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)


state 139

    (67) block -> LBRACE . statements RBRACE
    (21) statements -> . statement
    (22) statements -> . statement statements
    (1) statement -> . type declaration_list SEMICOLON
    (2) statement -> . CONST type ID EQUALS expression SEMICOLON
    (7) statement -> . ID EQUALS expression SEMICOLON
    (23) statement -> . simple_assignment
    (24) statement -> . array_declarationTab
    (25) statement -> . array_assignment
    (26) statement -> . type declarationTab_listTab SEMICOLON
    (27) statement -> . const_declarationTab
    (50) statement -> . type ID EQUALS expression_arithmetique SEMICOLON
    (51) statement -> . ID EQUALS expression_arithmetique SEMICOLON
    (62) statement -> . FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block
    (8) type -> . INT_TYPE
    (9) type -> . FLOAT_TYPE
    (10) type -> . BOOL_TYPE
    (11) type -> . CHAR_TYPE
    (28) simple_assignment -> . ID EQUALS expressionTab SEMICOLON
    (30) array_declarationTab -> . type ID LBRACKET INTEGER RBRACKET SEMICOLON
    (41) array_assignment -> . ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON
    (29) const_declarationTab -> . CONST type ID EQUALS expressionTab SEMICOLON

    CONST           shift and go to state 3
    ID              shift and go to state 4
    FOR             shift and go to state 9
    INT_TYPE        shift and go to state 10
    FLOAT_TYPE      shift and go to state 11
    BOOL_TYPE       shift and go to state 12
    CHAR_TYPE       shift and go to state 13

    statements                     shift and go to state 140
    statement                      shift and go to state 141
    type                           shift and go to state 2
    simple_assignment              shift and go to state 5
    array_declarationTab           shift and go to state 6
    array_assignment               shift and go to state 7
    const_declarationTab           shift and go to state 8

state 140

    (67) block -> LBRACE statements . RBRACE

    RBRACE          shift and go to state 142


state 141

    (21) statements -> statement .
    (22) statements -> statement . statements
    (21) statements -> . statement
    (22) statements -> . statement statements
    (1) statement -> . type declaration_list SEMICOLON
    (2) statement -> . CONST type ID EQUALS expression SEMICOLON
    (7) statement -> . ID EQUALS expression SEMICOLON
    (23) statement -> . simple_assignment
    (24) statement -> . array_declarationTab
    (25) statement -> . array_assignment
    (26) statement -> . type declarationTab_listTab SEMICOLON
    (27) statement -> . const_declarationTab
    (50) statement -> . type ID EQUALS expression_arithmetique SEMICOLON
    (51) statement -> . ID EQUALS expression_arithmetique SEMICOLON
    (62) statement -> . FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block
    (8) type -> . INT_TYPE
    (9) type -> . FLOAT_TYPE
    (10) type -> . BOOL_TYPE
    (11) type -> . CHAR_TYPE
    (28) simple_assignment -> . ID EQUALS expressionTab SEMICOLON
    (30) array_declarationTab -> . type ID LBRACKET INTEGER RBRACKET SEMICOLON
    (41) array_assignment -> . ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON
    (29) const_declarationTab -> . CONST type ID EQUALS expressionTab SEMICOLON

    RBRACE          reduce using rule 21 (statements -> statement .)
    CONST           shift and go to state 3
    ID              shift and go to state 4
    FOR             shift and go to state 9
    INT_TYPE        shift and go to state 10
    FLOAT_TYPE      shift and go to state 11
    BOOL_TYPE       shift and go to state 12
    CHAR_TYPE       shift and go to state 13

    statement                      shift and go to state 141
    statements                     shift and go to state 143
    type                           shift and go to state 2
    simple_assignment              shift and go to state 5
    array_declarationTab           shift and go to state 6
    array_assignment               shift and go to state 7
    const_declarationTab           shift and go to state 8

state 142

    (67) block -> LBRACE statements RBRACE .

    $end            reduce using rule 67 (block -> LBRACE statements RBRACE .)
    CONST           reduce using rule 67 (block -> LBRACE statements RBRACE .)
    ID              reduce using rule 67 (block -> LBRACE statements RBRACE .)
    FOR             reduce using rule 67 (block -> LBRACE statements RBRACE .)
    INT_TYPE        reduce using rule 67 (block -> LBRACE statements RBRACE .)
    FLOAT_TYPE      reduce using rule 67 (block -> LBRACE statements RBRACE .)
    BOOL_TYPE       reduce using rule 67 (block -> LBRACE statements RBRACE .)
    CHAR_TYPE       reduce using rule 67 (block -> LBRACE statements RBRACE .)
    RBRACE          reduce using rule 67 (block -> LBRACE statements RBRACE .)


state 143

    (22) statements -> statement statements .

    RBRACE          reduce using rule 22 (statements -> statement statements .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RPAREN in state 86 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 87 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 96 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 114 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 114 resolved as shift
WARNING: reduce/reduce conflict in state 16 resolved using rule (declaration -> ID)
WARNING: rejected rule (declarationTab -> ID) in state 16
WARNING: reduce/reduce conflict in state 30 resolved using rule (expressionTab -> ID)
WARNING: rejected rule (factor -> ID) in state 30
WARNING: reduce/reduce conflict in state 30 resolved using rule (expressionTab -> ID)
WARNING: rejected rule (factor_arithmetique -> ID) in state 30
WARNING: reduce/reduce conflict in state 38 resolved using rule (factor -> FLOAT)
WARNING: rejected rule (expressionTab -> FLOAT) in state 38
WARNING: reduce/reduce conflict in state 38 resolved using rule (factor -> FLOAT)
WARNING: rejected rule (factor_arithmetique -> FLOAT) in state 38
WARNING: reduce/reduce conflict in state 39 resolved using rule (factor -> INTEGER)
WARNING: rejected rule (expressionTab -> INTEGER) in state 39
WARNING: reduce/reduce conflict in state 39 resolved using rule (factor -> INTEGER)
WARNING: rejected rule (factor_arithmetique -> INTEGER) in state 39
WARNING: reduce/reduce conflict in state 40 resolved using rule (factor -> CHAR)
WARNING: rejected rule (expressionTab -> CHAR) in state 40
WARNING: reduce/reduce conflict in state 55 resolved using rule (expressionTab -> ID)
WARNING: rejected rule (factor_arithmetique -> ID) in state 55
WARNING: reduce/reduce conflict in state 55 resolved using rule (expressionTab -> ID)
WARNING: rejected rule (factor -> ID) in state 55
WARNING: reduce/reduce conflict in state 59 resolved using rule (expressionTab -> FLOAT)
WARNING: rejected rule (factor_arithmetique -> FLOAT) in state 59
WARNING: reduce/reduce conflict in state 59 resolved using rule (factor -> FLOAT)
WARNING: rejected rule (expressionTab -> FLOAT) in state 59
WARNING: reduce/reduce conflict in state 60 resolved using rule (expressionTab -> INTEGER)
WARNING: rejected rule (factor_arithmetique -> INTEGER) in state 60
WARNING: reduce/reduce conflict in state 60 resolved using rule (factor -> INTEGER)
WARNING: rejected rule (expressionTab -> INTEGER) in state 60
WARNING: reduce/reduce conflict in state 100 resolved using rule (expressionTab -> ID)
WARNING: rejected rule (factor -> ID) in state 100
WARNING: reduce/reduce conflict in state 103 resolved using rule (factor -> FLOAT)
WARNING: rejected rule (expressionTab -> FLOAT) in state 103
WARNING: reduce/reduce conflict in state 104 resolved using rule (factor -> INTEGER)
WARNING: rejected rule (expressionTab -> INTEGER) in state 104
