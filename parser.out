Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    DECLARATION
    ELSE
    EQ
    GT
    GTE
    IF
    INSTRUCTION
    LT
    LTE
    NEQ
    NUMBER
    READ
    VAR_GLOBAL
    WRITE

Grammar

Rule 0     S' -> statement
Rule 1     statement -> type declaration_list SEMICOLON
Rule 2     statement -> CONST type ID EQUALS expression SEMICOLON
Rule 3     declaration_list -> declaration
Rule 4     declaration_list -> declaration COMMA declaration_list
Rule 5     declaration -> ID
Rule 6     declaration -> ID EQUALS expression
Rule 7     statement -> ID EQUALS expression SEMICOLON
Rule 8     type -> INT_TYPE
Rule 9     type -> FLOAT_TYPE
Rule 10    type -> BOOL_TYPE
Rule 11    type -> CHAR_TYPE
Rule 12    factor -> INTEGER
Rule 13    factor -> FLOAT
Rule 14    factor -> CHAR
Rule 15    factor -> BOOL
Rule 16    factor -> MINUS factor
Rule 17    factor -> PLUS factor
Rule 18    factor -> LPAREN INTEGER RPAREN
Rule 19    factor -> LPAREN FLOAT RPAREN
Rule 20    factor -> LPAREN MINUS FLOAT RPAREN
Rule 21    statements -> statement
Rule 22    statements -> statement statements
Rule 23    statement -> simple_assignment
Rule 24    statement -> array_declarationTab
Rule 25    statement -> declaration_assignment
Rule 26    statement -> array_assignment
Rule 27    statement -> type declarationTab_listTab SEMICOLON
Rule 28    statement -> const_declarationTab
Rule 29    simple_assignment -> ID EQUALS expressionTab SEMICOLON
Rule 30    const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON
Rule 31    array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON
Rule 32    declarationTab_listTab -> declarationTab
Rule 33    declarationTab_listTab -> declarationTab COMMA declarationTab_listTab
Rule 34    declarationTab -> ID
Rule 35    declarationTab -> ID EQUALS expressionTab
Rule 36    declarationTab -> ID LBRACKET INTEGER RBRACKET
Rule 37    expressionTab -> ID
Rule 38    expressionTab -> FLOAT
Rule 39    expressionTab -> INTEGER
Rule 40    expressionTab -> CHAR
Rule 41    factor -> ID LBRACKET expressionTab RBRACKET
Rule 42    array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON
Rule 43    declaration_assignment -> type ID EQUALS expression SEMICOLON
Rule 44    simple_assignment -> ID EQUALS expression SEMICOLON
Rule 45    expression -> expression OR term
Rule 46    expression -> term
Rule 47    term -> term AND factor
Rule 48    term -> factor
Rule 49    factor -> ID
Rule 50    factor -> TRUE
Rule 51    factor -> FALSE
Rule 52    factor -> NOT ID
Rule 53    statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block
Rule 54    initialisation -> ID EQUALS INTEGER
Rule 55    step -> INTEGER
Rule 56    step -> ID
Rule 57    BorneSup -> ID
Rule 58    block -> LBRACE statements RBRACE
Rule 59    expression_arithmetique -> expression_arithmetique PLUS term_arithmetique
Rule 60    expression_arithmetique -> expression_arithmetique MINUS term_arithmetique
Rule 61    expression_arithmetique -> term_arithmetique
Rule 62    term_arithmetique -> term_arithmetique TIMES factor
Rule 63    term_arithmetique -> term_arithmetique DIVIDE factor_arithmetique
Rule 64    term_arithmetique -> factor_arithmetique
Rule 65    factor_arithmetique -> ID
Rule 66    factor_arithmetique -> LPAREN expression_arithmetique RPAREN

Terminals, with rules where they appear

AND                  : 47
BOOL                 : 15
BOOL_TYPE            : 10
CHAR                 : 14 40
CHAR_TYPE            : 11
COLON                : 53 53
COMMA                : 4 33
COMMENT              : 
CONST                : 2 30
DECLARATION          : 
DIVIDE               : 63
ELSE                 : 
EQ                   : 
EQUALS               : 2 6 7 29 30 35 42 43 44 54
FALSE                : 51
FLOAT                : 13 19 20 38
FLOAT_TYPE           : 9
FOR                  : 53
GT                   : 
GTE                  : 
ID                   : 2 5 6 7 29 30 31 34 35 36 37 41 42 43 44 49 52 54 56 57 65
IF                   : 
INSTRUCTION          : 
INTEGER              : 12 18 31 36 39 54 55
INT_TYPE             : 8
LBRACE               : 58
LBRACKET             : 31 36 41 42
LPAREN               : 18 19 20 53 66
LT                   : 
LTE                  : 
MINUS                : 16 20 60
NEQ                  : 
NOT                  : 52
NUMBER               : 
OR                   : 45
PLUS                 : 17 59
RBRACE               : 58
RBRACKET             : 31 36 41 42
READ                 : 
RPAREN               : 18 19 20 53 66
SEMICOLON            : 1 2 7 27 29 30 31 42 43 44
TIMES                : 62
TRUE                 : 50
VAR_GLOBAL           : 
WRITE                : 
error                : 

Nonterminals, with rules where they appear

BorneSup             : 53
array_assignment     : 26
array_declarationTab : 24
block                : 53
const_declarationTab : 28
declaration          : 3 4
declarationTab       : 32 33
declarationTab_listTab : 27 33
declaration_assignment : 25
declaration_list     : 1 4
expression           : 2 6 7 43 44 45
expressionTab        : 29 30 35 41 42 42
expression_arithmetique : 59 60 66
factor               : 16 17 47 48 62
factor_arithmetique  : 63 64
initialisation       : 53
simple_assignment    : 23
statement            : 21 22 0
statements           : 22 58
step                 : 53
term                 : 45 46 47
term_arithmetique    : 59 60 61 62 63
type                 : 1 2 27 30 31 43

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . type declaration_list SEMICOLON
    (2) statement -> . CONST type ID EQUALS expression SEMICOLON
    (7) statement -> . ID EQUALS expression SEMICOLON
    (23) statement -> . simple_assignment
    (24) statement -> . array_declarationTab
    (25) statement -> . declaration_assignment
    (26) statement -> . array_assignment
    (27) statement -> . type declarationTab_listTab SEMICOLON
    (28) statement -> . const_declarationTab
    (53) statement -> . FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block
    (8) type -> . INT_TYPE
    (9) type -> . FLOAT_TYPE
    (10) type -> . BOOL_TYPE
    (11) type -> . CHAR_TYPE
    (29) simple_assignment -> . ID EQUALS expressionTab SEMICOLON
    (44) simple_assignment -> . ID EQUALS expression SEMICOLON
    (31) array_declarationTab -> . type ID LBRACKET INTEGER RBRACKET SEMICOLON
    (43) declaration_assignment -> . type ID EQUALS expression SEMICOLON
    (42) array_assignment -> . ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON
    (30) const_declarationTab -> . CONST type ID EQUALS expressionTab SEMICOLON

    CONST           shift and go to state 3
    ID              shift and go to state 4
    FOR             shift and go to state 10
    INT_TYPE        shift and go to state 11
    FLOAT_TYPE      shift and go to state 12
    BOOL_TYPE       shift and go to state 13
    CHAR_TYPE       shift and go to state 14

    statement                      shift and go to state 1
    type                           shift and go to state 2
    simple_assignment              shift and go to state 5
    array_declarationTab           shift and go to state 6
    declaration_assignment         shift and go to state 7
    array_assignment               shift and go to state 8
    const_declarationTab           shift and go to state 9

state 1

    (0) S' -> statement .



state 2

    (1) statement -> type . declaration_list SEMICOLON
    (27) statement -> type . declarationTab_listTab SEMICOLON
    (31) array_declarationTab -> type . ID LBRACKET INTEGER RBRACKET SEMICOLON
    (43) declaration_assignment -> type . ID EQUALS expression SEMICOLON
    (3) declaration_list -> . declaration
    (4) declaration_list -> . declaration COMMA declaration_list
    (32) declarationTab_listTab -> . declarationTab
    (33) declarationTab_listTab -> . declarationTab COMMA declarationTab_listTab
    (5) declaration -> . ID
    (6) declaration -> . ID EQUALS expression
    (34) declarationTab -> . ID
    (35) declarationTab -> . ID EQUALS expressionTab
    (36) declarationTab -> . ID LBRACKET INTEGER RBRACKET

    ID              shift and go to state 17

    declaration_list               shift and go to state 15
    declarationTab_listTab         shift and go to state 16
    declaration                    shift and go to state 18
    declarationTab                 shift and go to state 19

state 3

    (2) statement -> CONST . type ID EQUALS expression SEMICOLON
    (30) const_declarationTab -> CONST . type ID EQUALS expressionTab SEMICOLON
    (8) type -> . INT_TYPE
    (9) type -> . FLOAT_TYPE
    (10) type -> . BOOL_TYPE
    (11) type -> . CHAR_TYPE

    INT_TYPE        shift and go to state 11
    FLOAT_TYPE      shift and go to state 12
    BOOL_TYPE       shift and go to state 13
    CHAR_TYPE       shift and go to state 14

    type                           shift and go to state 20

state 4

    (7) statement -> ID . EQUALS expression SEMICOLON
    (29) simple_assignment -> ID . EQUALS expressionTab SEMICOLON
    (44) simple_assignment -> ID . EQUALS expression SEMICOLON
    (42) array_assignment -> ID . LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON

    EQUALS          shift and go to state 21
    LBRACKET        shift and go to state 22


state 5

    (23) statement -> simple_assignment .

    $end            reduce using rule 23 (statement -> simple_assignment .)
    CONST           reduce using rule 23 (statement -> simple_assignment .)
    ID              reduce using rule 23 (statement -> simple_assignment .)
    FOR             reduce using rule 23 (statement -> simple_assignment .)
    INT_TYPE        reduce using rule 23 (statement -> simple_assignment .)
    FLOAT_TYPE      reduce using rule 23 (statement -> simple_assignment .)
    BOOL_TYPE       reduce using rule 23 (statement -> simple_assignment .)
    CHAR_TYPE       reduce using rule 23 (statement -> simple_assignment .)
    RBRACE          reduce using rule 23 (statement -> simple_assignment .)


state 6

    (24) statement -> array_declarationTab .

    $end            reduce using rule 24 (statement -> array_declarationTab .)
    CONST           reduce using rule 24 (statement -> array_declarationTab .)
    ID              reduce using rule 24 (statement -> array_declarationTab .)
    FOR             reduce using rule 24 (statement -> array_declarationTab .)
    INT_TYPE        reduce using rule 24 (statement -> array_declarationTab .)
    FLOAT_TYPE      reduce using rule 24 (statement -> array_declarationTab .)
    BOOL_TYPE       reduce using rule 24 (statement -> array_declarationTab .)
    CHAR_TYPE       reduce using rule 24 (statement -> array_declarationTab .)
    RBRACE          reduce using rule 24 (statement -> array_declarationTab .)


state 7

    (25) statement -> declaration_assignment .

    $end            reduce using rule 25 (statement -> declaration_assignment .)
    CONST           reduce using rule 25 (statement -> declaration_assignment .)
    ID              reduce using rule 25 (statement -> declaration_assignment .)
    FOR             reduce using rule 25 (statement -> declaration_assignment .)
    INT_TYPE        reduce using rule 25 (statement -> declaration_assignment .)
    FLOAT_TYPE      reduce using rule 25 (statement -> declaration_assignment .)
    BOOL_TYPE       reduce using rule 25 (statement -> declaration_assignment .)
    CHAR_TYPE       reduce using rule 25 (statement -> declaration_assignment .)
    RBRACE          reduce using rule 25 (statement -> declaration_assignment .)


state 8

    (26) statement -> array_assignment .

    $end            reduce using rule 26 (statement -> array_assignment .)
    CONST           reduce using rule 26 (statement -> array_assignment .)
    ID              reduce using rule 26 (statement -> array_assignment .)
    FOR             reduce using rule 26 (statement -> array_assignment .)
    INT_TYPE        reduce using rule 26 (statement -> array_assignment .)
    FLOAT_TYPE      reduce using rule 26 (statement -> array_assignment .)
    BOOL_TYPE       reduce using rule 26 (statement -> array_assignment .)
    CHAR_TYPE       reduce using rule 26 (statement -> array_assignment .)
    RBRACE          reduce using rule 26 (statement -> array_assignment .)


state 9

    (28) statement -> const_declarationTab .

    $end            reduce using rule 28 (statement -> const_declarationTab .)
    CONST           reduce using rule 28 (statement -> const_declarationTab .)
    ID              reduce using rule 28 (statement -> const_declarationTab .)
    FOR             reduce using rule 28 (statement -> const_declarationTab .)
    INT_TYPE        reduce using rule 28 (statement -> const_declarationTab .)
    FLOAT_TYPE      reduce using rule 28 (statement -> const_declarationTab .)
    BOOL_TYPE       reduce using rule 28 (statement -> const_declarationTab .)
    CHAR_TYPE       reduce using rule 28 (statement -> const_declarationTab .)
    RBRACE          reduce using rule 28 (statement -> const_declarationTab .)


state 10

    (53) statement -> FOR . LPAREN initialisation COLON step COLON BorneSup RPAREN block

    LPAREN          shift and go to state 23


state 11

    (8) type -> INT_TYPE .

    ID              reduce using rule 8 (type -> INT_TYPE .)


state 12

    (9) type -> FLOAT_TYPE .

    ID              reduce using rule 9 (type -> FLOAT_TYPE .)


state 13

    (10) type -> BOOL_TYPE .

    ID              reduce using rule 10 (type -> BOOL_TYPE .)


state 14

    (11) type -> CHAR_TYPE .

    ID              reduce using rule 11 (type -> CHAR_TYPE .)


state 15

    (1) statement -> type declaration_list . SEMICOLON

    SEMICOLON       shift and go to state 24


state 16

    (27) statement -> type declarationTab_listTab . SEMICOLON

    SEMICOLON       shift and go to state 25


state 17

    (31) array_declarationTab -> type ID . LBRACKET INTEGER RBRACKET SEMICOLON
    (43) declaration_assignment -> type ID . EQUALS expression SEMICOLON
    (5) declaration -> ID .
    (6) declaration -> ID . EQUALS expression
    (34) declarationTab -> ID .
    (35) declarationTab -> ID . EQUALS expressionTab
    (36) declarationTab -> ID . LBRACKET INTEGER RBRACKET

  ! reduce/reduce conflict for COMMA resolved using rule 5 (declaration -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 5 (declaration -> ID .)
    LBRACKET        shift and go to state 26
    EQUALS          shift and go to state 27
    COMMA           reduce using rule 5 (declaration -> ID .)
    SEMICOLON       reduce using rule 5 (declaration -> ID .)

  ! COMMA           [ reduce using rule 34 (declarationTab -> ID .) ]
  ! SEMICOLON       [ reduce using rule 34 (declarationTab -> ID .) ]


state 18

    (3) declaration_list -> declaration .
    (4) declaration_list -> declaration . COMMA declaration_list

    SEMICOLON       reduce using rule 3 (declaration_list -> declaration .)
    COMMA           shift and go to state 28


state 19

    (32) declarationTab_listTab -> declarationTab .
    (33) declarationTab_listTab -> declarationTab . COMMA declarationTab_listTab

    SEMICOLON       reduce using rule 32 (declarationTab_listTab -> declarationTab .)
    COMMA           shift and go to state 29


state 20

    (2) statement -> CONST type . ID EQUALS expression SEMICOLON
    (30) const_declarationTab -> CONST type . ID EQUALS expressionTab SEMICOLON

    ID              shift and go to state 30


state 21

    (7) statement -> ID EQUALS . expression SEMICOLON
    (29) simple_assignment -> ID EQUALS . expressionTab SEMICOLON
    (44) simple_assignment -> ID EQUALS . expression SEMICOLON
    (45) expression -> . expression OR term
    (46) expression -> . term
    (37) expressionTab -> . ID
    (38) expressionTab -> . FLOAT
    (39) expressionTab -> . INTEGER
    (40) expressionTab -> . CHAR
    (47) term -> . term AND factor
    (48) term -> . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (41) factor -> . ID LBRACKET expressionTab RBRACKET
    (49) factor -> . ID
    (50) factor -> . TRUE
    (51) factor -> . FALSE
    (52) factor -> . NOT ID

    ID              shift and go to state 31
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    CHAR            shift and go to state 37
    BOOL            shift and go to state 39
    MINUS           shift and go to state 40
    PLUS            shift and go to state 41
    LPAREN          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NOT             shift and go to state 45

    expression                     shift and go to state 32
    expressionTab                  shift and go to state 33
    term                           shift and go to state 34
    factor                         shift and go to state 38

state 22

    (42) array_assignment -> ID LBRACKET . expressionTab RBRACKET EQUALS expressionTab SEMICOLON
    (37) expressionTab -> . ID
    (38) expressionTab -> . FLOAT
    (39) expressionTab -> . INTEGER
    (40) expressionTab -> . CHAR

    ID              shift and go to state 46
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 49
    CHAR            shift and go to state 50

    expressionTab                  shift and go to state 47

state 23

    (53) statement -> FOR LPAREN . initialisation COLON step COLON BorneSup RPAREN block
    (54) initialisation -> . ID EQUALS INTEGER

    ID              shift and go to state 52

    initialisation                 shift and go to state 51

state 24

    (1) statement -> type declaration_list SEMICOLON .

    $end            reduce using rule 1 (statement -> type declaration_list SEMICOLON .)
    CONST           reduce using rule 1 (statement -> type declaration_list SEMICOLON .)
    ID              reduce using rule 1 (statement -> type declaration_list SEMICOLON .)
    FOR             reduce using rule 1 (statement -> type declaration_list SEMICOLON .)
    INT_TYPE        reduce using rule 1 (statement -> type declaration_list SEMICOLON .)
    FLOAT_TYPE      reduce using rule 1 (statement -> type declaration_list SEMICOLON .)
    BOOL_TYPE       reduce using rule 1 (statement -> type declaration_list SEMICOLON .)
    CHAR_TYPE       reduce using rule 1 (statement -> type declaration_list SEMICOLON .)
    RBRACE          reduce using rule 1 (statement -> type declaration_list SEMICOLON .)


state 25

    (27) statement -> type declarationTab_listTab SEMICOLON .

    $end            reduce using rule 27 (statement -> type declarationTab_listTab SEMICOLON .)
    CONST           reduce using rule 27 (statement -> type declarationTab_listTab SEMICOLON .)
    ID              reduce using rule 27 (statement -> type declarationTab_listTab SEMICOLON .)
    FOR             reduce using rule 27 (statement -> type declarationTab_listTab SEMICOLON .)
    INT_TYPE        reduce using rule 27 (statement -> type declarationTab_listTab SEMICOLON .)
    FLOAT_TYPE      reduce using rule 27 (statement -> type declarationTab_listTab SEMICOLON .)
    BOOL_TYPE       reduce using rule 27 (statement -> type declarationTab_listTab SEMICOLON .)
    CHAR_TYPE       reduce using rule 27 (statement -> type declarationTab_listTab SEMICOLON .)
    RBRACE          reduce using rule 27 (statement -> type declarationTab_listTab SEMICOLON .)


state 26

    (31) array_declarationTab -> type ID LBRACKET . INTEGER RBRACKET SEMICOLON
    (36) declarationTab -> ID LBRACKET . INTEGER RBRACKET

    INTEGER         shift and go to state 53


state 27

    (43) declaration_assignment -> type ID EQUALS . expression SEMICOLON
    (6) declaration -> ID EQUALS . expression
    (35) declarationTab -> ID EQUALS . expressionTab
    (45) expression -> . expression OR term
    (46) expression -> . term
    (37) expressionTab -> . ID
    (38) expressionTab -> . FLOAT
    (39) expressionTab -> . INTEGER
    (40) expressionTab -> . CHAR
    (47) term -> . term AND factor
    (48) term -> . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (41) factor -> . ID LBRACKET expressionTab RBRACKET
    (49) factor -> . ID
    (50) factor -> . TRUE
    (51) factor -> . FALSE
    (52) factor -> . NOT ID

    ID              shift and go to state 31
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    CHAR            shift and go to state 37
    BOOL            shift and go to state 39
    MINUS           shift and go to state 40
    PLUS            shift and go to state 41
    LPAREN          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NOT             shift and go to state 45

    expression                     shift and go to state 54
    expressionTab                  shift and go to state 55
    term                           shift and go to state 34
    factor                         shift and go to state 38

state 28

    (4) declaration_list -> declaration COMMA . declaration_list
    (3) declaration_list -> . declaration
    (4) declaration_list -> . declaration COMMA declaration_list
    (5) declaration -> . ID
    (6) declaration -> . ID EQUALS expression

    ID              shift and go to state 57

    declaration                    shift and go to state 18
    declaration_list               shift and go to state 56

state 29

    (33) declarationTab_listTab -> declarationTab COMMA . declarationTab_listTab
    (32) declarationTab_listTab -> . declarationTab
    (33) declarationTab_listTab -> . declarationTab COMMA declarationTab_listTab
    (34) declarationTab -> . ID
    (35) declarationTab -> . ID EQUALS expressionTab
    (36) declarationTab -> . ID LBRACKET INTEGER RBRACKET

    ID              shift and go to state 59

    declarationTab                 shift and go to state 19
    declarationTab_listTab         shift and go to state 58

state 30

    (2) statement -> CONST type ID . EQUALS expression SEMICOLON
    (30) const_declarationTab -> CONST type ID . EQUALS expressionTab SEMICOLON

    EQUALS          shift and go to state 60


state 31

    (37) expressionTab -> ID .
    (41) factor -> ID . LBRACKET expressionTab RBRACKET
    (49) factor -> ID .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 37 (expressionTab -> ID .)
  ! reduce/reduce conflict for COMMA resolved using rule 37 (expressionTab -> ID .)
    SEMICOLON       reduce using rule 37 (expressionTab -> ID .)
    COMMA           reduce using rule 37 (expressionTab -> ID .)
    LBRACKET        shift and go to state 61
    AND             reduce using rule 49 (factor -> ID .)
    OR              reduce using rule 49 (factor -> ID .)

  ! SEMICOLON       [ reduce using rule 49 (factor -> ID .) ]
  ! COMMA           [ reduce using rule 49 (factor -> ID .) ]


state 32

    (7) statement -> ID EQUALS expression . SEMICOLON
    (44) simple_assignment -> ID EQUALS expression . SEMICOLON
    (45) expression -> expression . OR term

    SEMICOLON       shift and go to state 62
    OR              shift and go to state 63


state 33

    (29) simple_assignment -> ID EQUALS expressionTab . SEMICOLON

    SEMICOLON       shift and go to state 64


state 34

    (46) expression -> term .
    (47) term -> term . AND factor

    SEMICOLON       reduce using rule 46 (expression -> term .)
    OR              reduce using rule 46 (expression -> term .)
    COMMA           reduce using rule 46 (expression -> term .)
    AND             shift and go to state 65


state 35

    (38) expressionTab -> FLOAT .
    (13) factor -> FLOAT .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 13 (factor -> FLOAT .)
  ! reduce/reduce conflict for COMMA resolved using rule 13 (factor -> FLOAT .)
    AND             reduce using rule 13 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 13 (factor -> FLOAT .)
    OR              reduce using rule 13 (factor -> FLOAT .)
    COMMA           reduce using rule 13 (factor -> FLOAT .)

  ! SEMICOLON       [ reduce using rule 38 (expressionTab -> FLOAT .) ]
  ! COMMA           [ reduce using rule 38 (expressionTab -> FLOAT .) ]


state 36

    (39) expressionTab -> INTEGER .
    (12) factor -> INTEGER .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 12 (factor -> INTEGER .)
  ! reduce/reduce conflict for COMMA resolved using rule 12 (factor -> INTEGER .)
    AND             reduce using rule 12 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 12 (factor -> INTEGER .)
    OR              reduce using rule 12 (factor -> INTEGER .)
    COMMA           reduce using rule 12 (factor -> INTEGER .)

  ! SEMICOLON       [ reduce using rule 39 (expressionTab -> INTEGER .) ]
  ! COMMA           [ reduce using rule 39 (expressionTab -> INTEGER .) ]


state 37

    (40) expressionTab -> CHAR .
    (14) factor -> CHAR .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 14 (factor -> CHAR .)
  ! reduce/reduce conflict for COMMA resolved using rule 14 (factor -> CHAR .)
    AND             reduce using rule 14 (factor -> CHAR .)
    SEMICOLON       reduce using rule 14 (factor -> CHAR .)
    OR              reduce using rule 14 (factor -> CHAR .)
    COMMA           reduce using rule 14 (factor -> CHAR .)

  ! SEMICOLON       [ reduce using rule 40 (expressionTab -> CHAR .) ]
  ! COMMA           [ reduce using rule 40 (expressionTab -> CHAR .) ]


state 38

    (48) term -> factor .

    AND             reduce using rule 48 (term -> factor .)
    SEMICOLON       reduce using rule 48 (term -> factor .)
    OR              reduce using rule 48 (term -> factor .)
    COMMA           reduce using rule 48 (term -> factor .)


state 39

    (15) factor -> BOOL .

    AND             reduce using rule 15 (factor -> BOOL .)
    SEMICOLON       reduce using rule 15 (factor -> BOOL .)
    OR              reduce using rule 15 (factor -> BOOL .)
    COMMA           reduce using rule 15 (factor -> BOOL .)


state 40

    (16) factor -> MINUS . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (41) factor -> . ID LBRACKET expressionTab RBRACKET
    (49) factor -> . ID
    (50) factor -> . TRUE
    (51) factor -> . FALSE
    (52) factor -> . NOT ID

    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    CHAR            shift and go to state 69
    BOOL            shift and go to state 39
    MINUS           shift and go to state 40
    PLUS            shift and go to state 41
    LPAREN          shift and go to state 42
    ID              shift and go to state 70
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NOT             shift and go to state 45

    factor                         shift and go to state 66

state 41

    (17) factor -> PLUS . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (41) factor -> . ID LBRACKET expressionTab RBRACKET
    (49) factor -> . ID
    (50) factor -> . TRUE
    (51) factor -> . FALSE
    (52) factor -> . NOT ID

    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    CHAR            shift and go to state 69
    BOOL            shift and go to state 39
    MINUS           shift and go to state 40
    PLUS            shift and go to state 41
    LPAREN          shift and go to state 42
    ID              shift and go to state 70
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NOT             shift and go to state 45

    factor                         shift and go to state 71

state 42

    (18) factor -> LPAREN . INTEGER RPAREN
    (19) factor -> LPAREN . FLOAT RPAREN
    (20) factor -> LPAREN . MINUS FLOAT RPAREN

    INTEGER         shift and go to state 72
    FLOAT           shift and go to state 73
    MINUS           shift and go to state 74


state 43

    (50) factor -> TRUE .

    AND             reduce using rule 50 (factor -> TRUE .)
    SEMICOLON       reduce using rule 50 (factor -> TRUE .)
    OR              reduce using rule 50 (factor -> TRUE .)
    COMMA           reduce using rule 50 (factor -> TRUE .)


state 44

    (51) factor -> FALSE .

    AND             reduce using rule 51 (factor -> FALSE .)
    SEMICOLON       reduce using rule 51 (factor -> FALSE .)
    OR              reduce using rule 51 (factor -> FALSE .)
    COMMA           reduce using rule 51 (factor -> FALSE .)


state 45

    (52) factor -> NOT . ID

    ID              shift and go to state 75


state 46

    (37) expressionTab -> ID .

    RBRACKET        reduce using rule 37 (expressionTab -> ID .)
    COMMA           reduce using rule 37 (expressionTab -> ID .)
    SEMICOLON       reduce using rule 37 (expressionTab -> ID .)


state 47

    (42) array_assignment -> ID LBRACKET expressionTab . RBRACKET EQUALS expressionTab SEMICOLON

    RBRACKET        shift and go to state 76


state 48

    (38) expressionTab -> FLOAT .

    RBRACKET        reduce using rule 38 (expressionTab -> FLOAT .)
    COMMA           reduce using rule 38 (expressionTab -> FLOAT .)
    SEMICOLON       reduce using rule 38 (expressionTab -> FLOAT .)


state 49

    (39) expressionTab -> INTEGER .

    RBRACKET        reduce using rule 39 (expressionTab -> INTEGER .)
    COMMA           reduce using rule 39 (expressionTab -> INTEGER .)
    SEMICOLON       reduce using rule 39 (expressionTab -> INTEGER .)


state 50

    (40) expressionTab -> CHAR .

    RBRACKET        reduce using rule 40 (expressionTab -> CHAR .)
    COMMA           reduce using rule 40 (expressionTab -> CHAR .)
    SEMICOLON       reduce using rule 40 (expressionTab -> CHAR .)


state 51

    (53) statement -> FOR LPAREN initialisation . COLON step COLON BorneSup RPAREN block

    COLON           shift and go to state 77


state 52

    (54) initialisation -> ID . EQUALS INTEGER

    EQUALS          shift and go to state 78


state 53

    (31) array_declarationTab -> type ID LBRACKET INTEGER . RBRACKET SEMICOLON
    (36) declarationTab -> ID LBRACKET INTEGER . RBRACKET

    RBRACKET        shift and go to state 79


state 54

    (43) declaration_assignment -> type ID EQUALS expression . SEMICOLON
    (6) declaration -> ID EQUALS expression .
    (45) expression -> expression . OR term

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 80
    COMMA           reduce using rule 6 (declaration -> ID EQUALS expression .)
    OR              shift and go to state 63

  ! SEMICOLON       [ reduce using rule 6 (declaration -> ID EQUALS expression .) ]


state 55

    (35) declarationTab -> ID EQUALS expressionTab .

    COMMA           reduce using rule 35 (declarationTab -> ID EQUALS expressionTab .)
    SEMICOLON       reduce using rule 35 (declarationTab -> ID EQUALS expressionTab .)


state 56

    (4) declaration_list -> declaration COMMA declaration_list .

    SEMICOLON       reduce using rule 4 (declaration_list -> declaration COMMA declaration_list .)


state 57

    (5) declaration -> ID .
    (6) declaration -> ID . EQUALS expression

    COMMA           reduce using rule 5 (declaration -> ID .)
    SEMICOLON       reduce using rule 5 (declaration -> ID .)
    EQUALS          shift and go to state 81


state 58

    (33) declarationTab_listTab -> declarationTab COMMA declarationTab_listTab .

    SEMICOLON       reduce using rule 33 (declarationTab_listTab -> declarationTab COMMA declarationTab_listTab .)


state 59

    (34) declarationTab -> ID .
    (35) declarationTab -> ID . EQUALS expressionTab
    (36) declarationTab -> ID . LBRACKET INTEGER RBRACKET

    COMMA           reduce using rule 34 (declarationTab -> ID .)
    SEMICOLON       reduce using rule 34 (declarationTab -> ID .)
    EQUALS          shift and go to state 82
    LBRACKET        shift and go to state 83


state 60

    (2) statement -> CONST type ID EQUALS . expression SEMICOLON
    (30) const_declarationTab -> CONST type ID EQUALS . expressionTab SEMICOLON
    (45) expression -> . expression OR term
    (46) expression -> . term
    (37) expressionTab -> . ID
    (38) expressionTab -> . FLOAT
    (39) expressionTab -> . INTEGER
    (40) expressionTab -> . CHAR
    (47) term -> . term AND factor
    (48) term -> . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (41) factor -> . ID LBRACKET expressionTab RBRACKET
    (49) factor -> . ID
    (50) factor -> . TRUE
    (51) factor -> . FALSE
    (52) factor -> . NOT ID

    ID              shift and go to state 31
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    CHAR            shift and go to state 37
    BOOL            shift and go to state 39
    MINUS           shift and go to state 40
    PLUS            shift and go to state 41
    LPAREN          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NOT             shift and go to state 45

    expression                     shift and go to state 84
    expressionTab                  shift and go to state 85
    term                           shift and go to state 34
    factor                         shift and go to state 38

state 61

    (41) factor -> ID LBRACKET . expressionTab RBRACKET
    (37) expressionTab -> . ID
    (38) expressionTab -> . FLOAT
    (39) expressionTab -> . INTEGER
    (40) expressionTab -> . CHAR

    ID              shift and go to state 46
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 49
    CHAR            shift and go to state 50

    expressionTab                  shift and go to state 86

state 62

    (7) statement -> ID EQUALS expression SEMICOLON .
    (44) simple_assignment -> ID EQUALS expression SEMICOLON .

  ! reduce/reduce conflict for $end resolved using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
  ! reduce/reduce conflict for CONST resolved using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
  ! reduce/reduce conflict for ID resolved using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
  ! reduce/reduce conflict for FOR resolved using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
  ! reduce/reduce conflict for INT_TYPE resolved using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
  ! reduce/reduce conflict for FLOAT_TYPE resolved using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
  ! reduce/reduce conflict for BOOL_TYPE resolved using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
  ! reduce/reduce conflict for CHAR_TYPE resolved using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
  ! reduce/reduce conflict for RBRACE resolved using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
    $end            reduce using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
    CONST           reduce using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
    ID              reduce using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
    FOR             reduce using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
    INT_TYPE        reduce using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
    FLOAT_TYPE      reduce using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
    BOOL_TYPE       reduce using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
    CHAR_TYPE       reduce using rule 7 (statement -> ID EQUALS expression SEMICOLON .)
    RBRACE          reduce using rule 7 (statement -> ID EQUALS expression SEMICOLON .)

  ! $end            [ reduce using rule 44 (simple_assignment -> ID EQUALS expression SEMICOLON .) ]
  ! CONST           [ reduce using rule 44 (simple_assignment -> ID EQUALS expression SEMICOLON .) ]
  ! ID              [ reduce using rule 44 (simple_assignment -> ID EQUALS expression SEMICOLON .) ]
  ! FOR             [ reduce using rule 44 (simple_assignment -> ID EQUALS expression SEMICOLON .) ]
  ! INT_TYPE        [ reduce using rule 44 (simple_assignment -> ID EQUALS expression SEMICOLON .) ]
  ! FLOAT_TYPE      [ reduce using rule 44 (simple_assignment -> ID EQUALS expression SEMICOLON .) ]
  ! BOOL_TYPE       [ reduce using rule 44 (simple_assignment -> ID EQUALS expression SEMICOLON .) ]
  ! CHAR_TYPE       [ reduce using rule 44 (simple_assignment -> ID EQUALS expression SEMICOLON .) ]
  ! RBRACE          [ reduce using rule 44 (simple_assignment -> ID EQUALS expression SEMICOLON .) ]


state 63

    (45) expression -> expression OR . term
    (47) term -> . term AND factor
    (48) term -> . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (41) factor -> . ID LBRACKET expressionTab RBRACKET
    (49) factor -> . ID
    (50) factor -> . TRUE
    (51) factor -> . FALSE
    (52) factor -> . NOT ID

    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    CHAR            shift and go to state 69
    BOOL            shift and go to state 39
    MINUS           shift and go to state 40
    PLUS            shift and go to state 41
    LPAREN          shift and go to state 42
    ID              shift and go to state 70
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NOT             shift and go to state 45

    term                           shift and go to state 87
    factor                         shift and go to state 38

state 64

    (29) simple_assignment -> ID EQUALS expressionTab SEMICOLON .

    $end            reduce using rule 29 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    CONST           reduce using rule 29 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    ID              reduce using rule 29 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    FOR             reduce using rule 29 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    INT_TYPE        reduce using rule 29 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    FLOAT_TYPE      reduce using rule 29 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    BOOL_TYPE       reduce using rule 29 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    CHAR_TYPE       reduce using rule 29 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)
    RBRACE          reduce using rule 29 (simple_assignment -> ID EQUALS expressionTab SEMICOLON .)


state 65

    (47) term -> term AND . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (41) factor -> . ID LBRACKET expressionTab RBRACKET
    (49) factor -> . ID
    (50) factor -> . TRUE
    (51) factor -> . FALSE
    (52) factor -> . NOT ID

    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    CHAR            shift and go to state 69
    BOOL            shift and go to state 39
    MINUS           shift and go to state 40
    PLUS            shift and go to state 41
    LPAREN          shift and go to state 42
    ID              shift and go to state 70
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NOT             shift and go to state 45

    factor                         shift and go to state 88

state 66

    (16) factor -> MINUS factor .

    AND             reduce using rule 16 (factor -> MINUS factor .)
    SEMICOLON       reduce using rule 16 (factor -> MINUS factor .)
    OR              reduce using rule 16 (factor -> MINUS factor .)
    COMMA           reduce using rule 16 (factor -> MINUS factor .)


state 67

    (12) factor -> INTEGER .

    AND             reduce using rule 12 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 12 (factor -> INTEGER .)
    OR              reduce using rule 12 (factor -> INTEGER .)
    COMMA           reduce using rule 12 (factor -> INTEGER .)


state 68

    (13) factor -> FLOAT .

    AND             reduce using rule 13 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 13 (factor -> FLOAT .)
    OR              reduce using rule 13 (factor -> FLOAT .)
    COMMA           reduce using rule 13 (factor -> FLOAT .)


state 69

    (14) factor -> CHAR .

    AND             reduce using rule 14 (factor -> CHAR .)
    SEMICOLON       reduce using rule 14 (factor -> CHAR .)
    OR              reduce using rule 14 (factor -> CHAR .)
    COMMA           reduce using rule 14 (factor -> CHAR .)


state 70

    (41) factor -> ID . LBRACKET expressionTab RBRACKET
    (49) factor -> ID .

    LBRACKET        shift and go to state 61
    AND             reduce using rule 49 (factor -> ID .)
    SEMICOLON       reduce using rule 49 (factor -> ID .)
    OR              reduce using rule 49 (factor -> ID .)
    COMMA           reduce using rule 49 (factor -> ID .)


state 71

    (17) factor -> PLUS factor .

    AND             reduce using rule 17 (factor -> PLUS factor .)
    SEMICOLON       reduce using rule 17 (factor -> PLUS factor .)
    OR              reduce using rule 17 (factor -> PLUS factor .)
    COMMA           reduce using rule 17 (factor -> PLUS factor .)


state 72

    (18) factor -> LPAREN INTEGER . RPAREN

    RPAREN          shift and go to state 89


state 73

    (19) factor -> LPAREN FLOAT . RPAREN

    RPAREN          shift and go to state 90


state 74

    (20) factor -> LPAREN MINUS . FLOAT RPAREN

    FLOAT           shift and go to state 91


state 75

    (52) factor -> NOT ID .

    AND             reduce using rule 52 (factor -> NOT ID .)
    SEMICOLON       reduce using rule 52 (factor -> NOT ID .)
    OR              reduce using rule 52 (factor -> NOT ID .)
    COMMA           reduce using rule 52 (factor -> NOT ID .)


state 76

    (42) array_assignment -> ID LBRACKET expressionTab RBRACKET . EQUALS expressionTab SEMICOLON

    EQUALS          shift and go to state 92


state 77

    (53) statement -> FOR LPAREN initialisation COLON . step COLON BorneSup RPAREN block
    (55) step -> . INTEGER
    (56) step -> . ID

    INTEGER         shift and go to state 94
    ID              shift and go to state 95

    step                           shift and go to state 93

state 78

    (54) initialisation -> ID EQUALS . INTEGER

    INTEGER         shift and go to state 96


state 79

    (31) array_declarationTab -> type ID LBRACKET INTEGER RBRACKET . SEMICOLON
    (36) declarationTab -> ID LBRACKET INTEGER RBRACKET .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 97
    COMMA           reduce using rule 36 (declarationTab -> ID LBRACKET INTEGER RBRACKET .)

  ! SEMICOLON       [ reduce using rule 36 (declarationTab -> ID LBRACKET INTEGER RBRACKET .) ]


state 80

    (43) declaration_assignment -> type ID EQUALS expression SEMICOLON .

    $end            reduce using rule 43 (declaration_assignment -> type ID EQUALS expression SEMICOLON .)
    CONST           reduce using rule 43 (declaration_assignment -> type ID EQUALS expression SEMICOLON .)
    ID              reduce using rule 43 (declaration_assignment -> type ID EQUALS expression SEMICOLON .)
    FOR             reduce using rule 43 (declaration_assignment -> type ID EQUALS expression SEMICOLON .)
    INT_TYPE        reduce using rule 43 (declaration_assignment -> type ID EQUALS expression SEMICOLON .)
    FLOAT_TYPE      reduce using rule 43 (declaration_assignment -> type ID EQUALS expression SEMICOLON .)
    BOOL_TYPE       reduce using rule 43 (declaration_assignment -> type ID EQUALS expression SEMICOLON .)
    CHAR_TYPE       reduce using rule 43 (declaration_assignment -> type ID EQUALS expression SEMICOLON .)
    RBRACE          reduce using rule 43 (declaration_assignment -> type ID EQUALS expression SEMICOLON .)


state 81

    (6) declaration -> ID EQUALS . expression
    (45) expression -> . expression OR term
    (46) expression -> . term
    (47) term -> . term AND factor
    (48) term -> . factor
    (12) factor -> . INTEGER
    (13) factor -> . FLOAT
    (14) factor -> . CHAR
    (15) factor -> . BOOL
    (16) factor -> . MINUS factor
    (17) factor -> . PLUS factor
    (18) factor -> . LPAREN INTEGER RPAREN
    (19) factor -> . LPAREN FLOAT RPAREN
    (20) factor -> . LPAREN MINUS FLOAT RPAREN
    (41) factor -> . ID LBRACKET expressionTab RBRACKET
    (49) factor -> . ID
    (50) factor -> . TRUE
    (51) factor -> . FALSE
    (52) factor -> . NOT ID

    INTEGER         shift and go to state 67
    FLOAT           shift and go to state 68
    CHAR            shift and go to state 69
    BOOL            shift and go to state 39
    MINUS           shift and go to state 40
    PLUS            shift and go to state 41
    LPAREN          shift and go to state 42
    ID              shift and go to state 70
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NOT             shift and go to state 45

    expression                     shift and go to state 98
    term                           shift and go to state 34
    factor                         shift and go to state 38

state 82

    (35) declarationTab -> ID EQUALS . expressionTab
    (37) expressionTab -> . ID
    (38) expressionTab -> . FLOAT
    (39) expressionTab -> . INTEGER
    (40) expressionTab -> . CHAR

    ID              shift and go to state 46
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 49
    CHAR            shift and go to state 50

    expressionTab                  shift and go to state 55

state 83

    (36) declarationTab -> ID LBRACKET . INTEGER RBRACKET

    INTEGER         shift and go to state 99


state 84

    (2) statement -> CONST type ID EQUALS expression . SEMICOLON
    (45) expression -> expression . OR term

    SEMICOLON       shift and go to state 100
    OR              shift and go to state 63


state 85

    (30) const_declarationTab -> CONST type ID EQUALS expressionTab . SEMICOLON

    SEMICOLON       shift and go to state 101


state 86

    (41) factor -> ID LBRACKET expressionTab . RBRACKET

    RBRACKET        shift and go to state 102


state 87

    (45) expression -> expression OR term .
    (47) term -> term . AND factor

    SEMICOLON       reduce using rule 45 (expression -> expression OR term .)
    OR              reduce using rule 45 (expression -> expression OR term .)
    COMMA           reduce using rule 45 (expression -> expression OR term .)
    AND             shift and go to state 65


state 88

    (47) term -> term AND factor .

    AND             reduce using rule 47 (term -> term AND factor .)
    SEMICOLON       reduce using rule 47 (term -> term AND factor .)
    OR              reduce using rule 47 (term -> term AND factor .)
    COMMA           reduce using rule 47 (term -> term AND factor .)


state 89

    (18) factor -> LPAREN INTEGER RPAREN .

    AND             reduce using rule 18 (factor -> LPAREN INTEGER RPAREN .)
    SEMICOLON       reduce using rule 18 (factor -> LPAREN INTEGER RPAREN .)
    OR              reduce using rule 18 (factor -> LPAREN INTEGER RPAREN .)
    COMMA           reduce using rule 18 (factor -> LPAREN INTEGER RPAREN .)


state 90

    (19) factor -> LPAREN FLOAT RPAREN .

    AND             reduce using rule 19 (factor -> LPAREN FLOAT RPAREN .)
    SEMICOLON       reduce using rule 19 (factor -> LPAREN FLOAT RPAREN .)
    OR              reduce using rule 19 (factor -> LPAREN FLOAT RPAREN .)
    COMMA           reduce using rule 19 (factor -> LPAREN FLOAT RPAREN .)


state 91

    (20) factor -> LPAREN MINUS FLOAT . RPAREN

    RPAREN          shift and go to state 103


state 92

    (42) array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS . expressionTab SEMICOLON
    (37) expressionTab -> . ID
    (38) expressionTab -> . FLOAT
    (39) expressionTab -> . INTEGER
    (40) expressionTab -> . CHAR

    ID              shift and go to state 46
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 49
    CHAR            shift and go to state 50

    expressionTab                  shift and go to state 104

state 93

    (53) statement -> FOR LPAREN initialisation COLON step . COLON BorneSup RPAREN block

    COLON           shift and go to state 105


state 94

    (55) step -> INTEGER .

    COLON           reduce using rule 55 (step -> INTEGER .)


state 95

    (56) step -> ID .

    COLON           reduce using rule 56 (step -> ID .)


state 96

    (54) initialisation -> ID EQUALS INTEGER .

    COLON           reduce using rule 54 (initialisation -> ID EQUALS INTEGER .)


state 97

    (31) array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .

    $end            reduce using rule 31 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    CONST           reduce using rule 31 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    ID              reduce using rule 31 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    FOR             reduce using rule 31 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    INT_TYPE        reduce using rule 31 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    FLOAT_TYPE      reduce using rule 31 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    BOOL_TYPE       reduce using rule 31 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    CHAR_TYPE       reduce using rule 31 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)
    RBRACE          reduce using rule 31 (array_declarationTab -> type ID LBRACKET INTEGER RBRACKET SEMICOLON .)


state 98

    (6) declaration -> ID EQUALS expression .
    (45) expression -> expression . OR term

    COMMA           reduce using rule 6 (declaration -> ID EQUALS expression .)
    SEMICOLON       reduce using rule 6 (declaration -> ID EQUALS expression .)
    OR              shift and go to state 63


state 99

    (36) declarationTab -> ID LBRACKET INTEGER . RBRACKET

    RBRACKET        shift and go to state 106


state 100

    (2) statement -> CONST type ID EQUALS expression SEMICOLON .

    $end            reduce using rule 2 (statement -> CONST type ID EQUALS expression SEMICOLON .)
    CONST           reduce using rule 2 (statement -> CONST type ID EQUALS expression SEMICOLON .)
    ID              reduce using rule 2 (statement -> CONST type ID EQUALS expression SEMICOLON .)
    FOR             reduce using rule 2 (statement -> CONST type ID EQUALS expression SEMICOLON .)
    INT_TYPE        reduce using rule 2 (statement -> CONST type ID EQUALS expression SEMICOLON .)
    FLOAT_TYPE      reduce using rule 2 (statement -> CONST type ID EQUALS expression SEMICOLON .)
    BOOL_TYPE       reduce using rule 2 (statement -> CONST type ID EQUALS expression SEMICOLON .)
    CHAR_TYPE       reduce using rule 2 (statement -> CONST type ID EQUALS expression SEMICOLON .)
    RBRACE          reduce using rule 2 (statement -> CONST type ID EQUALS expression SEMICOLON .)


state 101

    (30) const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .

    $end            reduce using rule 30 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    CONST           reduce using rule 30 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    ID              reduce using rule 30 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    FOR             reduce using rule 30 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    INT_TYPE        reduce using rule 30 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    FLOAT_TYPE      reduce using rule 30 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    BOOL_TYPE       reduce using rule 30 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    CHAR_TYPE       reduce using rule 30 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)
    RBRACE          reduce using rule 30 (const_declarationTab -> CONST type ID EQUALS expressionTab SEMICOLON .)


state 102

    (41) factor -> ID LBRACKET expressionTab RBRACKET .

    AND             reduce using rule 41 (factor -> ID LBRACKET expressionTab RBRACKET .)
    SEMICOLON       reduce using rule 41 (factor -> ID LBRACKET expressionTab RBRACKET .)
    OR              reduce using rule 41 (factor -> ID LBRACKET expressionTab RBRACKET .)
    COMMA           reduce using rule 41 (factor -> ID LBRACKET expressionTab RBRACKET .)


state 103

    (20) factor -> LPAREN MINUS FLOAT RPAREN .

    AND             reduce using rule 20 (factor -> LPAREN MINUS FLOAT RPAREN .)
    SEMICOLON       reduce using rule 20 (factor -> LPAREN MINUS FLOAT RPAREN .)
    OR              reduce using rule 20 (factor -> LPAREN MINUS FLOAT RPAREN .)
    COMMA           reduce using rule 20 (factor -> LPAREN MINUS FLOAT RPAREN .)


state 104

    (42) array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab . SEMICOLON

    SEMICOLON       shift and go to state 107


state 105

    (53) statement -> FOR LPAREN initialisation COLON step COLON . BorneSup RPAREN block
    (57) BorneSup -> . ID

    ID              shift and go to state 109

    BorneSup                       shift and go to state 108

state 106

    (36) declarationTab -> ID LBRACKET INTEGER RBRACKET .

    COMMA           reduce using rule 36 (declarationTab -> ID LBRACKET INTEGER RBRACKET .)
    SEMICOLON       reduce using rule 36 (declarationTab -> ID LBRACKET INTEGER RBRACKET .)


state 107

    (42) array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .

    $end            reduce using rule 42 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    CONST           reduce using rule 42 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    ID              reduce using rule 42 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    FOR             reduce using rule 42 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    INT_TYPE        reduce using rule 42 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    FLOAT_TYPE      reduce using rule 42 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    BOOL_TYPE       reduce using rule 42 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    CHAR_TYPE       reduce using rule 42 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)
    RBRACE          reduce using rule 42 (array_assignment -> ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON .)


state 108

    (53) statement -> FOR LPAREN initialisation COLON step COLON BorneSup . RPAREN block

    RPAREN          shift and go to state 110


state 109

    (57) BorneSup -> ID .

    RPAREN          reduce using rule 57 (BorneSup -> ID .)


state 110

    (53) statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN . block
    (58) block -> . LBRACE statements RBRACE

    LBRACE          shift and go to state 112

    block                          shift and go to state 111

state 111

    (53) statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .

    $end            reduce using rule 53 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    CONST           reduce using rule 53 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    ID              reduce using rule 53 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    FOR             reduce using rule 53 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    INT_TYPE        reduce using rule 53 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    FLOAT_TYPE      reduce using rule 53 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    BOOL_TYPE       reduce using rule 53 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    CHAR_TYPE       reduce using rule 53 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)
    RBRACE          reduce using rule 53 (statement -> FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block .)


state 112

    (58) block -> LBRACE . statements RBRACE
    (21) statements -> . statement
    (22) statements -> . statement statements
    (1) statement -> . type declaration_list SEMICOLON
    (2) statement -> . CONST type ID EQUALS expression SEMICOLON
    (7) statement -> . ID EQUALS expression SEMICOLON
    (23) statement -> . simple_assignment
    (24) statement -> . array_declarationTab
    (25) statement -> . declaration_assignment
    (26) statement -> . array_assignment
    (27) statement -> . type declarationTab_listTab SEMICOLON
    (28) statement -> . const_declarationTab
    (53) statement -> . FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block
    (8) type -> . INT_TYPE
    (9) type -> . FLOAT_TYPE
    (10) type -> . BOOL_TYPE
    (11) type -> . CHAR_TYPE
    (29) simple_assignment -> . ID EQUALS expressionTab SEMICOLON
    (44) simple_assignment -> . ID EQUALS expression SEMICOLON
    (31) array_declarationTab -> . type ID LBRACKET INTEGER RBRACKET SEMICOLON
    (43) declaration_assignment -> . type ID EQUALS expression SEMICOLON
    (42) array_assignment -> . ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON
    (30) const_declarationTab -> . CONST type ID EQUALS expressionTab SEMICOLON

    CONST           shift and go to state 3
    ID              shift and go to state 4
    FOR             shift and go to state 10
    INT_TYPE        shift and go to state 11
    FLOAT_TYPE      shift and go to state 12
    BOOL_TYPE       shift and go to state 13
    CHAR_TYPE       shift and go to state 14

    statements                     shift and go to state 113
    statement                      shift and go to state 114
    type                           shift and go to state 2
    simple_assignment              shift and go to state 5
    array_declarationTab           shift and go to state 6
    declaration_assignment         shift and go to state 7
    array_assignment               shift and go to state 8
    const_declarationTab           shift and go to state 9

state 113

    (58) block -> LBRACE statements . RBRACE

    RBRACE          shift and go to state 115


state 114

    (21) statements -> statement .
    (22) statements -> statement . statements
    (21) statements -> . statement
    (22) statements -> . statement statements
    (1) statement -> . type declaration_list SEMICOLON
    (2) statement -> . CONST type ID EQUALS expression SEMICOLON
    (7) statement -> . ID EQUALS expression SEMICOLON
    (23) statement -> . simple_assignment
    (24) statement -> . array_declarationTab
    (25) statement -> . declaration_assignment
    (26) statement -> . array_assignment
    (27) statement -> . type declarationTab_listTab SEMICOLON
    (28) statement -> . const_declarationTab
    (53) statement -> . FOR LPAREN initialisation COLON step COLON BorneSup RPAREN block
    (8) type -> . INT_TYPE
    (9) type -> . FLOAT_TYPE
    (10) type -> . BOOL_TYPE
    (11) type -> . CHAR_TYPE
    (29) simple_assignment -> . ID EQUALS expressionTab SEMICOLON
    (44) simple_assignment -> . ID EQUALS expression SEMICOLON
    (31) array_declarationTab -> . type ID LBRACKET INTEGER RBRACKET SEMICOLON
    (43) declaration_assignment -> . type ID EQUALS expression SEMICOLON
    (42) array_assignment -> . ID LBRACKET expressionTab RBRACKET EQUALS expressionTab SEMICOLON
    (30) const_declarationTab -> . CONST type ID EQUALS expressionTab SEMICOLON

    RBRACE          reduce using rule 21 (statements -> statement .)
    CONST           shift and go to state 3
    ID              shift and go to state 4
    FOR             shift and go to state 10
    INT_TYPE        shift and go to state 11
    FLOAT_TYPE      shift and go to state 12
    BOOL_TYPE       shift and go to state 13
    CHAR_TYPE       shift and go to state 14

    statement                      shift and go to state 114
    statements                     shift and go to state 116
    type                           shift and go to state 2
    simple_assignment              shift and go to state 5
    array_declarationTab           shift and go to state 6
    declaration_assignment         shift and go to state 7
    array_assignment               shift and go to state 8
    const_declarationTab           shift and go to state 9

state 115

    (58) block -> LBRACE statements RBRACE .

    $end            reduce using rule 58 (block -> LBRACE statements RBRACE .)
    CONST           reduce using rule 58 (block -> LBRACE statements RBRACE .)
    ID              reduce using rule 58 (block -> LBRACE statements RBRACE .)
    FOR             reduce using rule 58 (block -> LBRACE statements RBRACE .)
    INT_TYPE        reduce using rule 58 (block -> LBRACE statements RBRACE .)
    FLOAT_TYPE      reduce using rule 58 (block -> LBRACE statements RBRACE .)
    BOOL_TYPE       reduce using rule 58 (block -> LBRACE statements RBRACE .)
    CHAR_TYPE       reduce using rule 58 (block -> LBRACE statements RBRACE .)
    RBRACE          reduce using rule 58 (block -> LBRACE statements RBRACE .)


state 116

    (22) statements -> statement statements .

    RBRACE          reduce using rule 22 (statements -> statement statements .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for SEMICOLON in state 54 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 79 resolved as shift
WARNING: reduce/reduce conflict in state 17 resolved using rule (declaration -> ID)
WARNING: rejected rule (declarationTab -> ID) in state 17
WARNING: reduce/reduce conflict in state 31 resolved using rule (expressionTab -> ID)
WARNING: rejected rule (factor -> ID) in state 31
WARNING: reduce/reduce conflict in state 35 resolved using rule (factor -> FLOAT)
WARNING: rejected rule (expressionTab -> FLOAT) in state 35
WARNING: reduce/reduce conflict in state 36 resolved using rule (factor -> INTEGER)
WARNING: rejected rule (expressionTab -> INTEGER) in state 36
WARNING: reduce/reduce conflict in state 37 resolved using rule (factor -> CHAR)
WARNING: rejected rule (expressionTab -> CHAR) in state 37
WARNING: reduce/reduce conflict in state 62 resolved using rule (statement -> ID EQUALS expression SEMICOLON)
WARNING: rejected rule (simple_assignment -> ID EQUALS expression SEMICOLON) in state 62
WARNING: Rule (simple_assignment -> ID EQUALS expression SEMICOLON) is never reduced
