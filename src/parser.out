Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    BOOL
    COLON
    COMMENT
    DECLARATION
    DIVIDE
    ELSE
    EQ
    FOR
    GT
    GTE
    IF
    INSTRUCTION
    LBRACE
    LPAREN
    LT
    LTE
    MINUS
    MULTIPLY
    NEQ
    NOT
    OR
    PLUS
    RBRACE
    READ
    RPAREN
    VAR_GLOBAL
    WRITE

Grammar

Rule 0     S' -> statement
Rule 1     statement -> type declaration_list SEMICOLON
Rule 2     statement -> CONST type ID EQUALS expression SEMICOLON
Rule 3     declaration_list -> declaration
Rule 4     declaration_list -> declaration COMMA declaration_list
Rule 5     declaration -> ID
Rule 6     declaration -> ID EQUALS expression
Rule 7     declaration -> ID LBRACKET NUMBER RBRACKET
Rule 8     expression -> ID
Rule 9     expression -> FLOAT
Rule 10    expression -> INT
Rule 11    expression -> CHAR
Rule 12    type -> INT_TYPE
Rule 13    type -> FLOAT_TYPE
Rule 14    type -> BOOL_TYPE
Rule 15    type -> CHAR_TYPE

Terminals, with rules where they appear

AND                  : 
BOOL                 : 
BOOL_TYPE            : 14
CHAR                 : 11
CHAR_TYPE            : 15
COLON                : 
COMMA                : 4
COMMENT              : 
CONST                : 2
DECLARATION          : 
DIVIDE               : 
ELSE                 : 
EQ                   : 
EQUALS               : 2 6
FLOAT                : 9
FLOAT_TYPE           : 13
FOR                  : 
GT                   : 
GTE                  : 
ID                   : 2 5 6 7 8
IF                   : 
INSTRUCTION          : 
INT                  : 10
INT_TYPE             : 12
LBRACE               : 
LBRACKET             : 7
LPAREN               : 
LT                   : 
LTE                  : 
MINUS                : 
MULTIPLY             : 
NEQ                  : 
NOT                  : 
NUMBER               : 7
OR                   : 
PLUS                 : 
RBRACE               : 
RBRACKET             : 7
READ                 : 
RPAREN               : 
SEMICOLON            : 1 2
VAR_GLOBAL           : 
WRITE                : 
error                : 

Nonterminals, with rules where they appear

declaration          : 3 4
declaration_list     : 1 4
expression           : 2 6
statement            : 0
type                 : 1 2

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . type declaration_list SEMICOLON
    (2) statement -> . CONST type ID EQUALS expression SEMICOLON
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE
    (15) type -> . CHAR_TYPE

    CONST           shift and go to state 3
    INT_TYPE        shift and go to state 4
    FLOAT_TYPE      shift and go to state 5
    BOOL_TYPE       shift and go to state 6
    CHAR_TYPE       shift and go to state 7

    statement                      shift and go to state 1
    type                           shift and go to state 2

state 1

    (0) S' -> statement .



state 2

    (1) statement -> type . declaration_list SEMICOLON
    (3) declaration_list -> . declaration
    (4) declaration_list -> . declaration COMMA declaration_list
    (5) declaration -> . ID
    (6) declaration -> . ID EQUALS expression
    (7) declaration -> . ID LBRACKET NUMBER RBRACKET

    ID              shift and go to state 10

    declaration_list               shift and go to state 8
    declaration                    shift and go to state 9

state 3

    (2) statement -> CONST . type ID EQUALS expression SEMICOLON
    (12) type -> . INT_TYPE
    (13) type -> . FLOAT_TYPE
    (14) type -> . BOOL_TYPE
    (15) type -> . CHAR_TYPE

    INT_TYPE        shift and go to state 4
    FLOAT_TYPE      shift and go to state 5
    BOOL_TYPE       shift and go to state 6
    CHAR_TYPE       shift and go to state 7

    type                           shift and go to state 11

state 4

    (12) type -> INT_TYPE .

    ID              reduce using rule 12 (type -> INT_TYPE .)


state 5

    (13) type -> FLOAT_TYPE .

    ID              reduce using rule 13 (type -> FLOAT_TYPE .)


state 6

    (14) type -> BOOL_TYPE .

    ID              reduce using rule 14 (type -> BOOL_TYPE .)


state 7

    (15) type -> CHAR_TYPE .

    ID              reduce using rule 15 (type -> CHAR_TYPE .)


state 8

    (1) statement -> type declaration_list . SEMICOLON

    SEMICOLON       shift and go to state 12


state 9

    (3) declaration_list -> declaration .
    (4) declaration_list -> declaration . COMMA declaration_list

    SEMICOLON       reduce using rule 3 (declaration_list -> declaration .)
    COMMA           shift and go to state 13


state 10

    (5) declaration -> ID .
    (6) declaration -> ID . EQUALS expression
    (7) declaration -> ID . LBRACKET NUMBER RBRACKET

    COMMA           reduce using rule 5 (declaration -> ID .)
    SEMICOLON       reduce using rule 5 (declaration -> ID .)
    EQUALS          shift and go to state 14
    LBRACKET        shift and go to state 15


state 11

    (2) statement -> CONST type . ID EQUALS expression SEMICOLON

    ID              shift and go to state 16


state 12

    (1) statement -> type declaration_list SEMICOLON .

    $end            reduce using rule 1 (statement -> type declaration_list SEMICOLON .)


state 13

    (4) declaration_list -> declaration COMMA . declaration_list
    (3) declaration_list -> . declaration
    (4) declaration_list -> . declaration COMMA declaration_list
    (5) declaration -> . ID
    (6) declaration -> . ID EQUALS expression
    (7) declaration -> . ID LBRACKET NUMBER RBRACKET

    ID              shift and go to state 10

    declaration                    shift and go to state 9
    declaration_list               shift and go to state 17

state 14

    (6) declaration -> ID EQUALS . expression
    (8) expression -> . ID
    (9) expression -> . FLOAT
    (10) expression -> . INT
    (11) expression -> . CHAR

    ID              shift and go to state 18
    FLOAT           shift and go to state 20
    INT             shift and go to state 21
    CHAR            shift and go to state 22

    expression                     shift and go to state 19

state 15

    (7) declaration -> ID LBRACKET . NUMBER RBRACKET

    NUMBER          shift and go to state 23


state 16

    (2) statement -> CONST type ID . EQUALS expression SEMICOLON

    EQUALS          shift and go to state 24


state 17

    (4) declaration_list -> declaration COMMA declaration_list .

    SEMICOLON       reduce using rule 4 (declaration_list -> declaration COMMA declaration_list .)


state 18

    (8) expression -> ID .

    COMMA           reduce using rule 8 (expression -> ID .)
    SEMICOLON       reduce using rule 8 (expression -> ID .)


state 19

    (6) declaration -> ID EQUALS expression .

    COMMA           reduce using rule 6 (declaration -> ID EQUALS expression .)
    SEMICOLON       reduce using rule 6 (declaration -> ID EQUALS expression .)


state 20

    (9) expression -> FLOAT .

    COMMA           reduce using rule 9 (expression -> FLOAT .)
    SEMICOLON       reduce using rule 9 (expression -> FLOAT .)


state 21

    (10) expression -> INT .

    COMMA           reduce using rule 10 (expression -> INT .)
    SEMICOLON       reduce using rule 10 (expression -> INT .)


state 22

    (11) expression -> CHAR .

    COMMA           reduce using rule 11 (expression -> CHAR .)
    SEMICOLON       reduce using rule 11 (expression -> CHAR .)


state 23

    (7) declaration -> ID LBRACKET NUMBER . RBRACKET

    RBRACKET        shift and go to state 25


state 24

    (2) statement -> CONST type ID EQUALS . expression SEMICOLON
    (8) expression -> . ID
    (9) expression -> . FLOAT
    (10) expression -> . INT
    (11) expression -> . CHAR

    ID              shift and go to state 18
    FLOAT           shift and go to state 20
    INT             shift and go to state 21
    CHAR            shift and go to state 22

    expression                     shift and go to state 26

state 25

    (7) declaration -> ID LBRACKET NUMBER RBRACKET .

    COMMA           reduce using rule 7 (declaration -> ID LBRACKET NUMBER RBRACKET .)
    SEMICOLON       reduce using rule 7 (declaration -> ID LBRACKET NUMBER RBRACKET .)


state 26

    (2) statement -> CONST type ID EQUALS expression . SEMICOLON

    SEMICOLON       shift and go to state 27


state 27

    (2) statement -> CONST type ID EQUALS expression SEMICOLON .

    $end            reduce using rule 2 (statement -> CONST type ID EQUALS expression SEMICOLON .)

